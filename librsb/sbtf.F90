! /*
! 
! Copyright (C) 2008-2022 Michele Martone
! 
! This file is part of librsb.
! 
! librsb is free software; you can redistribute it and/or modify it
! under the terms of the GNU Lesser General Public License as published
! by the Free Software Foundation; either version 3 of the License, or
! (at your option) any later version.
! 
! librsb is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
! FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
! License for more details.
! 
! You should have received a copy of the GNU Lesser General Public
! License along with librsb; see the file COPYING.
! If not, see <http://www.gnu.org/licenses/>.
! 
! */
!
!> @cond INNERDOC
!> @file
!> @author Michele Martone 
!> @brief This file is part of the Octave based test suite for librsb
!
! Sparse BLAS fortran interface testing code
!
! FIXME: missing library initialization!
! FIXME: using zero based indices is only partially supprted!
!
! 
      SUBROUTINE ts_sg_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 12/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 1/)
      REAL*4 :: VA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/12, 3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 1
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*4 :: VA(4)=&
          &(/1, 1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/15, 9/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 1/)
      REAL*4 :: VA(2)=(/1, 3/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 12, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 1
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/9, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 3
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/6, 15/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 5
! 1 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*4 :: VA(4)=&
          &(/1, 5, 1, 2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 24, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/5, 3/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/4, 5/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 3
! 4 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 4/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/8, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 4
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: VA(3)=&
          &(/1, 4, 3/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/8, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 1/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 1
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*4 :: VA(4)=&
          &(/1, 1, 1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/4, 3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 1
! 6 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*4 :: VA(4)=&
          &(/1, 1, 6, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/10, 5/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 1
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*4 :: VA(4)=&
          &(/1, 1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/5, 5/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 3
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/7, 0, 4, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 1
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*4 :: VA(4)=&
          &(/1, 1, 2, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 4
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*4 :: VA(4)=&
          &(/1, 4, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 8, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 1/)
      REAL*4 :: VA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 2
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/2, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 2
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 1
! 1 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*4 :: VA(4)=&
          &(/1, 1, 1, 2/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 1/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 2
! 3 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*4 :: VA(4)=&
          &(/1, 2, 3, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-1, 0, -1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/2, 3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 1
! 1 3

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*4 :: VA(4)=&
          &(/1, 1, 1, 3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/1, -1/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/2, 3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 1/)
      REAL*4 :: VA(2)=(/1, 2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 1
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 2, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 5 4

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 5, 4/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, -24/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/0, 3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/0, -3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 1/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-3, 0, 3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 3
! 2 4

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*4 :: VA(4)=&
          &(/1, 3, 2, 4/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-6, 0, -18, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 1/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, 3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, -3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 3
! 0 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-9, 0, -3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, -3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 2
! 3 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*4 :: VA(4)=&
          &(/1, 2, 3, 2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-9, 0, -9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(4:),pone,pone,IA(4:),JA(4:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_de_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 1
! 0 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 5

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 5/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 18/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 2 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/12, 9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 4
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 4/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 15, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/12, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 1
! 1 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 1, 1, 2/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/9, 12/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 6
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: VA(3)=&
          &(/1, 6, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/12, 21/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 1
! 1 3

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 1, 1, 3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/9, 15/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 2
! 1 3

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 2, 1, 3/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 18, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(4:),pone,pone,IA(4:),JA(4:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 3
! 3 3

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 3, 3, 3/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/15, 0, 21, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 2
! 2 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 2, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 7/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 3
! 2 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 3, 2, 2/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 8/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 1
! 1 4

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 1, 1, 4/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/5, 8/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 2/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 5, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 1 3

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/4, 7/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 0 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/4, 5/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/5, 4/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 3
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/7, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 3
! 0 3

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 3/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 1/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/5, 0, 3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/2, 3/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 3

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 3/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/2, 0/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 1
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 1
! 3 3

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 1, 3, 3/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-1, 0, -1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 3/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 1/)
      REAL*8 :: VA(2)=(/1, 2/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/0, 3/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 3
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-1, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 1
! 2 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 1, 2, 2/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 4 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 4, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/-3, 3/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 3/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 3/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-3, 0, 3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 1
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-6, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 1
! 1 2

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 1, 1, 2/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-3, 0, -6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/-3, 3/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 1
! 3 3

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 1, 3, 3/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/-9, -9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/0, -3/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 2/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-6, 0, 3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 1
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      REAL*8 :: VA(4)=&
          &(/1, 1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-6, 0, -3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_de_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+2i 0+2i
! 0+2i 0+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,2.e0), (0.e0,2.e0), (0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,12.e0), (3,18)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+2i 2+0i
! 3+0i 3+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,0.e0), (3.e0,0.e0), (3,2)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(15.e0,6.e0), (18,6)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(4:),pone,pone,IA(4:),JA(4:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+2i 3+3i
! 3+3i 2+8i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (3.e0,3.e0), (3.e0,3.e0), (2,8)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(15.e0,-15.e0), (18,-33)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+2i 2+3i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (2.e0,3.e0), (1,3)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(12.e0,15.e0), (0.e0,0.e0), (6.e0,9.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+2i 0+4i
! 3+4i 1+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,4.e0), (3.e0,4.e0), (1,4)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(15.e0,18.e0), (0.e0,0.e0), (6.e0,24.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+2i 0+7i
! 2+7i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (0.e0,7.e0), (2,7)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(12.e0,-27.e0), (0.e0,0.e0), (3.e0,-21.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+2i 2+3i
! 4+3i 2+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,3.e0), (4.e0,3.e0), (2,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(12.e0,15.e0), (21,9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+2i 3+4i
! 0+4i 0+6i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (3.e0,4.e0), (0.e0,4.e0), (0,6)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,18.e0), (12,30)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+2i 0+1i
! 0+1i 0+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,1.e0), (0.e0,1.e0), (0,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,-9.e0), (3,-9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+2i 1+2i
! 1+2i 2+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (1.e0,2.e0), (1.e0,2.e0), (2,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(9.e0,12.e0), (0.e0,0.e0), (12.e0,12.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(4:),pone,pone,IA(4:),JA(4:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+2i 1+7i
! 0+7i 1+6i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (1.e0,7.e0), (0.e0,7.e0), (1,6)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,27.e0), (0.e0,0.e0), (9.e0,39.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+2i 0+8i
! 0+8i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (0.e0,8.e0), (0,8)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,-30.e0), (0.e0,0.e0), (3.e0,-24.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+2i 1+1i
! 1+1i 0+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (1.e0,1.e0), (1.e0,1.e0), (0,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(5.e0,3.e0), (4,3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+2i 0+1i
! 3+1i 2+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,1.e0), (3.e0,1.e0), (2,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(7.e0,3.e0), (5,1)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+2i 0+2i
! 0+2i 3+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,2.e0), (0.e0,2.e0), (3,2)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,-4.e0), (6,-4)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+2i 0+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (0.e0,1.e0), (0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(4.e0,3.e0), (0.e0,0.e0), (3.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+2i 3+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (3.e0,1.e0), (0,1)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(4.e0,3.e0), (0.e0,0.e0), (6.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+2i 0+0i
! 4+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (4.e0,0.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(8.e0,-2.e0), (0.e0,0.e0), (4.e0,0.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+2i 0+3i
! 0+3i 3+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,3.e0), (0.e0,3.e0), (3,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(4.e0,5.e0), (6,3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+2i 2+1i
! 0+1i 3+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,1.e0), (0.e0,1.e0), (3,4)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(4.e0,3.e0), (8,5)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(4:),pone,pone,IA(4:),JA(4:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+2i 3+0i
! 1+0i 0+6i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (3.e0,0.e0), (1.e0,0.e0), (0,6)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(5.e0,-2.e0), (6,-6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+2i 0+4i
! 1+4i 2+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,4.e0), (1.e0,4.e0), (2,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(4.e0,6.e0), (0.e0,0.e0), (6.e0,8.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+2i 0+5i
! 2+5i 1+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,5.e0), (2.e0,5.e0), (1,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,7.e0), (0.e0,0.e0), (4.e0,7.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+2i 1+2i
! 3+2i 2+6i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (1.e0,2.e0), (3.e0,2.e0), (2,6)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(7.e0,-4.e0), (0.e0,0.e0), (6.e0,-8.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+2i 0+3i
! 2+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (0.e0,3.e0), (2,3)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,-5.e0), (1,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+2i 2+0i
! 0+0i 3+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (2.e0,0.e0), (3,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(2.e0,-2.e0), (-2,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+2i 0+1i
! 0+1i 3+10i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,1.e0), (0.e0,1.e0), (3,10)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(2.e0,3.e0), (0,11)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+2i 2+3i
! 0+3i 0+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,3.e0), (0.e0,3.e0), (0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,-5.e0), (0.e0,0.e0), (3.e0,-7.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+2i 0+3i
! 0+3i 2+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,3.e0), (0.e0,3.e0), (2,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,-5.e0), (0.e0,0.e0), (1.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+2i 0+4i
! 2+4i 0+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,4.e0), (2.e0,4.e0), (0,4)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,6.e0), (0.e0,0.e0), (3.e0,8.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+2i 1+0i
! 0+0i 3+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (1.e0,0.e0), (3,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(1.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+2i 2+1i
! 0+1i 1+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,1.e0), (0.e0,1.e0), (1,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,-3.e0), (0,-5)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+2i 1+5i
! 0+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (1.e0,5.e0), (0,5)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,7.e0), (2,5)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+2i 0+0i
! 0+0i 0+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/(1.e0,2.e0), (0,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,-2.e0), (0.e0,0.e0), (3.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+2i 2+5i
! 0+5i 3+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,5.e0), (0.e0,5.e0), (3,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,-7.e0), (0.e0,0.e0), (-2.e0,-5.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+2i 4+0i
! 0+0i 0+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (4.e0,0.e0), (0,4)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,2.e0), (0.e0,0.e0), (-1.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+2i 0+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (0.e0,3.e0), (0,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,-15.e0), (3,-9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+2i 1+2i
! 1+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (1.e0,2.e0), (1,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(-3.e0,-12.e0), (0,-6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+2i 2+2i
! 0+2i 1+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,2.e0), (0.e0,2.e0), (1,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,12.e0), (-6,12)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+2i 1+6i
! 0+6i 0+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (1.e0,6.e0), (0.e0,6.e0), (0,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-3.e0,-24.e0), (0.e0,0.e0), (3.e0,-24.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+2i 4+1i
! 2+1i 3+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (4.e0,1.e0), (2.e0,1.e0), (3,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-6.e0,-9.e0), (0.e0,0.e0), (-18.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+2i 0+1i
! 0+1i 4+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,1.e0), (0.e0,1.e0), (4,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,9.e0), (0.e0,0.e0), (-9.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+2i 0+2i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (0.e0,2.e0), (0,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,-12.e0), (3,-6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+2i 0+5i
! 0+5i 3+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,5.e0), (0.e0,5.e0), (3,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,-21.e0), (-6,-15)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+2i 0+2i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,2.e0), (0.e0,2.e0), (2,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(-6.e0,12.e0), (3,6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+2i 3+1i
! 3+1i 3+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (3.e0,1.e0), (3.e0,1.e0), (3,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-9.e0,-9.e0), (0.e0,0.e0), (-15.e0,-9.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+2i 1+0i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/(1.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,-6.e0), (0.e0,0.e0), (0.e0,0.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+2i 0+6i
! 0+6i 2+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*8 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,6.e0), (0.e0,6.e0), (2,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,24.e0), (0.e0,0.e0), (-3.e0,18.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_de_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+2i 0+0i
! 1+0i 2+8i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (1.e0,0.e0), (2,8)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(6.e0,6.e0), (12,24)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+2i 1+1i
! 0+1i 0+6i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (1.e0,1.e0), (0.e0,1.e0), (0,6)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(6.e0,9.e0), (6,21)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+2i 0+1i
! 1+1i 0+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,1.e0), (1.e0,1.e0), (0,2)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(9.e0,-9.e0), (3,-9)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+2i 0+0i
! 2+0i 3+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (2.e0,0.e0), (3,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,6.e0), (0.e0,0.e0), (18.e0,6.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+2i 3+6i
! 0+6i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (3.e0,6.e0), (0,6)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,24.e0), (0.e0,0.e0), (12.e0,18.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+2i 0+5i
! 1+5i 1+6i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,5.e0), (1.e0,5.e0), (1,6)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(9.e0,-21.e0), (0.e0,0.e0), (6.e0,-33.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+2i 1+1i
! 0+1i 1+6i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (1.e0,1.e0), (0.e0,1.e0), (1,6)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(9.e0,9.e0), (6,21)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+2i 0+3i
! 2+3i 6+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,3.e0), (2.e0,3.e0), (6,2)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(12.e0,15.e0), (21,15)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+2i 1+6i
! 0+6i 3+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (1.e0,6.e0), (0.e0,6.e0), (3,4)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(6.e0,-24.e0), (15,-30)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+2i 2+6i
! 1+6i 2+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,6.e0), (1.e0,6.e0), (2,4)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(12.e0,24.e0), (0.e0,0.e0), (12.e0,30.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+2i 2+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (2.e0,3.e0), (0,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,15.e0), (0.e0,0.e0), (9.e0,9.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+2i 1+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (1.e0,1.e0), (0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,-9.e0), (0.e0,0.e0), (6.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+2i 0+3i
! 0+3i 3+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,3.e0), (0.e0,3.e0), (3,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,5.e0), (6,5)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+2i 1+3i
! 0+3i 0+10i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (1.e0,3.e0), (0.e0,3.e0), (0,10)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,5.e0), (4,13)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+2i 1+0i
! 0+0i 0+6i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (1.e0,0.e0), (0,6)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(4.e0,-2.e0), (4,-6)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+2i 2+2i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,2.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,4.e0), (0.e0,0.e0), (4.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+2i 3+3i
! 2+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (3.e0,3.e0), (2.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,5.e0), (0.e0,0.e0), (7.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+2i 0+3i
! 0+3i 0+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,3.e0), (0.e0,3.e0), (0,4)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,-5.e0), (0.e0,0.e0), (3.e0,-7.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+2i 0+1i
! 0+1i 4+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,1.e0), (0.e0,1.e0), (4,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,3.e0), (7,1)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+2i 0+2i
! 0+2i 4+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,2.e0), (0.e0,2.e0), (4,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,4.e0), (7,2)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+2i 2+1i
! 0+1i 3+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,1.e0), (0.e0,1.e0), (3,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,-3.e0), (8,-3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+2i 0+3i
! 0+3i 3+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,3.e0), (0.e0,3.e0), (3,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,5.e0), (0.e0,0.e0), (6.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+2i 2+4i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (2.e0,4.e0), (0,4)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,6.e0), (0.e0,0.e0), (5.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+2i 1+2i
! 3+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (1.e0,2.e0), (3,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(7.e0,-4.e0), (0.e0,0.e0), (4.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+2i 0+2i
! 1+2i 0+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,2.e0), (1.e0,2.e0), (0,4)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(2.e0,-4.e0), (2,-6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+2i 0+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (0.e0,1.e0), (0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(2.e0,-3.e0), (3,-1)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+2i 4+3i
! 0+3i 0+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (4.e0,3.e0), (0.e0,3.e0), (0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(2.e0,5.e0), (-1,7)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+2i 0+3i
! 0+3i 1+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,3.e0), (0.e0,3.e0), (1,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,-5.e0), (0.e0,0.e0), (2.e0,-5.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+2i 0+6i
! 4+6i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,6.e0), (4.e0,6.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-2.e0,-8.e0), (0.e0,0.e0), (2.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+2i 0+2i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (0.e0,2.e0), (0,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,4.e0), (0.e0,0.e0), (3.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+2i 2+4i
! 3+4i 0+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,4.e0), (3.e0,4.e0), (0,2)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,-6.e0), (0,-6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+2i 2+0i
! 1+0i 3+6i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,0.e0), (1.e0,0.e0), (3,6)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(1.e0,-2.e0), (-2,-6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+2i 0+1i
! 2+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (0.e0,1.e0), (2,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,3.e0), (3,1)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+2i 2+1i
! 1+1i 2+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,1.e0), (1.e0,1.e0), (2,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,-3.e0), (0.e0,0.e0), (0.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+2i 0+0i
! 1+0i 0+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (1.e0,0.e0), (0,4)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(1.e0,-2.e0), (0.e0,0.e0), (3.e0,-4.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+2i 0+0i
! 0+0i 0+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/(1.e0,2.e0), (0,2)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,2.e0), (0.e0,0.e0), (3.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+2i 0+1i
! 4+1i 2+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,1.e0), (4.e0,1.e0), (2,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,-9.e0), (-15,-3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+2i 0+3i
! 0+3i 5+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,3.e0), (0.e0,3.e0), (5,2)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,-15.e0), (-12,-15)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+2i 0+0i
! 3+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 1/)
      COMPLEX*16 :: VA(2)=(/(1.e0,2.e0), (3,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-9.e0,6.e0), (3,0)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+2i 1+2i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (1.e0,2.e0), (0,2)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-3.e0,-12.e0), (0.e0,0.e0), (3.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+2i 2+1i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,1.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,-9.e0), (0.e0,0.e0), (-6.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+2i 0+4i
! 0+4i 1+4i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,4.e0), (0.e0,4.e0), (1,4)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,18.e0), (0.e0,0.e0), (0.e0,24.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(4:),pone,pone,IA(4:),JA(4:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+2i 1+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,2.e0), (1.e0,3.e0), (0,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-3.e0,-15.e0), (3,-9)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+2i 2+1i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (2.e0,1.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,-9.e0), (-6,-3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(4),IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+2i 0+0i
! 3+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 1/)
      COMPLEX*16 :: VA(2)=(/(1.e0,2.e0), (3,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-9.e0,6.e0), (3,0)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+2i 1+1i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (1.e0,1.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-3.e0,-9.e0), (0.e0,0.e0), (0.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+2i 0+2i
! 3+2i 0+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,2.e0), (3.e0,2.e0), (0,2)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-9.e0,-12.e0), (0.e0,0.e0), (3.e0,-12.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+2i 0+1i
! 0+1i 0+2i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=4
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(4)=&
          &(/1, 1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(4)=&
          &(/1, 2, 1, 2/)
      COMPLEX*16 :: VA(4)=&
          &(/(1.e0,2.e0), (0.e0,1.e0), (0.e0,1.e0), (0,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,9.e0), (0.e0,0.e0), (3.e0,9.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(4:),pone,pone,IA(4),JA(4),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_de_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/6, 3/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 3
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/3, 12/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/3, 3/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 3
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(4)=&
          &(/3, 0, 12, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 2/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/2, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 2, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 2
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(2,1)=(reshape((/-3, -1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 3
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/-1, -4/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 4
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 4, 1/)
      REAL*4 :: x(2)=(/-1, -5/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/-3, -3/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/-3, -3/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/-3, -3/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/-6, 0, -3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 3
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 15/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/5, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/-3, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_de_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/3, 3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/3, 3/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2,1)=(reshape((/3, 6/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 2
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/9, 0, 3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 3
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/3, 0, 12, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 3
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*8 :: x(2)=(/1, 4/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2)=(/-2, -1/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/-1, -1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 5
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 5, 1/)
      REAL*8 :: x(2,1)=(reshape((/-1, -6/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(4)=&
          &(/-2, 0, -1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 2
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: x(4)=&
          &(/-1, 0, -3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 2
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: x(2)=(/-9, -3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2,1)=(reshape((/-3, -6/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 6
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 6, 1/)
      REAL*8 :: x(2)=(/-3, -21/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(4)=&
          &(/-3, 0, -6, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 2
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/12, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_de_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 1+3i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/(6.e0,9.e0), (3,0)/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/(3.e0,0.e0), (3,3)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 3+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/(3.e0,0.e0), (12,-6)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 2+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(9.e0,3.e0), (0.e0,0.e0), (3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 2+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/(3.e0,0.e0), (0.e0,0.e0), (9.e0,3.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 1+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/(3.e0,0.e0), (0.e0,0.e0), (6.e0,-6.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/2, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/(1.e0,0.e0), (1,-1)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 1+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(2.e0,1.e0), (0.e0,0.e0), (1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 2+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(1.e0,0.e0), (0.e0,0.e0), (3.e0,-1.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/-1, -1/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 3+5i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,5.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/(-1.e0,0.e0), (-4,-5)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*8 :: x(2)=(/-1, -2/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 1+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(-2.e0,-1.e0), (0.e0,0.e0), (-1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+5i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,5.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/(-1.e0,0.e0), (0.e0,0.e0), (-1.e0,5.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 1+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/(-6.e0,-6.e0), (-3,0)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*8 :: x(2)=(/-3, -6/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/-3, -6/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+3i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(-3.e0,0.e0), (0.e0,0.e0), (-3.e0,-9.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 3
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 3, 1/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/15, 6/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 1+4i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,4.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(6.e0,0.e0), (9,12)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+3i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(6.e0,0.e0), (6,-9)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,2.e0), (4,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 2+3i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,0.e0), (6,3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 1+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,0.e0), (5,-2)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 3+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(-1.e0,-1.e0), (2,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 1+3i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(2.e0,0.e0), (1,-3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 3
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/2, -1/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(0.e0,-3.e0), (0,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 3+5i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,5.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(0.e0,0.e0), (-9,-15)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(0.e0,0.e0), (0,3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_de_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(2)=(/3, 3/)! reference x 
      COMPLEX*16 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 3+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/(3.e0,0.e0), (12,3)/)! reference x 
      COMPLEX*16 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/(3.e0,0.e0), (3,-6)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/(3.e0,6.e0), (0.e0,0.e0), (3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+3i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/(1.e0,3.e0), (1,0)/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/(1.e0,0.e0), (1,2)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 3+3i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/(1.e0,0.e0), (4,-3)/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/(1.e0,0.e0), (0.e0,0.e0), (1.e0,1.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 1
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 2, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 3+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/(-4.e0,-2.e0), (-1,0)/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(2)=(/-1, -1/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/(-1.e0,0.e0), (-1,2)/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 2
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/-3, 0, -1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/(-1.e0,0.e0), (0.e0,0.e0), (-1.e0,-1.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 2+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/(-9.e0,-3.e0), (-3,0)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 2
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/-3, -9/)! reference x 
      COMPLEX*16 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/(-3.e0,0.e0), (-3,3)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 2
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: x(4)=&
          &(/-9, 0, -3, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 1+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/(-3.e0,0.e0), (0.e0,0.e0), (-6.e0,6.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(6.e0,3.e0), (6,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 2+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(6.e0,0.e0), (12,3)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+6i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,6.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(6.e0,0.e0), (6,-18)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+5i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,5.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(4.e0,5.e0), (4,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 2+6i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,6.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(4.e0,0.e0), (6,6)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+3i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(4.e0,0.e0), (4,-3)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 3+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(-1.e0,-2.e0), (2,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(2.e0,0.e0), (2,-1)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 2+2i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(2.e0,0.e0), (0,2)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+4i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(0.e0,-12.e0), (0,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 1+3i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(0.e0,0.e0), (-3,-9)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+1i
! 0+0i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 2, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(0.e0,0.e0), (0,3)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_de_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/3, 3/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2)=(/6, 3/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/3, 3/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(4)=&
          &(/3, 0, 9, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/6, 0, 3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 4 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 4, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 5/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/2, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 2, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2)=(/-1, -2/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(2,1)=(reshape((/-4, -1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/-1, -1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/-1, 0, -2, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/-2, 0, -1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(4)=&
          &(/-4, 0, -1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(2,1)=(reshape((/-3, -9/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/-3, -3/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/-3, -3/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/-3, 0, -6, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/-6, 0, -3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/7, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 5 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 5, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/-3, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, -9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/-9, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_de_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/3, 3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/3, 3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/3, 3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: x(4)=&
          &(/3, 0, 9, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*8 :: x(4)=&
          &(/12, 0, 3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 4 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 4, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/15, 0, 3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 5 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 5, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 6, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/-1, -3/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2,1)=(reshape((/-2, -1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/-1, -1/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/-1, 0, -3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/-3, -12/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/-3, -3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/-3, -3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(4)=&
          &(/-3, 0, -6, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/-6, 0, -3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/15, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/12, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/-1, 2/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/-3, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_de_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 5+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (5.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/(3.e0,0.e0), (18,3)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*8 :: x(2)=(/6, 3/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/9, 3/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(3.e0,0.e0), (0.e0,0.e0), (6.e0,6.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(3.e0,9.e0), (0.e0,0.e0), (3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 3+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/(1.e0,0.e0), (4,1)/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 2+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/(3.e0,-3.e0), (1,0)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(1.e0,0.e0), (0.e0,0.e0), (1.e0,4.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: x(4)=&
          &(/3, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(1.e0,-1.e0), (0.e0,0.e0), (1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/(-1.e0,0.e0), (-1,-1)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*8 :: x(2,1)=(reshape((/-2, -1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/(-1.e0,1.e0), (-1,0)/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 3, 1/)
      COMPLEX*8 :: x(4)=&
          &(/-4, 0, -1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(-1.e0,1.e0), (0.e0,0.e0), (-1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/-3, -3/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,5.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/(-3.e0,-15.e0), (-3,0)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*8 :: x(2)=(/-6, -3/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 2+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(-3.e0,0.e0), (0.e0,0.e0), (-9.e0,-3.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(-3.e0,-9.e0), (0.e0,0.e0), (-3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 3+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/(-12.e0,6.e0), (0.e0,0.e0), (-3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,5.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(6.e0,0.e0), (6,15)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,5.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(6.e0,15.e0), (6,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 2+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,4.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(12.e0,-12.e0), (6,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 1+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,4.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,0.e0), (5,4)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+8i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,8.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,8.e0), (4,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,-2.e0), (4,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(2.e0,0.e0), (1,-2)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(2.e0,-3.e0), (2,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+8i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,8.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(0.e0,-24.e0), (0,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_de_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/3, 6/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(2,1)=(reshape((/3, 3/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 5 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 5, 1/)
      COMPLEX*16 :: x(2,1)=(reshape((/18, 3/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/(3.e0,3.e0), (0.e0,0.e0), (3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 2+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/(1.e0,0.e0), (3,3)/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/(1.e0,1.e0), (1,0)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/(1.e0,-1.e0), (1,0)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 2+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/(1.e0,0.e0), (0.e0,0.e0), (3.e0,2.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 5 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 5, 1/)
      COMPLEX*16 :: x(4)=&
          &(/6, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/(1.e0,-4.e0), (0.e0,0.e0), (1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 2+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/(-1.e0,0.e0), (-3,-1)/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(2,1)=(reshape((/-1, -1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(2)=(/-1, -1/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/(-1.e0,0.e0), (0.e0,0.e0), (-1.e0,-3.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/(-1.e0,-1.e0), (0.e0,0.e0), (-1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/(-1.e0,2.e0), (0.e0,0.e0), (-1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/(-3.e0,0.e0), (-3,-3)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/-12, -3/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/(-3.e0,3.e0), (-3,0)/)! reference x 
      COMPLEX*16 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/(-3.e0,-9.e0), (0.e0,0.e0), (-3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/-6, 0, -3, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/6, 15/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(6.e0,6.e0), (6,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/12, 6/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 2+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(4.e0,0.e0), (6,3)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(4.e0,1.e0), (4,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,5.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(2.e0,0.e0), (2,-5)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/1, 2/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 3+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(-1.e0,3.e0), (2,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/0, -3/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(0.e0,-3.e0), (0,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=e blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_de_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/15, 15/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/12, 12/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/12, 0, 12, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/5, 5/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/7, 0, 7, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/7, 0, 7, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-1, 0, -1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/-3, -3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 4 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 4, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-12, 0, -12, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-6, 0, -6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/-3, -3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_de_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/5, 5/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/7, 0, 7, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/5, 5/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/-1, -1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 4 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 4, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/-2, -2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-1, 0, -1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/-1, -1/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/-3, -3/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 5 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 5, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-15, 0, -15, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/-3, -3/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/-3, -3/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/-6, -6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_de_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(6.e0,3.e0), (6,3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 3+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(15.e0,-6.e0), (15,-6)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 4 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 4, 1/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/18, 0, 18, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,6.e0), (0.e0,0.e0), (6.e0,6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 1+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,3.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(9.e0,-9.e0), (0.e0,0.e0), (9.e0,-9.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,6.e0), (6,6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 3+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(15.e0,3.e0), (15,3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,-3.e0), (6,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 3+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(15.e0,6.e0), (0.e0,0.e0), (15.e0,6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 1+6i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,6.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(9.e0,18.e0), (0.e0,0.e0), (9.e0,18.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,-6.e0), (0.e0,0.e0), (6.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 2+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(6.e0,3.e0), (6,3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,-1.e0), (4,-1)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 2+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,4.e0), (0.e0,0.e0), (6.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(5.e0,-2.e0), (0.e0,0.e0), (5.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(4.e0,4.e0), (4,4)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(4.e0,4.e0), (4,4)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 1+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(5.e0,-4.e0), (5,-4)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 3+6i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,6.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(7.e0,6.e0), (0.e0,0.e0), (7.e0,6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 4+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (4.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(8.e0,4.e0), (0.e0,0.e0), (8.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 3+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(-1.e0,-2.e0), (-1,-2)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 3+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,5.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(-1.e0,-5.e0), (-1,-5)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 4+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (4.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(-2.e0,4.e0), (-2,4)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,-1.e0), (0.e0,0.e0), (2.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,-1.e0), (0.e0,0.e0), (2.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,3.e0), (0.e0,0.e0), (2.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 3+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(-1.e0,-4.e0), (-1,-4)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,-3.e0), (2,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,4.e0), (2,4)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 1+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,5.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(1.e0,-5.e0), (0.e0,0.e0), (1.e0,-5.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,-2.e0), (0.e0,0.e0), (2.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,1.e0), (0.e0,0.e0), (2.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,-3.e0), (0,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(0.e0,-3.e0), (0,-3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 4+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (4.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(-12.e0,3.e0), (-12,3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 2+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-6.e0,-6.e0), (0.e0,0.e0), (-6.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,-12.e0), (0.e0,0.e0), (0.e0,-12.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,9.e0), (0.e0,0.e0), (0.e0,9.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/-3, -3/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/0, 0/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,12.e0), (0,12)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 2+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-6.e0,-6.e0), (0.e0,0.e0), (-6.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,3.e0), (0.e0,0.e0), (0.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_de_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/6, 6/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(6.e0,6.e0), (6,6)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 2+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(12.e0,-6.e0), (12,-6)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,12.e0), (0.e0,0.e0), (6.e0,12.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,9.e0), (0.e0,0.e0), (6.e0,9.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,-6.e0), (0.e0,0.e0), (6.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 1+7i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,7.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(9.e0,21.e0), (9,21)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(9.e0,6.e0), (9,6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(9.e0,-6.e0), (9,-6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,9.e0), (0.e0,0.e0), (6.e0,9.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+6i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,6.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,18.e0), (0.e0,0.e0), (6.e0,18.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,-3.e0), (0.e0,0.e0), (6.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 2+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(6.e0,1.e0), (6,1)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,2.e0), (4,2)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(4.e0,-4.e0), (4,-4)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(5.e0,2.e0), (0.e0,0.e0), (5.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 6 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 6, 1/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/10, 0, 10, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,-2.e0), (0.e0,0.e0), (4.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/6, 6/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 5+9i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (5.e0,9.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(9.e0,9.e0), (9,9)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,-2.e0), (4,-2)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,2.e0), (0.e0,0.e0), (4.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,3.e0), (0.e0,0.e0), (4.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 1+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(5.e0,-1.e0), (0.e0,0.e0), (5.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(2.e0,4.e0), (2,4)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 3+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-1.e0,-1.e0), (0.e0,0.e0), (-1.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,-1.e0), (0.e0,0.e0), (2.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,2.e0), (0.e0,0.e0), (2.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 1+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,4.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(1.e0,-4.e0), (1,-4)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 1+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(1.e0,1.e0), (1,1)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 3+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-1.e0,-3.e0), (0.e0,0.e0), (-1.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,-1.e0), (0.e0,0.e0), (2.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 1+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(1.e0,3.e0), (0.e0,0.e0), (1.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 3, 1/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/-9, -9/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 4 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 4, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/-12, -12/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 2+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(-6.e0,9.e0), (-6,9)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 3+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,5.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-9.e0,-15.e0), (0.e0,0.e0), (-9.e0,-15.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,5.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,-15.e0), (0.e0,0.e0), (0.e0,-15.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 3+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-9.e0,-6.e0), (-9,-6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,5.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,-15.e0), (0,-15)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/-3, -3/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/-6, 0, -6, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,9.e0), (0.e0,0.e0), (0.e0,9.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_de_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/15, 15/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/12, 0, 12, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/15, 0, 15, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/5, 5/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 4 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 4, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/8, 8/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/7, 7/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/7, 0, 7, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 5 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 5, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-1, 0, -1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/-3, -3/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-6, 0, -6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/-3, -3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/-3, -3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*4 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_de_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/15, 0, 15, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/12, 0, 12, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 4 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 4, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/8, 8/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/-1, -1/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-1, 0, -1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/-3, -3/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/-9, -9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 3, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/-9, -9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      REAL*8 :: VA(2)=(/1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 1, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      REAL*8 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-6, 0, -6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_de_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,-6.e0), (6,6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(9.e0,6.e0), (9,-6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(6.e0,-12.e0), (6,12)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,-6.e0), (0.e0,0.e0), (6.e0,6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,5.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,15.e0), (0.e0,0.e0), (6.e0,-15.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,-6.e0), (6,6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 2, 1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/12, 12/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,-12.e0), (0.e0,0.e0), (6.e0,12.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/12, 0, 12, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/15, 0, 15, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/5, 5/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,5.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,5.e0), (4,-5)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/5, 5/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(5.e0,-2.e0), (0.e0,0.e0), (5.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 3+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(7.e0,1.e0), (0.e0,0.e0), (7.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 2+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,-2.e0), (0.e0,0.e0), (6.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+6i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,6.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(4.e0,-6.e0), (4,6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(4.e0,2.e0), (4,-2)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/5, 5/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 3, 1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/7, 0, 7, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 3+6i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,6.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(7.e0,-6.e0), (0.e0,0.e0), (7.e0,6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 4+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (4.e0,2.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(-2.e0,2.e0), (-2,-2)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,-2.e0), (2,2)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(2.e0,2.e0), (2,-2)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,3.e0), (0.e0,0.e0), (2.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 1+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(1.e0,-4.e0), (0.e0,0.e0), (1.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 3+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,3.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-1.e0,3.e0), (0.e0,0.e0), (-1.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,3.e0), (2,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,2.e0), (2,-2)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 3, 1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/-1, 0, -1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 2+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,3.e0), (0.e0,0.e0), (0.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,9.e0), (0,-9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(0.e0,-3.e0), (0,3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,5.e0), (1,0)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(0.e0,15.e0), (0,-15)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,3.e0), (0.e0,0.e0), (0.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,-9.e0), (0.e0,0.e0), (0.e0,9.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 1+7i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,7.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(-3.e0,21.e0), (-3,-21)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 2+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,3.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(-6.e0,-9.e0), (-6,9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,4.e0), (1,0)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,12.e0), (0,-12)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,6.e0), (0.e0,0.e0), (0.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 4 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*8 :: VA(3)=&
          &(/1, 4, 1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/-12, 0, -12, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_de_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 3, 1/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/15, 15/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 2+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(12.e0,6.e0), (12,-6)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 5+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (5.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(21.e0,-6.e0), (21,6)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,-3.e0), (0.e0,0.e0), (6.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 4+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (4.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(18.e0,3.e0), (0.e0,0.e0), (18.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/6, 6/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(9.e0,6.e0), (9,-6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/6, 6/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,-3.e0), (0.e0,0.e0), (6.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 2+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(12.e0,6.e0), (0.e0,0.e0), (12.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1 0
! 1 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 1, 1/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/5, 5/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 2+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(6.e0,-2.e0), (6,2)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,-1.e0), (0.e0,0.e0), (4.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 1+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,1.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(5.e0,1.e0), (0.e0,0.e0), (5.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 3+4i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (3.e0,4.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(7.e0,-4.e0), (0.e0,0.e0), (7.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(5.e0,-2.e0), (5,2)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,1.e0), (4,-1)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,-2.e0), (4,2)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,-2.e0), (0.e0,0.e0), (4.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 2 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 2, 1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+8i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,8.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,-8.e0), (0.e0,0.e0), (4.e0,8.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(2.e0,1.e0), (2,-1)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/-1, -1/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(2.e0,3.e0), (2,-3)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(1.e0,2.e0), (0.e0,0.e0), (1.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(1.e0,-2.e0), (0.e0,0.e0), (1.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 1+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(1.e0,1.e0), (0.e0,0.e0), (1.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 1+6i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,6.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(1.e0,6.e0), (1,-6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+3i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,3.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(2.e0,-3.e0), (2,3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(2.e0,2.e0), (2,-2)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 2+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,1.e0), (0.e0,0.e0), (0.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,-1.e0), (0.e0,0.e0), (2.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,1.e0), (0.e0,0.e0), (2.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+6i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,6.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,18.e0), (0,-18)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 1+2i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (1.e0,2.e0), (1,0)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(-3.e0,-6.e0), (-3,6)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/0, 0/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 1+0i 0+0i
! 0+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,5.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,15.e0), (0.e0,0.e0), (0.e0,-15.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 1+0i 0+0i
! 2+5i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (2.e0,5.e0), (1,0)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-6.e0,-15.e0), (0.e0,0.e0), (-6.e0,15.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(3:),pone,pone,IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,3.e0), (0,-3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,-3.e0), (0,3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(3:),pone,pone,IA(3:),JA(3:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 1+0i 0+0i
! 0+1i 1+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/(1.e0,0.e0), (0.e0,1.e0), (1,0)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,3.e0), (0,-3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 1 0
! 3 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=3
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(3)=&
          &(/1, 2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(3)=&
          &(/1, 1, 2/)
      COMPLEX*16 :: VA(3)=&
          &(/1, 3, 1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/-9, 0, -9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(3),IA(3),JA(3),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=e blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 1 0
! 0 1

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/1, 2/)
      COMPLEX*16 :: VA(2)=(/1, 1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_de_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 6
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/6, 3/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/24, 15/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 5
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/5, 2/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/12, 0, 21, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/6, 12/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 2
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/2, 2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/12, 12/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 2
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/2, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/9, 12/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 3
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/3, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/15, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 5
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/5, 2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/12, 0, 21, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/5, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/4, 5/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/4, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 1
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/4, 5/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/7, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 2
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/2, 3/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/7, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 4
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/4/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/-2, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 3
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, -1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-1, 0, 2, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 4
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/4/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, -2, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 1
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/1, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/1, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 2
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/2, 1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 3
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/3, 2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, -1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/-6, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-3, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 2
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/2, 1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-3, 0, -6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 3
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/3/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/-9, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 1
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/-3, -3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/-9, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sg_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, -6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 3
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, -9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sg_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 4
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*4 :: VA(2)=(/4, 2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-6, 0, -12, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sg_di_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 3
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/3, 1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/15, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/6, 9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 2
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/2, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/9, 12/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 2
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/2, 3/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/12, 0, 15, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 1
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/1, 2/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/12, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 3
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/3, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/12, 0, 15, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/9, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 4
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/4/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/6, 18/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 1
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/1, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 2
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/2, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 12, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/12, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 1
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/1, 3/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/7, 5/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 2
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/2, 3/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/7, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/5, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/6, 4/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/4, 5/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 2
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/2, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/5, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/7, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 2
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/2, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/0, 1/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 1
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 2
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/2, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 6
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/6, 1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, -4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 1
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/1, 2/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 2
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/2, 3/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, -1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 2
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/2, 1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 3
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/3, 3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/-9, -9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 3
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/0, -9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 4
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/4/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/0, -12/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, -3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 6 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/6/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-18, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 1
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/1, 3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-9, 0, -3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 3
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/3, 1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/-9, -3/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sg_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, -3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 1
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      REAL*8 :: VA(2)=(/1, 3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-9, 0, -3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sg_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sg_di_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+6i
! 0+6i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(0.e0,6.e0), (0,6)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,18.e0), (6,18)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 2
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/2, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/12, 12/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/1/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 6, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+5i
! 0+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(0.e0,5.e0), (0,5)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,15.e0), (0.e0,0.e0), (6.e0,15.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(0.e0,1.e0), (0,1)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,3.e0), (6,3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(0.e0,1.e0), (0,1)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,3.e0), (6,3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 1
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/1, 1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 1+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(1.e0,3.e0), (0,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(9.e0,9.e0), (0.e0,0.e0), (6.e0,9.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/2/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/6, 0, 12, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 6, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(0.e0,3.e0), (0,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,3.e0), (4,3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/4, 4/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 4+4i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(4.e0,4.e0), (0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,-4.e0), (8,-4)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 2+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(2.e0,1.e0), (0,1)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,1.e0), (0.e0,0.e0), (4.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 2+4i
! 2+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(2.e0,4.e0), (2,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,4.e0), (0.e0,0.e0), (6.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 4+2i
! 1+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(4.e0,2.e0), (1,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(5.e0,-2.e0), (0.e0,0.e0), (8.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(0.e0,1.e0), (0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(4.e0,1.e0), (4,1)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 6+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(6.e0,1.e0), (0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(4.e0,1.e0), (10,1)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 4+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(4.e0,1.e0), (0,1)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(4.e0,-1.e0), (8,-1)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 2+1i
! 3+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(2.e0,1.e0), (3,1)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,1.e0), (0.e0,0.e0), (7.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 1+4i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(1.e0,4.e0), (0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(4.e0,4.e0), (0.e0,0.e0), (5.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 3+2i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(3.e0,2.e0), (0,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(4.e0,-2.e0), (0.e0,0.e0), (7.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 1+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(1.e0,3.e0), (0,3)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(1.e0,-3.e0), (2,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 3+2i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(3.e0,2.e0), (2,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,-2.e0), (-1,-2)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+1i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(0.e0,1.e0), (1,1)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(1.e0,1.e0), (2,1)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 2+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(2.e0,3.e0), (0,3)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,-3.e0), (0.e0,0.e0), (2.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/2, 0, 0, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+1i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(0.e0,1.e0), (1,1)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(1.e0,1.e0), (0.e0,0.e0), (2.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/2/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/2, 0/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 1+2i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(1.e0,2.e0), (0,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,-2.e0), (1,-2)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 2+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(2.e0,3.e0), (0,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,3.e0), (0,3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 1+4i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(1.e0,4.e0), (0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(1.e0,-4.e0), (0.e0,0.e0), (2.e0,-4.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 1+3i
! 6+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(1.e0,3.e0), (6,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-4.e0,-3.e0), (0.e0,0.e0), (1.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 2+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(2.e0,3.e0), (0,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,3.e0), (0.e0,0.e0), (0.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+2i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(0.e0,2.e0), (0,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(0.e0,-6.e0), (0,-6)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 1+2i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(1.e0,2.e0), (2,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(-6.e0,-6.e0), (-3,-6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 3+1i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(3.e0,1.e0), (1,1)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(-3.e0,3.e0), (-9,3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(0.e0,3.e0), (0,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,-9.e0), (0.e0,0.e0), (0.e0,-9.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 2+1i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(2.e0,1.e0), (1,1)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-3.e0,-3.e0), (0.e0,0.e0), (-6.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+1i
! 4+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(0.e0,1.e0), (4,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-12.e0,3.e0), (0.e0,0.e0), (0.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 4+4i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(4.e0,4.e0), (0,4)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(-12.e0,-12.e0), (0,-12)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 1+4i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(1.e0,4.e0), (0,4)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,-12.e0), (-3,-12)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 5
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/5, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/-6, -15/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sg_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(0.e0,1.e0), (0,1)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,-3.e0), (0.e0,0.e0), (0.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/2/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/-6, 0, 0, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sg_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 1+5i
! 3+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*8 :: VA(2)=(/(1.e0,5.e0), (3,5)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-9.e0,15.e0), (0.e0,0.e0), (-3.e0,15.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sg_di_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 3+4i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(3.e0,4.e0), (0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(15.e0,12.e0), (6,12)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/6, 6/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 1+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(1.e0,1.e0), (0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(9.e0,3.e0), (0.e0,0.e0), (6.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+6i
! 1+6i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,6.e0), (1,6)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(9.e0,18.e0), (0.e0,0.e0), (6.e0,18.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 2+4i
! 1+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(2.e0,4.e0), (1,4)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(9.e0,-12.e0), (0.e0,0.e0), (12.e0,-12.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 2+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(2.e0,1.e0), (0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(12.e0,3.e0), (6,3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 1+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(1.e0,3.e0), (0,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(6.e0,9.e0), (9,9)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 4+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(4.e0,3.e0), (0,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(6.e0,-9.e0), (18,-9)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,3.e0), (0,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,9.e0), (0.e0,0.e0), (6.e0,9.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+3i
! 2+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,3.e0), (2,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(12.e0,9.e0), (0.e0,0.e0), (6.e0,9.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 3+6i
! 0+6i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(3.e0,6.e0), (0,6)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,-18.e0), (0.e0,0.e0), (15.e0,-18.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+2i
! 3+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,2.e0), (3,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(7.e0,2.e0), (4,2)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 2+5i
! 0+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(2.e0,5.e0), (0,5)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(4.e0,-5.e0), (6,-5)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+1i
! 3+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,1.e0), (3,1)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,1.e0), (0.e0,0.e0), (7.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 3+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(3.e0,1.e0), (0,1)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,1.e0), (0.e0,0.e0), (7.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 2+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(2.e0,3.e0), (0,3)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,-3.e0), (0.e0,0.e0), (6.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+1i
! 5+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,1.e0), (5,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,1.e0), (9,1)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/2/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/6, 4/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+3i
! 3+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,3.e0), (3,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(7.e0,-3.e0), (4,-3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+2i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,2.e0), (0,2)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,2.e0), (0.e0,0.e0), (4.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+1i
! 2+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,1.e0), (2,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,1.e0), (0.e0,0.e0), (4.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,3.e0), (0,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,-3.e0), (0.e0,0.e0), (4.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 2+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(2.e0,1.e0), (0,1)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,-1.e0), (2,-1)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/2/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/2, 0/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 2+2i
! 3+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(2.e0,2.e0), (3,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(-1.e0,2.e0), (0,2)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/-1, 0, 2, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+4i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,4.e0), (0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,4.e0), (0.e0,0.e0), (2.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+2i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,2.e0), (2,2)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(2.e0,-2.e0), (0,-2)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+3i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,3.e0), (1,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(1.e0,-3.e0), (2,-3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+6i
! 3+6i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,6.e0), (3,6)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-1.e0,6.e0), (2,6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 4+3i
! 4+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(4.e0,3.e0), (4,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-2.e0,-3.e0), (0.e0,0.e0), (-2.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,1.e0), (0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,-1.e0), (0.e0,0.e0), (2.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,1.e0), (0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,1.e0), (0.e0,0.e0), (2.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 2
! 5 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/2, 5/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/-6, -15/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 4+2i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(4.e0,2.e0), (2,2)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-6.e0,-6.e0), (-12,-6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+1i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,1.e0), (0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,3.e0), (0,3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 2+4i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(2.e0,4.e0), (0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-6.e0,-12.e0), (0.e0,0.e0), (0.e0,-12.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 6+2i
! 1+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(6.e0,2.e0), (1,2)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-3.e0,-6.e0), (0.e0,0.e0), (-18.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+4i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,4.e0), (0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,12.e0), (0.e0,0.e0), (0.e0,12.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(2:),pone,pone,IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 1+1i
! 2+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(1.e0,1.e0), (2,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-3.e0,-3.e0), (-6,-3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(2),IA(2),JA(2),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/-3, 0/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+2i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,2.e0), (0,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,6.e0), (0,6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sg_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 2+3i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(2.e0,3.e0), (0,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-6.e0,-9.e0), (0.e0,0.e0), (0.e0,-9.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(2:),pone,pone,IA(2:),JA(2:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+6i
! 1+6i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(0.e0,6.e0), (1,6)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-3.e0,-18.e0), (0.e0,0.e0), (0.e0,-18.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sg_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=g diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 1+5i
! 2+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=2
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(2)=(/1, 2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(2)=(/2, 1/)
      COMPLEX*16 :: VA(2)=(/(1.e0,5.e0), (2,5)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-6.e0,15.e0), (0.e0,0.e0), (-3.e0,15.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sg_di_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/3, 3/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/3, 3/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/3, 3/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 5
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/5/)
      REAL*4 :: x(4)=&
          &(/3, 0, 18, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2,1)=(reshape((/1, 2/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(4)=&
          &(/3, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 2, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2,1)=(reshape((/-2, -1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2,1)=(reshape((/-1, -2/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2)=(/-1, -2/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/-1, 0, -2, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/-1, 0, -2, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/-9, -3/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 3
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/-3, -12/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/-3, -3/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/-6, 0, -3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/-3, 0, -9, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_su_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 4
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/4/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/18, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 6
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/6/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/4, 10/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*4 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/-6, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_su_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_su_di_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2,1)=(reshape((/6, 3/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/3, 3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/3, 3/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(4)=&
          &(/9, 0, 3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/3, 0, 6, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/3, 0, 9, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(2)=(/1, 3/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 2, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/-1, -1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 3
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/3/)
      REAL*8 :: x(2,1)=(reshape((/-1, -4/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(2,1)=(reshape((/-1, -3/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2)=(/-6, -3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(2,1)=(reshape((/-3, -9/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/-3, -3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(4)=&
          &(/-3, 0, -9, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_su_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 3
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/3/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 15/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 3
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/3/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 7/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 2/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_su_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 3
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      REAL*8 :: VA(1)=(/3/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, -9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_su_di_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 6+3i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(6,3)/)
      COMPLEX*8 :: x(2,1)=(reshape((/(21.e0,9.e0), (3,0)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/3, 3/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      COMPLEX*8 :: x(2)=(/(3.e0,0.e0), (3,-3)/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/6, 0, 3, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/3, 0, 9, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/1/)
      COMPLEX*8 :: x(4)=&
          &(/3, 0, 6, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+3i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/(1.e0,0.e0), (1,-3)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 1+3i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(1,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/(2.e0,3.e0), (0.e0,0.e0), (1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 2, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 1+3i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(1,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/(1.e0,0.e0), (0.e0,0.e0), (2.e0,-3.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 4
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/4/)
      COMPLEX*8 :: x(2,1)=(reshape((/-5, -1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/1/)
      COMPLEX*8 :: x(2)=(/-1, -2/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 3+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(3,1)/)
      COMPLEX*8 :: x(2)=(/(-1.e0,0.e0), (-4,1)/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 1+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(1,1)/)
      COMPLEX*8 :: x(4)=&
          &(/(-2.e0,-1.e0), (0.e0,0.e0), (-1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      COMPLEX*8 :: x(4)=&
          &(/(-1.e0,0.e0), (0.e0,0.e0), (-1.e0,-1.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      COMPLEX*8 :: x(4)=&
          &(/(-1.e0,0.e0), (0.e0,0.e0), (-1.e0,1.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 1+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(1,1)/)
      COMPLEX*8 :: x(2)=(/(-6.e0,-3.e0), (-3,0)/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/-3, -3/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: x(2,1)=(reshape((/-3, -3/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 3
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/3/)
      COMPLEX*8 :: x(4)=&
          &(/-12, 0, -3, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 2+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(2,1)/)
      COMPLEX*8 :: x(4)=&
          &(/(-3.e0,0.e0), (0.e0,0.e0), (-9.e0,-3.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_su_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 3
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/15, 6/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 1+4i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(1,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(6.e0,0.e0), (9,12)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/1/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/6, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 1+4i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(1,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(5.e0,4.e0), (4,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+3i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,0.e0), (4,3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,0.e0), (4,-1)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 1+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(1,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(1.e0,-1.e0), (2,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 1+4i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(1,4)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(2.e0,0.e0), (1,-4)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 2+2i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(2,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(2.e0,0.e0), (0,2)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(0.e0,-3.e0), (0,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 1+2i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(1,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(0.e0,0.e0), (-3,-6)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_su_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(0.e0,0.e0), (0,3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_su_di_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 2+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(2,1)/)
      COMPLEX*16 :: x(2)=(/(9.e0,3.e0), (3,0)/)! reference x 
      COMPLEX*16 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/3, 3/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2,1)=(reshape((/3, 3/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/(3.e0,3.e0), (0.e0,0.e0), (3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 3
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/3, 0, 12, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 2+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(2,1)/)
      COMPLEX*16 :: x(4)=&
          &(/(3.e0,0.e0), (0.e0,0.e0), (9.e0,-3.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 1+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(1,1)/)
      COMPLEX*16 :: x(2)=(/(2.e0,1.e0), (1,0)/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 3+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(3,1)/)
      COMPLEX*16 :: x(2,1)=(reshape((/(1.e0,0.e0), (4,1)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 3/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/1/)
      COMPLEX*16 :: x(4)=&
          &(/2, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 1
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 2, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 3
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 4, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(2,1)=(reshape((/(-1.e0,-1.e0), (-1,0)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+2i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(0,2)/)
      COMPLEX*16 :: x(2,1)=(reshape((/(-1.e0,0.e0), (-1,-2)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 1+4i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(1,4)/)
      COMPLEX*16 :: x(2)=(/(-1.e0,0.e0), (-2,4)/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 2+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(2,1)/)
      COMPLEX*16 :: x(4)=&
          &(/(-3.e0,-1.e0), (0.e0,0.e0), (-1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/(-1.e0,0.e0), (0.e0,0.e0), (-1.e0,-1.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 1+2i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(1,2)/)
      COMPLEX*16 :: x(4)=&
          &(/(-1.e0,0.e0), (0.e0,0.e0), (-2.e0,2.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2)=(/-3, -3/)! reference x 
      COMPLEX*16 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+3i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(0,3)/)
      COMPLEX*16 :: x(2,1)=(reshape((/(-3.e0,0.e0), (-3,-9)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+2i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(0,2)/)
      COMPLEX*16 :: x(2)=(/(-3.e0,0.e0), (-3,6)/)! reference x 
      COMPLEX*16 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/(-3.e0,0.e0), (0.e0,0.e0), (-3.e0,-3.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/(-3.e0,0.e0), (0.e0,0.e0), (-3.e0,3.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_upper_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_su_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 1+2i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(1,2)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(9.e0,6.e0), (6,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(6.e0,0.e0), (6,3)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 2
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/2/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/6, 12/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 2+4i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(2,4)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(6.e0,4.e0), (4,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 3+3i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(3,3)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(4.e0,0.e0), (7,3)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 2+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(2,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(0.e0,-1.e0), (2,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 5
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/5/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/2, -3/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(0.e0,-3.e0), (0,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+1i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(0.e0,0.e0), (0,-3)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_su_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=u diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 3+5i
! 0+0i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/2/)
      COMPLEX*16 :: VA(1)=(/(3,5)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(0.e0,0.e0), (-9,15)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_su_di_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/3, 9/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/3, 3/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/3, 3/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 5 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/5/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 6/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 4 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/4/)
      REAL*4 :: x(2,1)=(reshape((/5, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/2, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 2, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/2, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/3, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(2)=(/-1, -3/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2,1)=(reshape((/-2, -1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(2,1)=(reshape((/-3, -1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/-1, 0, -2, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(4)=&
          &(/-3, 0, -1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/-4, 0, -1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(2,1)=(reshape((/-3, -9/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/-3, -3/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/-3, -3/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/-3, 0, -6, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_sussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sl_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 12/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/9, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/5, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/5, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/1, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sl_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/-9, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sl_di_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/3, 3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/12, 3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 5 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/5/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/18, 3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/3, 0, 3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/6, 0, 3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/2, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 2, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      REAL*8 :: x(4)=&
          &(/4, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2)=(/-1, -2/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/-1, -1/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/-1, -1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/-1, 0, -2, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(4)=&
          &(/-3, 0, -1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/-3, -3/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/-6, -3/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(2,1)=(reshape((/-9, -3/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/-3, 0, -12, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/-6, 0, -3, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sl_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 12/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/9, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/9, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, -1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/-1, 2/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/-3, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sl_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sl_di_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/(3.e0,0.e0), (6,9)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/1/)
      COMPLEX*8 :: x(2)=(/6, 3/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 2+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,1)/)
      COMPLEX*8 :: x(2)=(/(9.e0,-3.e0), (3,0)/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 2+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,1)/)
      COMPLEX*8 :: x(4)=&
          &(/(3.e0,0.e0), (0.e0,0.e0), (9.e0,3.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/1/)
      COMPLEX*8 :: x(4)=&
          &(/6, 0, 3, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      COMPLEX*8 :: x(4)=&
          &(/(3.e0,-3.e0), (0.e0,0.e0), (3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/2/)
      COMPLEX*8 :: x(2)=(/1, 3/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 4 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/4/)
      COMPLEX*8 :: x(2)=(/5, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/3/)
      COMPLEX*8 :: x(2,1)=(reshape((/4, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/4, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 3+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/(4.e0,-2.e0), (0.e0,0.e0), (1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/1/)
      COMPLEX*8 :: x(2)=(/-1, -2/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/(-1.e0,-1.e0), (-1,0)/)! reference x 
      COMPLEX*8 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/(-1.e0,1.e0), (-1,0)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/(-1.e0,0.e0), (0.e0,0.e0), (-1.e0,-3.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 3+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,2)/)
      COMPLEX*8 :: x(4)=&
          &(/(-4.e0,-2.e0), (0.e0,0.e0), (-1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,2)/)
      COMPLEX*8 :: x(4)=&
          &(/(-3.e0,2.e0), (0.e0,0.e0), (-1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,5)/)
      COMPLEX*8 :: x(2)=(/(-3.e0,0.e0), (-3,-15)/)! reference x 
      COMPLEX*8 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*8 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 3+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,1)/)
      COMPLEX*8 :: x(2,1)=(reshape((/(-12.e0,-3.e0), (-3,0)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/(-6.e0,3.e0), (-3,0)/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,3)/)
      COMPLEX*8 :: x(4)=&
          &(/(-6.e0,9.e0), (0.e0,0.e0), (-3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sl_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 1+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,2)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(6.e0,0.e0), (9,6)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 6+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(6,3)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(24.e0,9.e0), (6,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,2)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(12.e0,-6.e0), (6,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 2+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,1)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,0.e0), (6,1)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 3+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,3)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(7.e0,3.e0), (4,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 1+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(5.e0,-2.e0), (4,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,4)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(2.e0,0.e0), (2,-4)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/1, 2/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(2.e0,3.e0), (2,0)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sl_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sl_di_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/(3.e0,0.e0), (3,9)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(2)=(/(3.e0,3.e0), (3,0)/)! reference x 
      COMPLEX*16 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,2)/)
      COMPLEX*16 :: x(2,1)=(reshape((/(3.e0,-6.e0), (3,0)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(2,2)/)
      COMPLEX*16 :: x(4)=&
          &(/(3.e0,0.e0), (0.e0,0.e0), (9.e0,6.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/(3.e0,3.e0), (0.e0,0.e0), (3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 2+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(2,3)/)
      COMPLEX*16 :: x(4)=&
          &(/(9.e0,-9.e0), (0.e0,0.e0), (3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,3)/)
      COMPLEX*16 :: x(2)=(/(1.e0,0.e0), (2,3)/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/4, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/(1.e0,0.e0), (0.e0,0.e0), (1.e0,1.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(2,2)/)
      COMPLEX*16 :: x(4)=&
          &(/(3.e0,-2.e0), (0.e0,0.e0), (1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/2/)
      COMPLEX*16 :: x(2,1)=(reshape((/-1, -3/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(2)=(/(-1.e0,-1.e0), (-1,0)/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2)=(/-1, -1/)! reference x 
      COMPLEX*16 :: cy(2)=(/1, 1/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 3+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(3,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/(-1.e0,0.e0), (0.e0,0.e0), (-4.e0,-1.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,3)/)
      COMPLEX*16 :: x(4)=&
          &(/(-2.e0,-3.e0), (0.e0,0.e0), (-1.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/-1, 0, -1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 6+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(6,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/(-3.e0,0.e0), (-21,-9)/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/0, 0/),(/2,1/)))! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zussm(blas_colmajor,transT,pone,alpha,A,y,nr,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 4+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(4,2)/)
      COMPLEX*16 :: x(2)=(/(-15.e0,-6.e0), (-3,0)/)! reference x 
      COMPLEX*16 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2)=(/-3, -3/)! reference x 
      COMPLEX*16 :: cy(2)=(/9, 9/)! reference cy after 
      COMPLEX*16 :: y(2)=(/0, 0/)! y 

      y=x
      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/-3, 0, -9, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,3)/)
      COMPLEX*16 :: x(4)=&
          &(/(-3.e0,-9.e0), (0.e0,0.e0), (-3.e0,0.e0), (0,0)/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 ussv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/-3, 0, -3, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/0, 0, 0, 0/)! y 

      y=x
      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_lower_triangular,istat)
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL ussv(transT,alpha,A,y,incx,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_ussv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sl_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,2)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(6.e0,0.e0), (6,6)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_usmm_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 1+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,5)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(9.e0,15.e0), (6,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_usmm_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_usmm_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 2+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(2,4)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(4.e0,0.e0), (6,4)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_usmm_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(4.e0,2.e0), (4,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_usmm_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,1)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(5.e0,-1.e0), (4,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_usmm_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 3+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(3,1)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(2.e0,0.e0), (-1,-1)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_usmm_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(2.e0,-1.e0), (2,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_usmm_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_usmm_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 3+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(3,3)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(0.e0,0.e0), (-9,-9)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_usmm_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(0.e0,-6.e0), (0,0)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_usmm_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sl_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      INTEGER(KIND=RSB_IDX_KIND) :: ldX=2
      INTEGER(KIND=RSB_IDX_KIND) :: ldY=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=l diag=i blocks=&
          &1x1 usmm alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/-3, 0/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmm(blas_colmajor,transT,1,alpha,A,x,ldX,y,ldY,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sl_di_usmm_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/12, 12/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/15, 15/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 4 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/4/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/8, 8/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/7, 7/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-1, 0, -1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/-1, -1/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/-9, -9/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/-9, -9/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-9, 0, -9, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/-6, -6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/-3, -3/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_ss_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 4 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/4/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-12, 0, -12, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_ss_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_ss_di_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/15, 0, 15, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/15, 15/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/12, 12/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/15, 0, 15, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 5 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/5/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/21, 0, 21, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/5, 5/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/7, 0, 7, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/5, 5/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/1, 1/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/1, 1/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 4 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/4/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/-12, -12/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/-6, -6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_ss_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 6 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/6/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-18, 0, -18, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_ss_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_ss_di_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(6.e0,6.e0), (6,6)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,1)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(9.e0,3.e0), (9,3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 2+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,5)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(12.e0,-15.e0), (12,-15)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,6.e0), (0.e0,0.e0), (6.e0,6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 0+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,5)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,15.e0), (0.e0,0.e0), (6.e0,15.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/3/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/15, 0, 15, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 2+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(12.e0,9.e0), (12,9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/6, 6/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 6+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(6,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(24.e0,-6.e0), (24,-6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,3.e0), (0.e0,0.e0), (6.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(9.e0,-9.e0), (0.e0,0.e0), (9.e0,-9.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,2.e0), (6,2)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/3/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/7, 7/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(4.e0,-3.e0), (4,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 2+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,4.e0), (0.e0,0.e0), (6.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(5.e0,1.e0), (0.e0,0.e0), (5.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(4.e0,-2.e0), (0.e0,0.e0), (4.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 3+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,4)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(7.e0,4.e0), (7,4)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,1)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(5.e0,1.e0), (5,1)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+9i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,9)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(4.e0,-9.e0), (4,-9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 2+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,1)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,1.e0), (0.e0,0.e0), (6.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 3+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(7.e0,2.e0), (0.e0,0.e0), (7.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(4.e0,-2.e0), (0.e0,0.e0), (4.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 2+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(0.e0,-1.e0), (0,-1)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,-1.e0), (0.e0,0.e0), (2.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 3+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-1.e0,-2.e0), (0.e0,0.e0), (-1.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,4)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,4.e0), (0.e0,0.e0), (2.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,-3.e0), (2,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,-3.e0), (2,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,3.e0), (2,3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,-3.e0), (0.e0,0.e0), (2.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(1.e0,-3.e0), (0.e0,0.e0), (1.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,-9.e0), (0,-9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,-3.e0), (0,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 3+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(-9.e0,9.e0), (-9,9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/2/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/-6, 0, -6, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-6.e0,-6.e0), (0.e0,0.e0), (-6.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,1)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-3.e0,3.e0), (0.e0,0.e0), (-3.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,-3.e0), (0,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,-9.e0), (0,-9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 5 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/5/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/-15, -15/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_ss_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/-6, 0, -6, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,-9.e0), (0.e0,0.e0), (0.e0,-9.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_ss_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 1+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-3.e0,6.e0), (0.e0,0.e0), (-3.e0,6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_ss_di_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 2+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(2,4)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(12.e0,12.e0), (12,12)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/12, 12/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,3)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(9.e0,-9.e0), (9,-9)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/1/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,1)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(9.e0,3.e0), (0.e0,0.e0), (9.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 1+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,2)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(9.e0,-6.e0), (0.e0,0.e0), (9.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 1+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,5)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(9.e0,15.e0), (9,15)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,5)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(6.e0,15.e0), (6,15)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(6.e0,-3.e0), (6,-3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,3.e0), (0.e0,0.e0), (6.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,3.e0), (0.e0,0.e0), (6.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 3+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(3,2)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(15.e0,-6.e0), (0.e0,0.e0), (15.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,3)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,3.e0), (4,3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/4, 4/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,2)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,-2.e0), (4,-2)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,1.e0), (0.e0,0.e0), (4.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/2/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 4+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(4,1)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(8.e0,-1.e0), (0.e0,0.e0), (8.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,3.e0), (4,3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,4.e0), (4,4)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,-1.e0), (4,-1)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,3.e0), (0.e0,0.e0), (4.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,2)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,2.e0), (0.e0,0.e0), (4.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 5+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(5,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(9.e0,-1.e0), (0.e0,0.e0), (9.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/2, 2/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 1+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,5)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(1.e0,-5.e0), (1,-5)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/2/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/0, 0/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,-2.e0), (0.e0,0.e0), (2.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,-3.e0), (0.e0,0.e0), (2.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 3+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(3,1)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-1.e0,1.e0), (0.e0,0.e0), (-1.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 2+6i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(2,6)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,-6.e0), (0,-6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(2,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,-2.e0), (0,-2)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/2, 2/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,2)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,-2.e0), (0.e0,0.e0), (2.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 2+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(2,4)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,-4.e0), (0.e0,0.e0), (0.e0,-4.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 3+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(3,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-1.e0,1.e0), (0.e0,0.e0), (-1.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 1+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,4)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-3.e0,-12.e0), (-3,-12)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 3+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(3,4)/)
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(-9.e0,-12.e0), (-9,-12)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(0.e0,6.e0), (0,6)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 6+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(6,3)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-18.e0,-9.e0), (0.e0,0.e0), (-18.e0,-9.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,-12.e0), (0.e0,0.e0), (0.e0,-12.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,12.e0), (0.e0,0.e0), (0.e0,12.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/0, 0/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-3.e0,-9.e0), (-3,-9)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-3.e0,9.e0), (-3,9)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_ss_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/3/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/-9, 0, -9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/-9, 0, -9, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_ss_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=s diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/1/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_symmetric,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_ss_di_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/15, 0, 15, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/15, 0, 15, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL suscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 4 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/4/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/8, 8/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/7, 0, 7, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 5 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/5/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 6 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/6/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/-4, -4/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/3/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-1, 0, -1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 5 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/5/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*4 :: cy(2,1)=(reshape((/-6, -6/),(/2,1/)))! reference cy after 
      REAL*4 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 4 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/4/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-12, 0, -12, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/1/)
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-3, 0, -3, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*4 :: x(2)=(/1, 1/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-6, 0, -6, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*4 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE ts_sh_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL suscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE ts_sh_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*4 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=s dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 5 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*4 :: VA(1)=(/5/)
      REAL*4 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*4 :: cy(4)=&
          &(/-15, 0, -15, 0/)! reference cy after 
      REAL*4 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_suscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_suscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_suscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL suscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_susmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE ts_sh_di_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/9, 9/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/12, 0, 12, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/6, 6/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/12, 12/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/6, 6/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/7, 7/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 5 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/5/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/9, 9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/4, 4/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 5 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/5/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/9, 0, 9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/7, 0, 7, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/4, 0, 4, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/2, 2/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/-1, -1/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/2, 2/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/1, 0, 1, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/-3, -3/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      REAL*8 :: cy(2,1)=(reshape((/0, 0/),(/2,1/)))! reference cy after 
      REAL*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      REAL*8 :: x(2)=(/1, 1/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-9, 0, -9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/0, 0/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(2)=(/-9, -9/)! reference cy after 
      REAL*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL duscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE td_sh_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-6, 0, -6, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      REAL*8 :: VA(1)=(/3/)
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/-9, 0, -9, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL duscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE td_sh_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      REAL*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=d dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      REAL*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      REAL*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      REAL*8 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      REAL*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_duscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_duscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_duscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL duscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_dusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE td_sh_di_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,-9.e0), (6,9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,1)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(9.e0,3.e0), (9,-3)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,-6.e0), (6,6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 2 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/12, 0, 12, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,6.e0), (0.e0,0.e0), (6.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 3+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,5)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(15.e0,-15.e0), (0.e0,0.e0), (15.e0,15.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 3+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(15.e0,-9.e0), (15,9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(6.e0,6.e0), (6,-6)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(9.e0,-3.e0), (9,3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,-3.e0), (0.e0,0.e0), (6.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 1+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,5)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(9.e0,15.e0), (0.e0,0.e0), (9.e0,-15.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*8 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/6, 0, 6, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,5)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,-5.e0), (4,5)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+6i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,6)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(4.e0,6.e0), (4,-6)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 2+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,4)/)
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(6.e0,-4.e0), (6,4)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(4.e0,-2.e0), (0.e0,0.e0), (4.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 2+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,1)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(6.e0,1.e0), (0.e0,0.e0), (6.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(5.e0,-1.e0), (0.e0,0.e0), (5.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 1+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(5.e0,-2.e0), (5,2)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(5.e0,3.e0), (5,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 3+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,1)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(7.e0,-1.e0), (7,1)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(4.e0,-2.e0), (0.e0,0.e0), (4.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 1+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(5.e0,2.e0), (0.e0,0.e0), (5.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(4.e0,-2.e0), (0.e0,0.e0), (4.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 1+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,4)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(1.e0,4.e0), (1,-4)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(2.e0,-4.e0), (2,4)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+7i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,7)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,7.e0), (2,-7)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,2)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(2.e0,2.e0), (0.e0,0.e0), (2.e0,-2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 3+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-1.e0,-2.e0), (0.e0,0.e0), (-1.e0,2.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 1+7i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,7)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(1.e0,7.e0), (0.e0,0.e0), (1.e0,-7.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 2+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,5)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,5.e0), (0,-5)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,2)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(2.e0,-2.e0), (2,2)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(1.e0,3.e0), (1,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 2+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,4)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,4.e0), (0.e0,0.e0), (0.e0,-4.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 6+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(6,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-4.e0,-3.e0), (0.e0,0.e0), (-4.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(1.e0,3.e0), (0.e0,0.e0), (1.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 1+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(1,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*8 :: cy(2,1)=(reshape((/(-3.e0,6.e0), (-3,-6)/),(/2,1/)))! reference cy after 
      COMPLEX*8 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 3+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(3,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(-9.e0,-9.e0), (-9,9)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,1)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,3.e0), (0,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 4+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(4,1)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-12.e0,3.e0), (0.e0,0.e0), (-12.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/3/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/-9, 0, -9, 0/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 2+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,1)/)
      COMPLEX*8 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-6.e0,3.e0), (0.e0,0.e0), (-6.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 5+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(5,1)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(-15.e0,3.e0), (-15,-3)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,4)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/(0.e0,-12.e0), (0,12)/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/1/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(2)=(/-3, -3/)! reference cy after 
      COMPLEX*8 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_cuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tc_sh_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,9.e0), (0.e0,0.e0), (0.e0,-9.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 2+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(2,3)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(-6.e0,-9.e0), (0.e0,0.e0), (-6.e0,9.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tc_sh_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*8 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=c dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*8 :: VA(1)=(/(0,4)/)
      COMPLEX*8 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*8 :: cy(4)=&
          &(/(0.e0,12.e0), (0.e0,0.e0), (0.e0,-12.e0), (0,0)/)! reference cy after 
      COMPLEX*8 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL cuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL cuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tc_sh_di_usmv_2_c_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 1+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,5)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(9.e0,-15.e0), (9,15)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 5 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/5/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/21, 21/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(9.e0,-9.e0), (9,9)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_ap3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 1+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,5)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(9.e0,-15.e0), (0.e0,0.e0), (9.e0,15.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 2+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(2,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(12.e0,3.e0), (0.e0,0.e0), (12.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 1+5i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,5)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(9.e0,-15.e0), (0.e0,0.e0), (9.e0,15.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_ap3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 3 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/3/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/15, 15/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(9.e0,9.e0), (9,-9)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/6, 6/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_ap3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,-3.e0), (0.e0,0.e0), (6.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 4+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(4,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(18.e0,9.e0), (0.e0,0.e0), (18.e0,-9.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(6.e0,-3.e0), (0.e0,0.e0), (6.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_ap3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/4, 4/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/4, 4/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 2+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(2,3)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(6.e0,-3.e0), (6,3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_ap1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/1/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 1+6i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,6)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(5.e0,6.e0), (0.e0,0.e0), (5.e0,-6.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,3)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,-3.e0), (0.e0,0.e0), (4.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_ap1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,-4.e0), (4,4)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,1.e0), (4,-1)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+8i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,8)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(4.e0,-8.e0), (4,8)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_ap1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,-4.e0), (0.e0,0.e0), (4.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(4.e0,1.e0), (0.e0,0.e0), (4.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entry(A,VA(1),IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha= 1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0 0
! 1 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/1/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/5, 0, 5, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_ap1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/2, 2/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 2+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(2,1)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(0.e0,-1.e0), (0,1)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(2.e0,4.e0), (2,-4)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_anr1_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 0+8i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,8)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,8.e0), (0.e0,0.e0), (2.e0,-8.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(1.e0,-1.e0), (0.e0,0.e0), (1.e0,1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 0+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,1)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(2.e0,1.e0), (0.e0,0.e0), (2.e0,-1.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_anr1_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/2, 2/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 0+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,3)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(2.e0,-3.e0), (2,3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 5+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(5,4)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-3.e0,4.e0), (-3,-4)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_anr1_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/2, 0, 2, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 1+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(1.e0,-4.e0), (0.e0,0.e0), (1.e0,4.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-1
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-1 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 3+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(3,3)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-1.e0,3.e0), (0.e0,0.e0), (-1.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_anr1_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 5+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(5,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2,1)=(reshape((/1, 1/),(/2,1/)))! reference x 
      COMPLEX*16 :: cy(2,1)=(reshape((/(-15.e0,6.e0), (-15,-6)/),(/2,1/)))! reference cy after 
      COMPLEX*16 :: y(2,1)=(reshape((/3, 3/),(/2,1/)))! y will be overwritten

      errval=0
      CALL zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zusmm(blas_colmajor,transT,pone,alpha,A,x,nr,y,nc,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i,1).NE.cy(i,1))PRINT*,LCS," is not ok"
        IF(y(i,1).NE.cy(i,1))errval=-1
        IF(y(i,1).NE.cy(i,1))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 3+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(3,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-9.e0,-3.e0), (-9,3)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=1 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(2)=(/0, 0/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_anr3_bp1_ix1_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 1+3i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,3)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-3.e0,9.e0), (0.e0,0.e0), (-3.e0,-9.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,4)/)
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,-12.e0), (0.e0,0.e0), (0.e0,12.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_clique(A,pone,pone,VA(1:),pone,pone,IA(1:),JA(1:),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=1
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=1 incy=2 trans=c"
! A =
! 0 0
! 0 0

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=0
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/-999999/) ! fortran does not support empty arrays
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: VA(1)=(/-999999/) ! fortran does not support empty arrays
      COMPLEX*16 :: x(2)=(/1, 1/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/0, 0, 0, 0/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_anr3_bp1_ix1_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=n"
! A =
! 0+0i 0+0i
! 2+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(2,2)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-6.e0,6.e0), (-6,-6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_begin(nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=t"
! A =
! 0+0i 0+0i
! 1+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,2)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-3.e0,-6.e0), (-3,6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=1
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=1 trans=c"
! A =
! 0+0i 0+0i
! 1+2i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,2)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(2)=(/(-3.e0,6.e0), (-3,-6)/)! reference cy after 
      COMPLEX*16 :: y(2)=(/3, 3/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_anr3_bp1_ix2_iy1 
! 
      SUBROUTINE tz_sh_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_no_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=n"
! A =
! 0+0i 0+0i
! 1+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(1,1)/)
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-3.e0,3.e0), (0.e0,0.e0), (-3.e0,-3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL zuscr_block_begin(pone,pone,nr,nc,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL uscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL usmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_n_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_trans
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=t"
! A =
! 0+0i 0+0i
! 4+1i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(4,1)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(-12.e0,-3.e0), (0.e0,0.e0), (-12.e0,3.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_col(A,mone,nnz,VA,IA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL zuscr_insert_block(A,VA(1:),pone,pone,IA(1),JA(1),istat)
      IF(istat.NE.0)GOTO 9997
      CALL uscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_t_anr3_bp1_ix2_iy2 
! 
      SUBROUTINE tz_sh_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      USE blas_sparse
      USE rsb ! for RSB_IDX_KIND
      IMPLICIT NONE
      INTEGER::errval,istat=0,i
      INTEGER(KIND=RSB_IDX_KIND)::mone=-1,pone=+1
      INTEGER::A
      INTEGER::transT=blas_conj_trans 
      INTEGER(KIND=RSB_IDX_KIND) :: incx=2
      INTEGER(KIND=RSB_IDX_KIND) :: incy=2
      COMPLEX*16 :: alpha=-3
      CHARACTER(LEN=*),PARAMETER :: LCS = "&
       &type=z dims=2x2 sym=h diag=i blocks=&
          &1x1 usmv alpha=-3 beta= 1 incx=2 incy=2 trans=c"
! A =
! 0+0i 0+0i
! 0+4i 0+0i

      ! declaration of VA,IA,JA 
      INTEGER(KIND=RSB_IDX_KIND) :: nnz=1
      INTEGER(KIND=RSB_IDX_KIND) :: nr=2
      INTEGER(KIND=RSB_IDX_KIND) :: nc=2
      INTEGER(KIND=RSB_IDX_KIND) :: IA(1)=(/2/)
      INTEGER(KIND=RSB_IDX_KIND) :: JA(1)=(/1/)
      COMPLEX*16 :: VA(1)=(/(0,4)/)
      INTEGER(KIND=RSB_IDX_KIND) :: K(2)=(/1, 1/)! K
      INTEGER(KIND=RSB_IDX_KIND) :: L(2)=(/1, 1/)! L
      COMPLEX*16 :: x(4)=&
          &(/1, 0, 1, 0/)! reference x 
      COMPLEX*16 :: cy(4)=&
          &(/(0.e0,12.e0), (0.e0,0.e0), (0.e0,-12.e0), (0,0)/)! reference cy after 
      COMPLEX*16 :: y(4)=&
          &(/3, 0, 3, 0/)! y will be overwritten

      errval=0
      CALL BLAS_zuscr_variable_block_begin(nr,nc,K,L,A,errval)
      IF(errval.NE.0)GOTO 9999
      CALL ussp(A,blas_unit_diag,istat)
      CALL ussp(A,blas_lower_hermitian,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_insert_row(A,mone,nnz,VA,JA,istat)
      IF(istat.EQ.0)THEN
        istat=-1;GOTO 9997;
      ELSE
        istat=0;
      ENDIF
      CALL BLAS_zuscr_insert_entries(A,nnz,VA,IA,JA,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zuscr_end(A,istat)
      IF(istat.NE.0)GOTO 9997
      CALL BLAS_zusmv(transT,alpha,A,x,incx,y,incy,istat)
      IF(istat.NE.0)GOTO 9997
      DO i=1,2
        IF(y(i).NE.cy(i))PRINT*,LCS," is not ok"
        IF(y(i).NE.cy(i))errval=-1
        IF(y(i).NE.cy(i))GOTO 9997
      ENDDO
      PRINT*,LCS," is ok"
9997      IF(istat.NE.0)errval=-1
      CALL usds(A,istat)
      IF(istat.NE.0)errval=-1
9999      CONTINUE
      end SUBROUTINE tz_sh_di_usmv_2_c_anr3_bp1_ix2_iy2 
!
      PROGRAM main

      USE rsb
      INTEGER :: passed=0,failed=0,errval=0
      info = rsb_lib_init(RSB_NULL_INIT_OPTIONS)
      IF(info.NE.0)THEN
      STOP 1
      ENDIF
      CALL       ts_sg_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_de_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_de_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sg_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sg_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sg_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sg_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_su_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_su_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_su_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_su_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sl_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sl_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sl_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_ussv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_usmm_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_usmm_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_usmm_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_usmm_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_usmm_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_usmm_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_usmm_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_usmm_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_usmm_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_usmm_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_usmm_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sl_di_usmm_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_ss_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_ss_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_ss_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_ss_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       ts_sh_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       td_sh_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tc_sh_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_ap3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_ap3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_ap3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_ap3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_ap1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_ap1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_ap1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_ap1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_anr1_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_anr1_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_anr1_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_anr1_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_anr3_bp1_ix1_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_anr3_bp1_ix1_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_anr3_bp1_ix2_iy1(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_n_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_t_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      CALL       tz_sh_di_usmv_2_c_anr3_bp1_ix2_iy2(errval)
      IF(errval.LT.0)failed=failed+1
      IF(errval.EQ.0)passed=passed+1
      
      PRINT *,"PASSED:",passed
      PRINT *,"FAILED:",failed
      info = rsb_lib_exit(RSB_NULL_EXIT_OPTIONS)
      IF(failed.NE.0.OR.info.NE.0)THEN
      STOP 1
      ENDIF
      END PROGRAM main



!> @endcond
