
cmake_minimum_required(VERSION 3.15)

# -----------------------------------------------------------------------------
# CMake configuration to walk a set of project directories, discover source
# files and run arbitrary commands on them.
#
# This example uses CMake's custom command and custom target mechanism to
# generate an output file for each source file discovered under the given
# projects.  Each custom command writes a small message into the output file
# using `cmake -E echo` as a placeholder command.  Replace the `COMMAND`
# argument in the `add_custom_command` invocation with the actual tool you
# want to run on each source file (for example a code analyser or script).
#
# A custom target named `run_processing` is declared at the bottom of this
# file.  When you build this target (it is also part of the default ALL
# target) CMake will generate the output files for all discovered sources.
#
# The structure of this file follows the guidance in the CMake "Custom
# Commands" chapter: we generate multiple custom commands in a `foreach`
# loop and collect their outputs into a list.  Afterwards we define a single
# custom target that depends on all of those outputs, which causes them to be
# produced when the target is builthttps://cmake.org/cmake/help/book/mastering-cmake/chapter/Custom%20Commands.html#:~:text=,DOCS%20doc1%20doc2%20doc3.  CMake's
# documentation recommends specifying the full paths of both the inputs and
# outputs of custom commands to avoid confusion between the source and binary
# treeshttps://cmake.org/cmake/help/book/mastering-cmake/chapter/Custom%20Commands.html#:~:text=When%20using%20custom%20commands%20and,full%20paths%20are%20not%20specified.

project(run_project_processing LANGUAGES NONE)

# -----------------------------------------------------------------------------
# Configuration options
#
# Define PROJECT_DIRS as a semicolon‑separated list of directories containing
# your projects.  Each project directory will be searched recursively for
# source files.  You can pass this variable on the CMake command line, e.g.:
#
#   cmake -DPROJECT_DIRS="projA;projB" -S . -B build
#
# If PROJECT_DIRS is not set, we fall back to all immediate subdirectories of
# the current source directory.

if(NOT DEFINED PROJECT_DIRS OR PROJECT_DIRS STREQUAL "")
  message(STATUS "PROJECT_DIRS not provided; defaulting to all subdirectories of ${CMAKE_SOURCE_DIR}")
  # Gather top‑level subdirectories (excluding files).  LIST_DIRECTORIES must
  # be true for GLOB to return directories.
  file(GLOB PROJECT_DIRS LIST_DIRECTORIES true "${CMAKE_SOURCE_DIR}/projects")
  # Filter out non‑directory entries.
  # set(_filtered_dirs)
  # foreach(_cand IN LISTS PROJECT_DIRS)
  #   if(IS_DIRECTORY "${_cand}")
  #     # Skip version control directories like .git
  #     get_filename_component(_base_name "${_cand}" NAME)
  #     if(NOT _base_name STREQUAL ".git")
  #       list(APPEND _filtered_dirs "${_cand}")
  #     endif()
  #   endif()
  # endforeach()
  # set(PROJECT_DIRS ${_filtered_dirs})
endif()

# Root directory for all generated results.  This resides in the build tree.
set(RESULTS_ROOT "${CMAKE_BINARY_DIR}/results")
file(MAKE_DIRECTORY "${RESULTS_ROOT}")

# List to accumulate all output files generated by custom commands.
set(RESULT_FILES)

foreach(_project_dir IN LISTS PROJECT_DIRS)
  # Skip non‑directory entries (shouldn't happen due to filtering above).
  if(NOT IS_DIRECTORY "${_project_dir}")
    continue()
  endif()

  # Discover source files recursively.  Adjust the glob patterns to match the
  # file types that interest you.  The CONFIGURE_DEPENDS option tells CMake
  # to automatically re‑run when new files matching these patterns are added
  # or removed, which keeps the build graph up‑to‑date.
  file(GLOB_RECURSE _src_files
       RELATIVE "${_project_dir}"
       CONFIGURE_DEPENDS
       "${_project_dir}/*.f" "${_project_dir}/*.F"
       "${_project_dir}/*.for"  "${_project_dir}/*.FOR"
       "${_project_dir}/*.ftn" "${_project_dir}/*.f77" "${_project_dir}/*.F77"
       "${_project_dir}/*.FTN" "${_project_dir}/*.ftn77" "${_project_dir}/*.FTN77"
       "${_project_dir}/*.f90" "${_project_dir}/*.F90"
       "${_project_dir}/*.ftn90" "${_project_dir}/*.FTN90"
       "${_project_dir}/*.f95" "${_project_dir}/*.F95"
       "${_project_dir}/*.ftn95" "${_project_dir}/*.FTN95"
       "${_project_dir}/*.f03" "${_project_dir}/*.F03"
       "${_project_dir}/*.ftn03" "${_project_dir}/*.FTN03"
       "${_project_dir}/*.f08" "${_project_dir}/*.F08"
       "${_project_dir}/*.ftn08" "${_project_dir}/*.FTN08"
       "${_project_dir}/*.f18" "${_project_dir}/*.F18"
       "${_project_dir}/*.ftn18" "${_project_dir}/*.FTN18"
       "${_project_dir}/*.f23" "${_project_dir}/*.F23"
       "${_project_dir}/*.ftn23" "${_project_dir}/*.FTN23")

  foreach(_rel_src IN LISTS _src_files)
    # Construct the absolute path to the input file.
    set(_src "${_project_dir}/${_rel_src}")

    # Compute the directory of the source relative to the project root.
    get_filename_component(_src_dir "${_src}" DIRECTORY)
    file(RELATIVE_PATH _rel_dir "${_project_dir}" "${_src_dir}")

    # Build an output directory mirroring the source hierarchy inside the
    # RESULTS_ROOT.  Include the top‑level project directory name so that
    # results for a project such as 'projA/examples/foo' end up under
    # 'results/projA/examples/foo' rather than just 'results/examples/foo'.
    get_filename_component(_project_base "${_project_dir}" NAME)
    set(_out_dir "${RESULTS_ROOT}/${_project_base}/${_rel_dir}")
    file(MAKE_DIRECTORY "${_out_dir}")

    # Define the output file name.  Here we simply append a ".result" suffix
    # to the original filename.  You can change this to any naming scheme.
    get_filename_component(_base_name "${_rel_src}" NAME)
    get_filename_component(_project_base "${_project_dir}" NAME)
    set(_out_dir "${RESULTS_ROOT}/${_project_base}/${_rel_dir}")
    set(_out_file "${_out_dir}/${_base_name}.result")

    # Guard against generating the same output more than once.  A given
    # directory may contain files with the same base name and extension,
    # or patterns may overlap, so we check if this output has already been
    # registered.  If it has, skip adding another custom command for it.
    list(FIND RESULT_FILES "${_out_file}" _existing_index)
    if(_existing_index EQUAL -1)
      # Define a custom command that generates the output file from the input.
      # Replace `cmake -E echo` with the real command you want to execute.  You
      # can add multiple COMMAND lines if your tool chain requires several
      # steps.  Always specify the full paths for inputs and outputshttps://cmake.org/cmake/help/book/mastering-cmake/chapter/Custom%20Commands.html#:~:text=When%20using%20custom%20commands%20and,full%20paths%20are%20not%20specified.
      add_custom_command(
        OUTPUT "${_out_file}"
        COMMAND ${CMAKE_COMMAND} -E echo "Processing ${_src}" > "${_out_file}"
        DEPENDS "${_src}"
        COMMENT "Processing ${_src}"
        VERBATIM
      )
      # Append to the global list of generated results.
      list(APPEND RESULT_FILES "${_out_file}")
    endif()
  endforeach()
endforeach()

# Create a single custom target that depends on all generated files.  When
# `make` (or the build tool) runs, this target will ensure that all custom
# commands above are invoked and that all output files are created.  Marking
# it with ALL means it is part of the default build target https://cmake.org/cmake/help/book/mastering-cmake/chapter/Custom%20Commands.html#:~:text=,DOCS%20doc1%20doc2%20doc3.
add_custom_target(run_processing ALL DEPENDS ${RESULT_FILES})

# Optionally print a summary of discovered projects and files.
message(STATUS "Projects found: ${PROJECT_DIRS}")
# Additional counters could be added here by incrementing a variable when
# iterating over the files; omitted for brevity.
