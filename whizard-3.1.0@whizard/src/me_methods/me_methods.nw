% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*-
% WHIZARD code as NOWEB source: matrix elements and process libraries
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Interface for Matrix Element Objects}
\includemodulegraph{me_methods}

These modules manage internal and, in particular, external
matrix-element code.
\begin{description}
\item[prc\_core]
  We define the abstract [[prc_core_t]] type which handles all specific
  features of kinematics matrix-element evaluation that depend on a particular
  class of processes.  This abstract type supplements the
  [[prc_core_def_t]] type and related types in another module.
  Together, they provide a complete set of matrix-element handlers
  that are implemented in the concrete types below.
\end{description}

These are the implementations:
\begin{description}
\item[prc\_template\_me]
  Implements matrix-element code without actual content (trivial
  value), but full-fledged interface.  This can be used for injecting
  user-defined matrix-element code.
\item[prc\_omega]
  Matrix elements calculated by \oMega\ are the default for WHIZARD.
  Here, we provide all necessary support.
\item[prc\_external]
  Matrix elements provided or using external (not \oMega) code or libraries.
  This is an abstract type, with concrete extensions below:
\item[prc\_external\_test]
  Concrete implementation of the external-code type, actually using some
  pre-defined test matrix elements.
\item[prc\_gosam]
  Interface for matrix elements computed using \gosam.
\item[prc\_openloops]
  Interface for matrix elements computed using OpenLoops.
\item[prc\_recola]
  Interface for matrix elements computed using Recola.
\item[prc\_threshold]
  Interface for matrix elements for the top-pair threshold, that use external
  libraries.
\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract process core}
In this module we provide abstract data types for process classes.  Each
process class represents a set of processes which are handled by a common
``method'', e.g., by the \oMega\ matrix-element generator.  The process class
is also able to select a particular implementation for the phase-space and
integration modules.

For a complete implementation of a process class, we have to
provide extensions of the following abstract types:
\begin{description}
\item[prc\_core\_def\_t] process and matrix-element configuration
\item[prc\_writer\_t] (optional) writing external matrix-element code
\item[prc\_driver\_t] accessing the matrix element (internal or external)
\item[prc\_core\_t] evaluating kinematics and matrix element.  The process
  core also selects phase-space and integrator implementations as appropriate
  for the process class and configuration.
\end{description}

In the actual process-handling data structures, each process component
contains an instance of such a process class as its core.  This allows us to
keep the [[processes]] module below, which supervises matrix-element
evaluation, integration, and event generation, free of any reference to
concrete implementations (for the process class, phase space, and
integrator).

There are no unit tests, these are deferred to the [[processes]] module.
<<[[prc_core.f90]]>>=
<<File header>>
module prc_core

<<Use kinds>>
<<Use strings>>
  use io_units
  use diagnostics
  use os_interface, only: os_data_t
  use lorentz
  use interactions
  use variables, only: var_list_t
  use model_data, only: model_data_t

  use process_constants
  use prc_core_def
  use process_libraries
  use sf_base

<<Standard module head>>

<<Prc core: public>>

<<Prc core: types>>

<<Prc core: interfaces>>

  interface
<<Prc core: sub interfaces>>
  end interface

end module prc_core
@ %def prc_core
@
<<[[prc_core_sub.f90]]>>=
<<File header>>

submodule (prc_core) prc_core_s

  implicit none

contains

<<Prc core: procedures>>

end submodule prc_core_s

@ %def prc_core_s
@
\subsection{The process core}
The process core is of abstract data type.  Different types of matrix
elements will be represented by different implementations.
<<Prc core: public>>=
  public :: prc_core_t
<<Prc core: types>>=
  type, abstract :: prc_core_t
     class(prc_core_def_t), pointer :: def => null ()
     logical :: data_known = .false.
     type(process_constants_t) :: data
     class(prc_core_driver_t), allocatable :: driver
     logical :: use_color_factors = .false.
     integer :: nc = 3
   contains
   <<Prc core: process core: TBP>>
  end type prc_core_t

@ %def prc_core_t
@ In any case there must be an output routine.
<<Prc core: process core: TBP>>=
  procedure(prc_core_write), deferred :: write
<<Prc core: interfaces>>=
  abstract interface
     subroutine prc_core_write (object, unit)
       import
       class(prc_core_t), intent(in) :: object
       integer, intent(in), optional :: unit
     end subroutine prc_core_write
  end interface

@ %def prc_core_write
@ Just type the name of the actual core method.
<<Prc core: process core: TBP>>=
  procedure(prc_core_write_name), deferred :: write_name
<<Prc core: interfaces>>=
  abstract interface
     subroutine prc_core_write_name (object, unit)
       import
       class(prc_core_t), intent(in) :: object
       integer, intent(in), optional :: unit
     end subroutine prc_core_write_name
  end interface

@ %def prc_core_write_name
@ For initialization, we assign a pointer to the process entry in the
relevant library.  This allows us to access all process functions via
the implementation of [[prc_core_t]].

We declare the [[object]] as [[intent(inout)]], since just after
allocation it may be useful to store some extra data in the object,
which we can then use in the actual initialization.  This applies to
extensions of [[prc_core]] which override the [[init]] method.
<<Prc core: process core: TBP>>=
  procedure :: init => prc_core_init
  procedure :: base_init => prc_core_init
<<Prc core: sub interfaces>>=
    module subroutine prc_core_init (object, def, lib, id, i_component)
      class(prc_core_t), intent(inout) :: object
      class(prc_core_def_t), intent(in), target :: def
      type(process_library_t), intent(in), target :: lib
      type(string_t), intent(in) :: id
      integer, intent(in) :: i_component
    end subroutine prc_core_init
<<Prc core: procedures>>=
  module subroutine prc_core_init (object, def, lib, id, i_component)
    class(prc_core_t), intent(inout) :: object
    class(prc_core_def_t), intent(in), target :: def
    type(process_library_t), intent(in), target :: lib
    type(string_t), intent(in) :: id
    integer, intent(in) :: i_component
    object%def => def
    call lib%connect_process (id, i_component, object%data, object%driver)
    object%data_known = .true.
  end subroutine prc_core_init

@ %def prc_core_init
@ Return true if the matrix element generation was successful.  This can be
tested by looking at the number of generated flavor states, which should be
nonzero.
<<Prc core: process core: TBP>>=
  procedure :: has_matrix_element => prc_core_has_matrix_element
<<Prc core: sub interfaces>>=
    module function prc_core_has_matrix_element (object) result (flag)
      class(prc_core_t), intent(in) :: object
      logical :: flag
    end function prc_core_has_matrix_element
<<Prc core: procedures>>=
  module function prc_core_has_matrix_element (object) result (flag)
    class(prc_core_t), intent(in) :: object
    logical :: flag
    flag = object%data%n_flv /= 0
  end function prc_core_has_matrix_element

@ %def prc_core_has_matrix_element
@
Return true if this process-core type needs extra code that has to be compiled
and/or linked, beyond the default \oMega\ framework.  This depends only on the
concrete type, and the default is no.
<<Prc core: process core: TBP>>=
  procedure, nopass :: needs_external_code => prc_core_needs_external_code
<<Prc core: sub interfaces>>=
    module function prc_core_needs_external_code () result (flag)
      logical :: flag
    end function prc_core_needs_external_code 
<<Prc core: procedures>>=
  module function prc_core_needs_external_code () result (flag)
    logical :: flag
    flag = .false.
  end function prc_core_needs_external_code

@ %def prc_core_needs_external_code
@ The corresponding procedure to create and load extra libraries.  The base
procedure must not be called but has to be overridden, if extra code is
required.
<<Prc core: process core: TBP>>=
  procedure :: prepare_external_code => &
       prc_core_prepare_external_code
<<Prc core: sub interfaces>>=
    module subroutine prc_core_prepare_external_code &
         (core, flv_states, var_list, os_data, libname, model, i_core, is_nlo)
      class(prc_core_t), intent(inout) :: core
      integer, intent(in), dimension(:,:), allocatable :: flv_states
      type(var_list_t), intent(in) :: var_list
      type(os_data_t), intent(in) :: os_data
      type(string_t), intent(in) :: libname
      type(model_data_t), intent(in), target :: model
      integer, intent(in) :: i_core
      logical, intent(in) :: is_nlo
    end subroutine prc_core_prepare_external_code
<<Prc core: procedures>>=
  module subroutine prc_core_prepare_external_code &
       (core, flv_states, var_list, os_data, libname, model, i_core, is_nlo)
    class(prc_core_t), intent(inout) :: core
    integer, intent(in), dimension(:,:), allocatable :: flv_states
    type(var_list_t), intent(in) :: var_list
    type(os_data_t), intent(in) :: os_data
    type(string_t), intent(in) :: libname
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: i_core
    logical, intent(in) :: is_nlo
    call core%write ()
    call msg_bug ("prc_core_prepare_external_code called &
         &but not overridden")
  end subroutine prc_core_prepare_external_code

@ %def prc_core_prepare_external_code
@
Return true if this process-core type uses the BLHA interface.  This depends
only on the concrete type, and the default is no.
<<Prc core: process core: TBP>>=
  procedure, nopass :: uses_blha => prc_core_uses_blha
<<Prc core: sub interfaces>>=
    module function prc_core_uses_blha () result (flag)
      logical :: flag
    end function prc_core_uses_blha
<<Prc core: procedures>>=
  module function prc_core_uses_blha () result (flag)
    logical :: flag
    flag = .false.
  end function prc_core_uses_blha

@ %def prc_core_uses_blha
@
Tell whether a particular combination of flavor/helicity/color state
is allowed for the matrix element.
<<Prc core: process core: TBP>>=
  procedure(prc_core_is_allowed), deferred :: is_allowed
<<Prc core: interfaces>>=
  abstract interface
     function prc_core_is_allowed (object, i_term, f, h, c) result (flag)
       import
       class(prc_core_t), intent(in) :: object
       integer, intent(in) :: i_term, f, h, c
       logical :: flag
     end function prc_core_is_allowed
  end interface

@ %def prc_core_is_allowed
@ Set the constant process data for a specific term.  By default,
these are the constants stored inside the object, ignoring the term
index.  Type extensions may override this and provide term-specific data.
<<Prc core: process core: TBP>>=
  procedure :: get_constants => prc_core_get_constants
<<Prc core: sub interfaces>>=
    module subroutine prc_core_get_constants (object, data, i_term)
      class(prc_core_t), intent(in) :: object
      type(process_constants_t), intent(out) :: data
      integer, intent(in) :: i_term
    end subroutine prc_core_get_constants
<<Prc core: procedures>>=
  module subroutine prc_core_get_constants (object, data, i_term)
    class(prc_core_t), intent(in) :: object
    type(process_constants_t), intent(out) :: data
    integer, intent(in) :: i_term
    data = object%data
  end subroutine prc_core_get_constants

@ %def prc_core_get_constants
@ The strong coupling is not among the process constants.  The default
implementation is to return a negative number, which indicates that $\alpha_s$
is not available.  This may be overridden by an implementation that provides
an (event-specific) value.  The value can be stored in the
process-specific workspace.
<<Prc core: process core: TBP>>=
  procedure :: get_alpha_s => prc_core_get_alpha_s
<<Prc core: sub interfaces>>=
    module function prc_core_get_alpha_s (object, core_state) result (alpha_qcd)
      class(prc_core_t), intent(in) :: object
      class(prc_core_state_t), intent(in), allocatable :: core_state
      real(default) :: alpha_qcd
    end function prc_core_get_alpha_s
<<Prc core: procedures>>=
  module function prc_core_get_alpha_s (object, core_state) result (alpha_qcd)
    class(prc_core_t), intent(in) :: object
    class(prc_core_state_t), intent(in), allocatable :: core_state
    real(default) :: alpha_qcd
    alpha_qcd = -1
  end function prc_core_get_alpha_s

@ %def prc_core_get_alpha_s
@ We follow the same strategy for the electromagnetic coupling
$\alpha_\text{em}$.
<<Prc core: process core: TBP>>=
  procedure :: get_alpha_qed => prc_core_get_alpha_qed
<<Prc core: sub interfaces>>=
    module function prc_core_get_alpha_qed &
         (object, core_state) result (alpha_qed)
      class(prc_core_t), intent(in) :: object
      class(prc_core_state_t), intent(in), allocatable :: core_state
      real(default) :: alpha_qed
    end function prc_core_get_alpha_qed
<<Prc core: procedures>>=
  module function prc_core_get_alpha_qed &
       (object, core_state) result (alpha_qed)
    class(prc_core_t), intent(in) :: object
    class(prc_core_state_t), intent(in), allocatable :: core_state
    real(default) :: alpha_qed
    alpha_qed = -1
  end function prc_core_get_alpha_qed

@ %def prc_core_get_alpha_qed
@
Setup an index mapping for flavor structures and helicities that give
the same matrix element. The index mapping is according to the order
of flavor structures known to the [[prc_core]] class. This procedure
here acts as a fallback in case there is no overridden procedure in
the [[prc_core]] extension. 
<<Prc core: process core: TBP>>=
  procedure :: set_equivalent_flv_hel_indices => &
       prc_core_set_equivalent_flv_hel_indices
<<Prc core: sub interfaces>>=
    module subroutine prc_core_set_equivalent_flv_hel_indices (object)
      class(prc_core_t), intent(inout) :: object
    end subroutine prc_core_set_equivalent_flv_hel_indices
<<Prc core: procedures>>=
  module subroutine prc_core_set_equivalent_flv_hel_indices (object)
    class(prc_core_t), intent(inout) :: object
    integer :: i, n_flv, n_hel
    n_flv = object%data%n_flv
    n_hel = object%data%n_hel
    if (.not. allocated (object%data%eqv_flv_index)) &
         allocate (object%data%eqv_flv_index(n_flv))
    if (.not. allocated (object%data%eqv_hel_index)) &
         allocate (object%data%eqv_hel_index(n_hel))
    if (size (object%data%eqv_flv_index) /= n_flv) &
         call msg_bug ("BLHA Core: Size mismatch between eqv_flv_index and number of flavors.")
    if (size (object%data%eqv_hel_index) /= n_hel) &
         call msg_bug ("BLHA Core: Size mismatch between eqv_hel_index and number of helicities.")
    object%data%eqv_flv_index = [(i, i = 1, n_flv)]
    object%data%eqv_hel_index = [(i, i = 1, n_hel)]
  end subroutine prc_core_set_equivalent_flv_hel_indices

@ %def prc_core_set_equivalent_flv_hel_indices
@ Get the index mappings for flavor and helicity mappings set up in
[[prc_core_get_equivalent_flv_index]] or any overriding variation.
<<Prc core: process core: TBP>>=
  procedure :: get_equivalent_flv_index => prc_core_get_equivalent_flv_index
  procedure :: get_equivalent_hel_index => prc_core_get_equivalent_hel_index
<<Prc core: sub interfaces>>=
    module function prc_core_get_equivalent_flv_index &
         (object) result (eqv_flv_index)
      class(prc_core_t), intent(in) :: object
      integer, dimension(:), allocatable :: eqv_flv_index
    end function prc_core_get_equivalent_flv_index
    module function prc_core_get_equivalent_hel_index &
         (object) result (eqv_hel_index)
      class(prc_core_t), intent(in) :: object
      integer, dimension(:), allocatable :: eqv_hel_index
    end function prc_core_get_equivalent_hel_index
<<Prc core: procedures>>=
  module function prc_core_get_equivalent_flv_index &
       (object) result (eqv_flv_index)
    class(prc_core_t), intent(in) :: object
    integer, dimension(:), allocatable :: eqv_flv_index
    eqv_flv_index = object%data%eqv_flv_index
  end function prc_core_get_equivalent_flv_index

  module function prc_core_get_equivalent_hel_index &
       (object) result (eqv_hel_index)
    class(prc_core_t), intent(in) :: object
    integer, dimension(:), allocatable :: eqv_hel_index
    eqv_hel_index = object%data%eqv_hel_index
  end function prc_core_get_equivalent_hel_index

@ %def prc_core_get_equivalent_flv_index prc_core_get_equivalent_hel_index
@ Allocate the workspace associated to a process component.  The default is
that there is no workspace, so we do nothing.  A type extension may override
this and allocate a workspace object of appropriate type, which can be used in
further calculations.

In any case, the [[intent(out)]] attribute deletes any previously allocated
workspace.
<<Prc core: process core: TBP>>=
  procedure :: allocate_workspace => prc_core_ignore_workspace
<<Prc core: sub interfaces>>=
    module subroutine prc_core_ignore_workspace (object, core_state)
      class(prc_core_t), intent(in) :: object
      class(prc_core_state_t), intent(inout), allocatable :: core_state
    end subroutine prc_core_ignore_workspace
<<Prc core: procedures>>=
  module subroutine prc_core_ignore_workspace (object, core_state)
    class(prc_core_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
  end subroutine prc_core_ignore_workspace

@ %def prc_core_ignore_workspace
@ Compute the momenta in the hard interaction, taking the seed
kinematics as input.  The [[i_term]] index tells us which term we want
to compute.  (The standard method is to just transfer the momenta to the hard
interaction.)
<<Prc core: process core: TBP>>=
  procedure(prc_core_compute_hard_kinematics), deferred :: &
       compute_hard_kinematics
<<Prc core: interfaces>>=
  abstract interface
     subroutine prc_core_compute_hard_kinematics &
          (object, p_seed, i_term, int_hard, core_state)
       import
       class(prc_core_t), intent(in) :: object
       type(vector4_t), dimension(:), intent(in) :: p_seed
       integer, intent(in) :: i_term
       type(interaction_t), intent(inout) :: int_hard
       class(prc_core_state_t), intent(inout), allocatable :: core_state
     end subroutine prc_core_compute_hard_kinematics
  end interface

@ %def prc_core_compute_hard_kinematics
@ Compute the momenta in the effective interaction, taking the hard
kinematics as input.  (This is called only if parton recombination is to be
applied for the process variant.)
<<Prc core: process core: TBP>>=
  procedure(prc_core_compute_eff_kinematics), deferred :: &
       compute_eff_kinematics
<<Prc core: interfaces>>=
  abstract interface
     subroutine prc_core_compute_eff_kinematics &
          (object, i_term, int_hard, int_eff, core_state)
       import
       class(prc_core_t), intent(in) :: object
       integer, intent(in) :: i_term
       type(interaction_t), intent(in) :: int_hard
       type(interaction_t), intent(inout) :: int_eff
       class(prc_core_state_t), intent(inout), allocatable :: core_state
     end subroutine prc_core_compute_eff_kinematics
  end interface

@ %def prc_core_compute_eff_kinematics
@ The process core must implement this function.  Here, [[j]] is the index
of the particular term we want to compute.  The amplitude may depend on the
factorization and renormalization scales.

The [[core_state]] (workspace) argument may be used if it is provided by the caller.
Otherwise, the routine should compute the result directly.
<<Prc core: process core: TBP>>=
  procedure(prc_core_compute_amplitude), deferred :: compute_amplitude
<<Prc core: interfaces>>=
  abstract interface
     function prc_core_compute_amplitude &
          (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
          core_state) result (amp)
       import
       complex(default) :: amp
       class(prc_core_t), intent(in) :: object
       integer, intent(in) :: j
       type(vector4_t), dimension(:), intent(in) :: p
       integer, intent(in) :: f, h, c
       real(default), intent(in) :: fac_scale, ren_scale
       real(default), intent(in), allocatable :: alpha_qcd_forced
       class(prc_core_state_t), intent(inout), allocatable, optional :: &
            core_state
     end function prc_core_compute_amplitude
  end interface

@ %def prc_core_compute_amplitude
@
\subsection{Storage for intermediate results}

The abstract [[prc_core_state_t]] type allows process cores to set up temporary
workspace.  The object is an extra argument for each of the individual
calculations between kinematics setup and matrix-element evaluation.
<<Prc core: public>>=
  public :: prc_core_state_t
<<Prc core: types>>=
  type, abstract :: prc_core_state_t
   contains
     procedure(workspace_write), deferred :: write
     procedure(workspace_reset_new_kinematics), deferred :: reset_new_kinematics
  end type prc_core_state_t

@ %def prc_core_state_t
@ For debugging, we should at least have an output routine.
<<Prc core: interfaces>>=
  abstract interface
     subroutine workspace_write (object, unit)
       import
       class(prc_core_state_t), intent(in) :: object
       integer, intent(in), optional :: unit
     end subroutine workspace_write
  end interface

@ %def workspace_write
@ This is used during the NLO calculation, see there for more information.
<<Prc core: interfaces>>=
  abstract interface
    subroutine workspace_reset_new_kinematics (object)
      import
      class(prc_core_state_t), intent(inout) :: object
    end subroutine workspace_reset_new_kinematics
  end interface

@ %def workspace_reset_new_kinematics
@
\subsection{Helicity selection data}
This is intended for use with \oMega, but may also be made available to other
process methods.  We set thresholds for counting the times a specific
helicity amplitude is zero.  When the threshold is reached, we skip this
amplitude in subsequent calls.

For initializing the helicity counters, we need an object that holds the two
parameters, the threshold (large real number) and the cutoff (integer).

A helicity value suppressed by more than [[threshold]] (a value which
multiplies [[epsilon]], to be compared with the average of the current
amplitude, default is $10^{10}$) is treated as zero.  A matrix element is
assumed to be zero and not called again if it has been zero [[cutoff]] times.
<<Prc core: public>>=
  public :: helicity_selection_t
<<Prc core: types>>=
  type :: helicity_selection_t
     logical :: active = .false.
     real(default) :: threshold = 0
     integer :: cutoff = 0
   contains
   <<Prc core: helicity selection: TBP>>
  end type helicity_selection_t

@ %def helicity_selection_t
@ Output.  If the selection is inactive, print nothing.
<<Prc core: helicity selection: TBP>>=
  procedure :: write => helicity_selection_write
<<Prc core: sub interfaces>>=
    module subroutine helicity_selection_write (object, unit)
      class(helicity_selection_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine helicity_selection_write
<<Prc core: procedures>>=
  module subroutine helicity_selection_write (object, unit)
    class(helicity_selection_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (object%active) then
       write (u, "(3x,A)")  "Helicity selection data:"
       write (u, "(5x,A,ES17.10)") &
            "threshold =", object%threshold
       write (u, "(5x,A,I0)") &
            "cutoff    = ", object%cutoff
    end if
  end subroutine helicity_selection_write

@ %def helicity_selection_write
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Test process type}
For the following tests, we define a simple implementation of the abstract
[[prc_core_t]], designed such as to complement the [[prc_test_t]]
process definition type.

Note that it is not given that the actual process is defined as
[[prc_test_t]] type.  We enforce this by calling
[[prc_test_create_library]].  The driver component in the process core
will then become of type [[prc_test_t]].
@
<<[[prc_test_core.f90]]>>=
<<File header>>

module prc_test_core

<<Use kinds>>
  use lorentz
  use interactions
  use prc_test
  use prc_core

<<Standard module head>>

<<Prc test core: public>>

<<Prc test core: types>>

  interface
<<Prc test core: sub interfaces>>
  end interface

end module prc_test_core
@ %def prc_test_core
@
<<[[prc_test_core_sub.f90]]>>=
<<File header>>

submodule (prc_test_core) prc_test_core_s

  use io_units

  implicit none

contains

<<Prc test core: procedures>>

end submodule prc_test_core_s

@ %def prc_test_core_s
@
<<Prc test core: public>>=
  public :: test_t
<<Prc test core: types>>=
  type, extends (prc_core_t) :: test_t
   contains
   <<Prc test core: test type: TBP>>
  end type test_t

@ %def test_t
<<Prc test core: test type: TBP>>=
  procedure :: write => test_write
<<Prc test core: sub interfaces>>=
    module subroutine test_write (object, unit)
      class(test_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine test_write
<<Prc test core: procedures>>=
  module subroutine test_write (object, unit)
    class(test_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A)")  "test type implementing prc_test"
  end subroutine test_write

@ %def test_write
<<Prc test core: test type: TBP>>=
  procedure :: write_name => test_write_name
<<Prc test core: sub interfaces>>=
    module subroutine test_write_name (object, unit)
      class(test_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine test_write_name
<<Prc test core: procedures>>=
  module subroutine test_write_name (object, unit)
    class(test_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u,"(1x,A)")  "Core: prc_test"
  end subroutine test_write_name

@ %def test_write_name
@ This process type always needs a MC parameter set and a
single term.  This only state is always allowed.
<<Prc test core: test type: TBP>>=
  procedure :: needs_mcset => test_needs_mcset
  procedure :: get_n_terms => test_get_n_terms
  procedure :: is_allowed => test_is_allowed
<<Prc test core: sub interfaces>>=
    module function test_needs_mcset (object) result (flag)
      class(test_t), intent(in) :: object
      logical :: flag
    end function test_needs_mcset
    module function test_get_n_terms (object) result (n)
      class(test_t), intent(in) :: object
      integer :: n
    end function test_get_n_terms
    module function test_is_allowed (object, i_term, f, h, c) result (flag)
      class(test_t), intent(in) :: object
      integer, intent(in) :: i_term, f, h, c
      logical :: flag
    end function test_is_allowed
<<Prc test core: procedures>>=
  module function test_needs_mcset (object) result (flag)
    class(test_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function test_needs_mcset

  module function test_get_n_terms (object) result (n)
    class(test_t), intent(in) :: object
    integer :: n
    n = 1
  end function test_get_n_terms

  module function test_is_allowed (object, i_term, f, h, c) result (flag)
    class(test_t), intent(in) :: object
    integer, intent(in) :: i_term, f, h, c
    logical :: flag
    flag = .true.
  end function test_is_allowed

@ %def test_needs_mcset
@ %def test_get_n_terms
@ %def test_is_allowed
@ Transfer the generated momenta directly to the hard interaction in
the (only) term.  We assume that everything has been set up correctly,
so the array fits.
<<Prc test core: test type: TBP>>=
  procedure :: compute_hard_kinematics => test_compute_hard_kinematics
<<Prc test core: sub interfaces>>=
    module subroutine test_compute_hard_kinematics &
         (object, p_seed, i_term, int_hard, core_state)
      class(test_t), intent(in) :: object
      type(vector4_t), dimension(:), intent(in) :: p_seed
      integer, intent(in) :: i_term
      type(interaction_t), intent(inout) :: int_hard
      class(prc_core_state_t), intent(inout), allocatable :: core_state
    end subroutine test_compute_hard_kinematics
<<Prc test core: procedures>>=
  module subroutine test_compute_hard_kinematics &
       (object, p_seed, i_term, int_hard, core_state)
    class(test_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p_seed
    integer, intent(in) :: i_term
    type(interaction_t), intent(inout) :: int_hard
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    call int_hard%set_momenta (p_seed)
  end subroutine test_compute_hard_kinematics

@ %def test_compute_hard_kinematics
@ This procedure is not called for [[test_t]], just a placeholder.
<<Prc test core: test type: TBP>>=
  procedure :: compute_eff_kinematics => test_compute_eff_kinematics
<<Prc test core: sub interfaces>>=
    module subroutine test_compute_eff_kinematics &
         (object, i_term, int_hard, int_eff, core_state)
      class(test_t), intent(in) :: object
      integer, intent(in) :: i_term
      type(interaction_t), intent(in) :: int_hard
      type(interaction_t), intent(inout) :: int_eff
      class(prc_core_state_t), intent(inout), allocatable :: core_state
    end subroutine test_compute_eff_kinematics
<<Prc test core: procedures>>=
  module subroutine test_compute_eff_kinematics &
       (object, i_term, int_hard, int_eff, core_state)
    class(test_t), intent(in) :: object
    integer, intent(in) :: i_term
    type(interaction_t), intent(in) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
  end subroutine test_compute_eff_kinematics

@ %def test_compute_eff_kinematics
@ Transfer the incoming momenta of [[p_seed]] directly to the
effective interaction, and vice versa for the outgoing momenta.

[[int_hard]] is left untouched since [[int_eff]] is an alias (via
pointer) to it.
<<Prc test core: test type: TBP>>=
  procedure :: recover_kinematics => test_recover_kinematics
<<Prc test core: sub interfaces>>=
    module subroutine test_recover_kinematics &
         (object, p_seed, int_hard, int_eff, core_state)
      class(test_t), intent(in) :: object
      type(vector4_t), dimension(:), intent(inout) :: p_seed
      type(interaction_t), intent(inout) :: int_hard
      type(interaction_t), intent(inout) :: int_eff
      class(prc_core_state_t), intent(inout), allocatable :: core_state
    end subroutine test_recover_kinematics
<<Prc test core: procedures>>=
  module subroutine test_recover_kinematics &
       (object, p_seed, int_hard, int_eff, core_state)
    class(test_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(inout) :: p_seed
    type(interaction_t), intent(inout) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    integer :: n_in
    n_in = int_eff%get_n_in ()
    call int_eff%set_momenta (p_seed(1:n_in), outgoing = .false.)
    p_seed(n_in+1:) = int_eff%get_momenta (outgoing = .true.)
  end subroutine test_recover_kinematics

@ %def test_recover_kinematics
@ Compute the amplitude.  The driver ignores all quantum numbers and,
in fact, returns a constant.  Nevertheless, we properly transfer the
momentum vectors.
<<Prc test core: test type: TBP>>=
  procedure :: compute_amplitude => test_compute_amplitude
<<Prc test core: sub interfaces>>=
    module function test_compute_amplitude &
         (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
         core_state) result (amp)
      class(test_t), intent(in) :: object
      integer, intent(in) :: j
      type(vector4_t), dimension(:), intent(in) :: p
      integer, intent(in) :: f, h, c
      real(default), intent(in) :: fac_scale, ren_scale
      real(default), intent(in), allocatable :: alpha_qcd_forced
      class(prc_core_state_t), intent(inout), allocatable, optional :: &
           core_state
      complex(default) :: amp
    end function test_compute_amplitude
<<Prc test core: procedures>>=
  module function test_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
       core_state) result (amp)
    class(test_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: core_state
    complex(default) :: amp
    real(default), dimension(:,:), allocatable :: parray
    integer :: i, n_tot
    select type (driver => object%driver)
    type is (prc_test_t)
       if (driver%scattering) then
          n_tot = 4
       else
          n_tot = 3
       end if
       allocate (parray (0:3,n_tot))
       forall (i = 1:n_tot)  parray(:,i) = vector4_get_components (p(i))
       amp = driver%get_amplitude (parray)
    end select
  end function test_compute_amplitude

@ %def test_compute_amplitude
@
@
\section{Template matrix elements}

Here, we provide template matrix elements that are in structure
very similar to \oMega\ matrix elements, but do not need its
infrastructure. Per default, the matrix elements are flat, i.e.
they have the constant value one. Analogous to the \oMega\
implementation, this section implements the interface
to the templates (via the makefile) and the driver.
<<[[prc_template_me.f90]]>>=
<<File header>>

module prc_template_me

  use, intrinsic ::  iso_c_binding !NODEP!

  use kinds
<<Use strings>>
  use os_interface
  use lorentz
  use interactions
  use model_data

  use particle_specifiers, only: new_prt_spec
  use process_constants
  use prclib_interfaces
  use prc_core_def
  use process_libraries
  use prc_core

<<Standard module head>>

<<Template matrix elements: public>>

<<Template matrix elements: types>>

<<Template matrix elements: interfaces>>

  interface
<<Template matrix elements: sub interfaces>>
  end interface

contains

<<Template matrix elements: main procedures>>

end module prc_template_me
@ %def prc_template_me
@
<<[[prc_template_me_sub.f90]]>>=
<<File header>>

submodule (prc_template_me) prc_template_me_s

  use io_units
  use system_defs, only: TAB
  use diagnostics
  use flavors

  implicit none

contains

<<Template matrix elements: procedures>>

end submodule prc_template_me_s

@ %def prc_template_me_s
@
\subsection{Process definition}
For the process definition we implement an extension of the
[[prc_core_def_t]] abstract type.
<<Template matrix elements: public>>=
  public :: template_me_def_t
<<Template matrix elements: types>>=
  type, extends (prc_core_def_t) :: template_me_def_t
   contains
   <<Template matrix elements: template ME def: TBP>>
  end type template_me_def_t

@ %def template_me_def_t
<<Template matrix elements: template ME def: TBP>>=
  procedure, nopass :: type_string => template_me_def_type_string
<<Template matrix elements: sub interfaces>>=
    module function template_me_def_type_string () result (string)
      type(string_t) :: string
    end function template_me_def_type_string
<<Template matrix elements: procedures>>=
  module function template_me_def_type_string () result (string)
    type(string_t) :: string
    string = "template"
  end function template_me_def_type_string

@ %def template_me_def_type_string
@ Initialization: allocate the writer for the template matrix element.
Also set any data for this process that the writer needs.
Gfortran 7/8/9 bug, has to remain in the main module.
<<Template matrix elements: template ME def: TBP>>=
  procedure :: init => template_me_def_init
<<Template matrix elements: main procedures>>=
  subroutine template_me_def_init &
       (object, model, prt_in, prt_out, unity)
    class(template_me_def_t), intent(out) :: object
    class(model_data_t), intent(in), target :: model
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    logical, intent(in) :: unity
    allocate (template_me_writer_t :: object%writer)
    select type (writer => object%writer)
    type is (template_me_writer_t)
       call writer%init (model, prt_in, prt_out, unity)
    end select
  end subroutine template_me_def_init

@ %def template_me_def_init
@ Write/read process- and method-specific data.
<<Template matrix elements: template ME def: TBP>>=
  procedure :: write => template_me_def_write
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_def_write (object, unit)
      class(template_me_def_t), intent(in) :: object
      integer, intent(in) :: unit
    end subroutine template_me_def_write
<<Template matrix elements: procedures>>=
  module subroutine template_me_def_write (object, unit)
    class(template_me_def_t), intent(in) :: object
    integer, intent(in) :: unit
    select type (writer => object%writer)
    type is (template_me_writer_t)
       call writer%write (unit)
    end select
  end subroutine template_me_def_write

@ %def template_me_def_write
@
<<Template matrix elements: template ME def: TBP>>=
  procedure :: read => template_me_def_read
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_def_read (object, unit)
      class(template_me_def_t), intent(out) :: object
      integer, intent(in) :: unit
    end subroutine template_me_def_read
<<Template matrix elements: procedures>>=
  module subroutine template_me_def_read (object, unit)
    class(template_me_def_t), intent(out) :: object
    integer, intent(in) :: unit
    call msg_bug &
         ("WHIZARD template process definition: input not supported (yet)")
  end subroutine template_me_def_read

@ %def template_me_def_read
@ Allocate the driver for template matrix elements.
Gfortran 7/8/9 bug, has to remain in the main module.
<<Template matrix elements: template ME def: TBP>>=
  procedure :: allocate_driver => template_me_def_allocate_driver
<<Template matrix elements: main procedures>>=
  subroutine template_me_def_allocate_driver (object, driver, basename)
    class(template_me_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    allocate (template_me_driver_t :: driver)
  end subroutine template_me_def_allocate_driver

@ %def template_me_def_allocate_driver
@ We need code:
<<Template matrix elements: template ME def: TBP>>=
  procedure, nopass :: needs_code => template_me_def_needs_code
<<Template matrix elements: sub interfaces>>=
    module function template_me_def_needs_code () result (flag)
      logical :: flag
    end function template_me_def_needs_code
<<Template matrix elements: procedures>>=
  module function template_me_def_needs_code () result (flag)
    logical :: flag
    flag = .true.
  end function template_me_def_needs_code

@ %def template_me_def_needs_code
@ These are the features that a template matrix element provides.
<<Template matrix elements: template ME def: TBP>>=
  procedure, nopass :: get_features => template_me_def_get_features
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_def_get_features (features)
      type(string_t), dimension(:), allocatable, intent(out) :: features
    end subroutine template_me_def_get_features
<<Template matrix elements: procedures>>=
  module subroutine template_me_def_get_features (features)
    type(string_t), dimension(:), allocatable, intent(out) :: features
    allocate (features (5))
    features = [ &
         var_str ("init"), &
         var_str ("update_alpha_s"), &
         var_str ("is_allowed"), &
         var_str ("new_event"), &
         var_str ("get_amplitude")]
  end subroutine template_me_def_get_features

@ %def template_me_def_get_features
@ The interface of the specific features.
<<Template matrix elements: interfaces>>=
  abstract interface
     subroutine init_t (par, scheme) bind(C)
       import
       real(c_default_float), dimension(*), intent(in) :: par
       integer(c_int), intent(in) :: scheme
     end subroutine init_t
  end interface

  abstract interface
     subroutine update_alpha_s_t (alpha_s) bind(C)
       import
       real(c_default_float), intent(in) :: alpha_s
     end subroutine update_alpha_s_t
  end interface

  abstract interface
     subroutine is_allowed_t (flv, hel, col, flag) bind(C)
       import
       integer(c_int), intent(in) :: flv, hel, col
       logical(c_bool), intent(out) :: flag
     end subroutine is_allowed_t
  end interface

  abstract interface
     subroutine new_event_t (p) bind(C)
       import
       real(c_default_float), dimension(0:3,*), intent(in) :: p
     end subroutine new_event_t
  end interface

  abstract interface
     subroutine get_amplitude_t (flv, hel, col, amp) bind(C)
       import
       integer(c_int), intent(in) :: flv, hel, col
       complex(c_default_complex), intent(out):: amp
     end subroutine get_amplitude_t
  end interface

@ %def init_t update_alpha_s_t
@ %def is_allowed_t new_event_t get_amplitude_t
@ Connect the template matrix element features with the process driver.
<<Template matrix elements: template ME def: TBP>>=
  procedure :: connect => template_me_def_connect
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_def_connect (def, lib_driver, i, proc_driver)
      class(template_me_def_t), intent(in) :: def
      class(prclib_driver_t), intent(in) :: lib_driver
      integer, intent(in) :: i
      class(prc_core_driver_t), intent(inout) :: proc_driver
    end subroutine template_me_def_connect
<<Template matrix elements: procedures>>=
  module subroutine template_me_def_connect (def, lib_driver, i, proc_driver)
    class(template_me_def_t), intent(in) :: def
    class(prclib_driver_t), intent(in) :: lib_driver
    integer, intent(in) :: i
    class(prc_core_driver_t), intent(inout) :: proc_driver
    integer(c_int) :: pid, fid
    type(c_funptr) :: fptr
    select type (proc_driver)
    type is  (template_me_driver_t)
       pid = i
       fid = 1
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%init)
       fid = 2
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%update_alpha_s)
       fid = 3
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%is_allowed)
       fid = 4
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%new_event)
       fid = 5
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%get_amplitude)
    end select
  end subroutine template_me_def_connect

@ %def template_me_def_connect
@
\subsection{The Template Matrix element writer}
Unlike \oMega, the template matrix element is directly written by the main
\whizard\ program, so there will be no entry in the makefile for
calling an external program. The template matrix element writer is
responsible for writing interfaces and wrappers.
<<Template matrix elements: types>>=
  type, extends (prc_writer_f_module_t) :: template_me_writer_t
     class(model_data_t), pointer :: model => null ()
     type(string_t) :: model_name
     logical :: unity
     type(string_t), dimension(:), allocatable :: prt_in
     type(string_t), dimension(:), allocatable :: prt_out
     integer :: n_in
     integer :: n_out
     integer :: n_tot
   contains
   <<Template matrix elements: template ME writer: TBP>>
  end type template_me_writer_t

@ %def template_me_writer_t
@ The reported type is the same as for the [[template_me_def_t]] type.
<<Template matrix elements: template ME writer: TBP>>=
  procedure, nopass :: type_name => template_me_writer_type_name
<<Template matrix elements: sub interfaces>>=
    module function template_me_writer_type_name () result (string)
      type(string_t) :: string
    end function template_me_writer_type_name
<<Template matrix elements: procedures>>=
  module function template_me_writer_type_name () result (string)
    type(string_t) :: string
    string = "template"
  end function template_me_writer_type_name

@ %def template_me_writer_type_name
@ Taking into account the prefix for template ME module names.
<<Template matrix elements: template ME writer: TBP>>=
  procedure, nopass :: get_module_name => template_me_writer_get_module_name
<<Template matrix elements: sub interfaces>>=
    module function template_me_writer_get_module_name (id) result (name)
      type(string_t) :: name
      type(string_t), intent(in) :: id
    end function template_me_writer_get_module_name
<<Template matrix elements: procedures>>=
  module function template_me_writer_get_module_name (id) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: id
    name = "tpr_" // id
  end function template_me_writer_get_module_name

@ %def template_me_writer_get_module_name
@ Output.  This is called by [[template_me_def_write]].
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: write => template_me_writer_write
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_writer_write (object, unit)
      class(template_me_writer_t), intent(in) :: object
      integer, intent(in) :: unit
    end subroutine template_me_writer_write
<<Template matrix elements: procedures>>=
  module subroutine template_me_writer_write (object, unit)
    class(template_me_writer_t), intent(in) :: object
    integer, intent(in) :: unit
    integer :: i, j
    write (unit, "(5x,A,I0)") "# incoming part. = ", object%n_in
    write (unit, "(7x,A)", advance="no") &
                              "   Initial state: "
    do i = 1, object%n_in - 1
       write (unit, "(1x,A)", advance="no") char (object%prt_in(i))
    end do
    write (unit, "(1x,A)") char (object%prt_in(object%n_in))
    write (unit, "(5x,A,I0)") "# outgoing part. = ", object%n_out
    write (unit, "(7x,A)", advance="no") &
                              "   Final state:   "
    do j = 1, object%n_out - 1
       write (unit, "(1x,A)", advance="no") char (object%prt_out(j))
    end do
    write (unit, "(1x,A)") char (object%prt_out(object%n_out))
    write (unit, "(5x,A,I0)") "# part. (total) = ", object%n_tot
  end subroutine template_me_writer_write

@ %def template_me_writer_write
@ Initialize with process data.
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: init => template_me_writer_init
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_writer_init (writer, model, &
         prt_in, prt_out, unity)
      class(template_me_writer_t), intent(out) :: writer
      class(model_data_t), intent(in), target :: model
      type(string_t), dimension(:), intent(in) :: prt_in
      type(string_t), dimension(:), intent(in) :: prt_out
      logical, intent(in) :: unity
    end subroutine template_me_writer_init
<<Template matrix elements: procedures>>=
  module subroutine template_me_writer_init (writer, model, &
       prt_in, prt_out, unity)
    class(template_me_writer_t), intent(out) :: writer
    class(model_data_t), intent(in), target :: model
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    logical, intent(in) :: unity
    writer%model => model
    writer%model_name = model%get_name ()
    writer%n_in = size (prt_in)
    writer%n_out = size (prt_out)
    writer%n_tot = size (prt_in) + size (prt_out)
    allocate (writer%prt_in (size (prt_in)), source = prt_in)
    allocate (writer%prt_out (size (prt_out)), source = prt_out)
    writer%unity = unity
  end subroutine template_me_writer_init

@ %def template_me_writer_init
@ The makefile is the driver file for the test matrix elements.
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: write_makefile_code => template_me_write_makefile_code
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_write_makefile_code &
         (writer, unit, id, os_data, verbose, testflag)
      class(template_me_writer_t), intent(in) :: writer
      integer, intent(in) :: unit
      type(string_t), intent(in) :: id
      type(os_data_t), intent(in) :: os_data
      logical, intent(in) :: verbose
      logical, intent(in), optional :: testflag
    end subroutine template_me_write_makefile_code
<<Template matrix elements: procedures>>=
  module subroutine template_me_write_makefile_code &
       (writer, unit, id, os_data, verbose, testflag)
    class(template_me_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: verbose
    logical, intent(in), optional :: testflag
    write (unit, "(5A)")  "SOURCES += ", char (id), ".f90"
    write (unit, "(5A)")  "OBJECTS += ", char (id), ".lo"
    write (unit, "(5A)")  "clean-", char (id), ":"
    if (verbose) then
       write (unit, "(5A)")  TAB, "rm -f tpr_", char (id), ".mod"
       write (unit, "(5A)")  TAB, "rm -f ", char (id), ".lo"
    else
       write (unit, "(5A)")  TAB // '@echo  "  RM        ', &
            trim (char (id)), '.mod"'
       write (unit, "(5A)")  TAB, "@rm -f tpr_", char (id), ".mod"
       write (unit, "(5A)")  TAB // '@echo  "  RM        ', &
            trim (char (id)), '.lo"'
       write (unit, "(5A)")  TAB, "@rm -f ", char (id), ".lo"
    end if
    write (unit, "(5A)")  "CLEAN_SOURCES += ", char (id), ".f90"
    write (unit, "(5A)")  "CLEAN_OBJECTS += tpr_", char (id), ".mod"
    write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), ".lo"
    write (unit, "(5A)")  char (id), ".lo: ", char (id), ".f90"
    if (.not. verbose) then
       write (unit, "(5A)")  TAB // '@echo  "  FC       " $@'
    end if
    write (unit, "(5A)")  TAB, "$(LTFCOMPILE) $<"
  end subroutine template_me_write_makefile_code

@ %def template_me_write_makefile_code
@ The source is written by this routine.
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: write_source_code => template_me_write_source_code
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_write_source_code (writer, id)
      class(template_me_writer_t), intent(in) :: writer
      type(string_t), intent(in) :: id
    end subroutine template_me_write_source_code
<<Template matrix elements: procedures>>=
  module subroutine template_me_write_source_code (writer, id)
    class(template_me_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
    integer, dimension(writer%n_in) :: prt_in, mult_in, col_in
    type(flavor_t), dimension(1:writer%n_in) :: flv_in
    integer, dimension(writer%n_out) :: prt_out, mult_out
    integer, dimension(writer%n_tot) :: prt, mult
    integer, dimension(:,:), allocatable :: sxxx
    integer :: dummy, status
    type(flavor_t), dimension(1:writer%n_out) :: flv_out
    type(string_t) :: proc_str, comment_str, col_str
    integer :: u, i, j
    integer :: hel, hel_in, hel_out, fac, factor, col_fac
    type(string_t) :: filename
    comment_str = ""
    do i = 1, writer%n_in
       comment_str = comment_str // writer%prt_in(i) // " "
    end do
    do j = 1, writer%n_out
       comment_str = comment_str // writer%prt_out(j) // " "
    end do
    do i = 1, writer%n_in
       prt_in(i) = writer%model%get_pdg (writer%prt_in(i))
       call flv_in(i)%init (prt_in(i), writer%model)
       mult_in(i) = flv_in(i)%get_multiplicity ()
       col_in(i) = abs (flv_in(i)%get_color_type ())
       mult(i) = mult_in(i)
       end do
    do j = 1, writer%n_out
       prt_out(j) = writer%model%get_pdg (writer%prt_out(j))
       call flv_out(j)%init (prt_out(j), writer%model)
       mult_out(j) = flv_out(j)%get_multiplicity ()
       mult(writer%n_in + j) = mult_out(j)
       end do
    prt(1:writer%n_in) = prt_in(1:writer%n_in)
    prt(writer%n_in+1:writer%n_tot) = prt_out(1:writer%n_out)
    proc_str = converter (prt)
    hel_in = product (mult_in)
    hel_out = product (mult_out)
    col_fac = product (col_in)
    hel = hel_in * hel_out
    fac = hel
    dummy = 1
    factor = 1
    if (writer%n_out >= 3) then
       do i = 3, writer%n_out
          factor = factor * (i - 2) * (i - 1)
       end do
    end if
    factor = factor * col_fac
    allocate (sxxx(1:hel,1:writer%n_tot))
    call create_spin_table (dummy,hel,fac,mult,sxxx)
    call msg_message ("Writing test matrix element for process '" &
         // char (id) // "'")
    filename = id // ".f90"
    u = free_unit ()
    open (unit=u, file=char(filename), action="write")
    write (u, "(A)") "! File generated automatically by WHIZARD"
    write (u, "(A)") "!                                        "
    write (u, "(A)") "! Note that irresp. of what you demanded WHIZARD"
    write (u, "(A)") "! treats this as colorless process       "
    write (u, "(A)") "!                                        "
    write (u, "(A)") "module tpr_" // char(id)
    write (u, "(A)") "                                         "
    write (u, "(A)") "  use kinds"
    write (u, "(A)") "  use omega_color, OCF => omega_color_factor"
    write (u, "(A)") "                                         "
    write (u, "(A)") "  implicit none"
    write (u, "(A)") "  private"
    write (u, "(A)") "                                         "
    write (u, "(A)") "  public :: md5sum"
    write (u, "(A)") "  public :: number_particles_in, number_particles_out"
    write (u, "(A)") "  public :: number_spin_states, spin_states"
    write (u, "(A)") "  public :: number_flavor_states, flavor_states"
    write (u, "(A)") "  public :: number_color_flows, color_flows"
    write (u, "(A)") "  public :: number_color_indices, number_color_factors, &"
    write (u, "(A)") "     color_factors, color_sum, openmp_supported"
    write (u, "(A)") "  public :: init, final, update_alpha_s"
    write (u, "(A)") "                                         "
    write (u, "(A)") "  public :: new_event, is_allowed, get_amplitude"
    write (u, "(A)") "       "
    write (u, "(A)") "  real(default), parameter :: &"
    write (u, "(A)") "       & conv = 0.38937966e12_default"
    write (u, "(A)") "       "
    write (u, "(A)") "  real(default), parameter :: &"
    write (u, "(A)") "       & pi = 3.1415926535897932384626433832795028841972_default"
    write (u, "(A)") "       "
    write (u, "(A)") "  real(default), parameter :: &"
    if (writer%unity) then
       write (u, "(A)") "                   & const = 1"
    else
       write (u, "(A,1x,I0,A)") "       & const = (16 * pi / conv) * " &
          // "(16 * pi**2)**(", writer%n_out, "-2) "
    end if
    write (u, "(A)") "       "
    write (u, "(A,1x,I0)") "  integer, parameter, private :: n_prt =  ", &
       writer%n_tot
    write (u, "(A,1x,I0)") "  integer, parameter, private :: n_in = ", &
       writer%n_in
    write (u, "(A,1x,I0)") "  integer, parameter, private :: n_out = ", &
       writer%n_out
    write (u, "(A)") "  integer, parameter, private :: n_cflow = 1"
    write (u, "(A)") "  integer, parameter, private :: n_cindex = 2"
    write (u, "(A)") "  !!! We ignore tensor products and take only one flavor state."
    write (u, "(A)") "  integer, parameter, private :: n_flv = 1"
    write (u, "(A,1x,I0)") "  integer, parameter, private :: n_hel = ", hel
    write (u, "(A)") "                                           "
    write (u, "(A)") "  logical, parameter, private :: T = .true."
    write (u, "(A)") "  logical, parameter, private :: F = .false."
    write (u, "(A)") "                                           "
    do i = 1, hel
       write (u, "(A)") "  integer, dimension(n_prt), parameter, private :: &"
       write (u, "(A)") "    " // s_conv(i) // " = [ " // &
            char(converter(sxxx(i,1:writer%n_tot))) // " ]"
    end do
    write (u, "(A)") "  integer, dimension(n_prt,n_hel), parameter, private :: table_spin_states = &"
    write (u, "(A)") "    reshape ( [ & "
    do i = 1, hel-1
       write (u, "(A)") "                 " // s_conv(i) // ", & "
    end do
    write (u, "(A)") "                 " // s_conv(hel) // " & "
    write (u, "(A)") "              ], [ n_prt, n_hel ] )"
    write (u, "(A)") "                                                 "
    write (u, "(A)") "  integer, dimension(n_prt), parameter, private :: &"
    write (u, "(A)") "    f0001 = [ " // char(proc_str) // " ]   !  " // char(comment_str)
    write (u, "(A)") "  integer, dimension(n_prt,n_flv), parameter, private :: table_flavor_states = &"
    write (u, "(A)") "    reshape ( [ f0001 ], [ n_prt, n_flv ] )"
    write (u, "(A)") "                                                 "
    write (u, "(A)") "  integer, dimension(n_cindex, n_prt), parameter, private :: &"
    !!! This produces non-matching color flows, better keep it completely colorless
    ! write (u, "(A)") "    c0001 = reshape ( [ " // char (dummy_colorizer (flv_in)) // &
    !                          " " // &
    select case (writer%n_in)
    case (1)
       col_str = "0,0,"
    case (2)
       col_str = "0,0,0,0,"
    end select
    write (u, "(A)") "    c0001 = reshape ( [" // char (col_str) // &
      (repeat ("0,0, ", writer%n_out-1)) // "0,0 ], " // " [ n_cindex, n_prt ] )"
    write (u, "(A)") "  integer, dimension(n_cindex, n_prt, n_cflow), parameter, private :: &"
    write (u, "(A)") "  table_color_flows = reshape ( [ c0001 ], [ n_cindex, n_prt, n_cflow ] )"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  logical, dimension(n_prt), parameter, private :: & "
    write (u, "(A)") "    g0001 = [ "  // (repeat ("F, ", writer%n_tot-1)) // "F ] "
    write (u, "(A)") "  logical, dimension(n_prt, n_cflow), parameter, private " &
         // ":: table_ghost_flags = &"
    write (u, "(A)") "    reshape ( [ g0001 ], [ n_prt, n_cflow ] )"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  integer, parameter, private :: n_cfactors = 1"
    write (u, "(A)") "  type(OCF), dimension(n_cfactors), parameter, private :: &"
    write (u, "(A)") "    table_color_factors = [  OCF(1,1,+1._default) ]"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  logical, dimension(n_flv), parameter, private :: a0001 = [ T ]"
    write (u, "(A)") "  logical, dimension(n_flv, n_cflow), parameter, private :: &"
    write (u, "(A)") "    flv_col_is_allowed = reshape ( [ a0001 ], [ n_flv, n_cflow ] )"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  complex(default), dimension (n_flv, n_hel, n_cflow), private, save :: amp"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  logical, dimension(n_hel), private, save :: hel_is_allowed = T"
    write (u, "(A)") "                                           "
    write (u, "(A)") "contains"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure function md5sum ()"
    write (u, "(A)") "    character(len=32) :: md5sum"
    write (u, "(A)") "    ! DON'T EVEN THINK of modifying the following line!"
    write (u, "(A)") "    md5sum = """ // writer%md5sum // """"
    write (u, "(A)") "  end function md5sum"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  subroutine init (par, scheme)"
    write (u, "(A)") "    real(default), dimension(*), intent(in) :: par"
    write (u, "(A)") "    integer, intent(in) :: scheme"
    write (u, "(A)") "  end subroutine init"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  subroutine final ()"
    write (u, "(A)") "  end subroutine final"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  subroutine update_alpha_s (alpha_s)"
    write (u, "(A)") "    real(default), intent(in) :: alpha_s"
    write (u, "(A)") "  end subroutine update_alpha_s"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure function number_particles_in () result (n)"
    write (u, "(A)") "    integer :: n"
    write (u, "(A)") "    n = n_in"
    write (u, "(A)") "  end function number_particles_in"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure function number_particles_out () result (n)"
    write (u, "(A)") "    integer :: n"
    write (u, "(A)") "    n = n_out"
    write (u, "(A)") "  end function number_particles_out"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure function number_spin_states () result (n)"
    write (u, "(A)") "    integer :: n"
    write (u, "(A)") "    n = size (table_spin_states, dim=2)"
    write (u, "(A)") "  end function number_spin_states"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure subroutine spin_states (a)"
    write (u, "(A)") "    integer, dimension(:,:), intent(out) :: a"
    write (u, "(A)") "    a = table_spin_states"
    write (u, "(A)") "  end subroutine spin_states"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure function number_flavor_states () result (n)"
    write (u, "(A)") "    integer :: n"
    write (u, "(A)") "    n = 1"
    write (u, "(A)") "  end function number_flavor_states"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure subroutine flavor_states (a)"
    write (u, "(A)") "    integer, dimension(:,:), intent(out) :: a"
    write (u, "(A)") "    a = table_flavor_states"
    write (u, "(A)") "  end subroutine flavor_states"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure function number_color_indices () result (n)"
    write (u, "(A)") "    integer :: n"
    write (u, "(A)") "    n = size(table_color_flows, dim=1)"
    write (u, "(A)") "  end function number_color_indices"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure subroutine color_factors (cf)"
    write (u, "(A)") "    type(OCF), dimension(:), intent(out) :: cf"
    write (u, "(A)") "    cf = table_color_factors"
    write (u, "(A)") "  end subroutine color_factors"
    write (u, "(A)") "                                           "
    !pure unless OpenMP
    !write (u, "(A)") "  pure function color_sum (flv, hel) result (amp2)"
    write (u, "(A)") "  function color_sum (flv, hel) result (amp2)"
    write (u, "(A)") "    integer, intent(in) :: flv, hel"
    write (u, "(A)") "    real(kind=default) :: amp2"
    write (u, "(A)") "    amp2 = real (omega_color_sum (flv, hel, amp, table_color_factors))"
    write (u, "(A)") "  end function color_sum"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure function number_color_flows () result (n)"
    write (u, "(A)") "    integer :: n"
    write (u, "(A)") "    n = size (table_color_flows, dim=3)"
    write (u, "(A)") "  end function number_color_flows"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure subroutine color_flows (a, g)"
    write (u, "(A)") "    integer, dimension(:,:,:), intent(out) :: a"
    write (u, "(A)") "    logical, dimension(:,:), intent(out) :: g"
    write (u, "(A)") "    a = table_color_flows"
    write (u, "(A)") "    g = table_ghost_flags"
    write (u, "(A)") "  end subroutine color_flows"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure function number_color_factors () result (n)"
    write (u, "(A)") "    integer :: n"
    write (u, "(A)") "    n = size (table_color_factors)"
    write (u, "(A)") "  end function number_color_factors"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure function openmp_supported () result (status)"
    write (u, "(A)") "    logical :: status"
    write (u, "(A)") "    status = .false."
    write (u, "(A)") "  end function openmp_supported"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  subroutine new_event (p)"
    write (u, "(A)") "    real(default), dimension(0:3,*), intent(in) :: p"
    write (u, "(A)") "    call calculate_amplitudes (amp, p)"
    write (u, "(A)") "  end subroutine new_event"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure function is_allowed (flv, hel, col) result (yorn)"
    write (u, "(A)") "    logical :: yorn"
    write (u, "(A)") "    integer, intent(in) :: flv, hel, col"
    write (u, "(A)") "    yorn = hel_is_allowed(hel) .and. flv_col_is_allowed(flv,col)"
    write (u, "(A)") "  end function is_allowed"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure function get_amplitude (flv, hel, col) result (amp_result)"
    write (u, "(A)") "    complex(default) :: amp_result"
    write (u, "(A)") "    integer, intent(in) :: flv, hel, col"
    write (u, "(A)") "    amp_result = amp (flv, hel, col)"
    write (u, "(A)") "  end function get_amplitude"
    write (u, "(A)") "                                           "
    write (u, "(A)") "  pure subroutine calculate_amplitudes (amp, k)"
    write (u, "(A)") "    complex(default), dimension(:,:,:), intent(out) :: amp"
    write (u, "(A)") "    real(default), dimension(0:3,*), intent(in) :: k"
    write (u, "(A)") "    real(default) :: fac"
    write (u, "(A)") "    integer :: i"
    write (u, "(A)") "    ! We give all helicities the same weight!"
    if (writer%unity) then
       write (u, "(A,1x,I0,1x,A)") "    fac = ", col_fac
       write (u, "(A)") "    amp = const * sqrt(fac)"
    else
       write (u, "(A,1x,I0,1x,A)") "    fac = ", factor
       write (u, "(A)") "    amp = sqrt((2 * (k(0,1)*k(0,2) &"
       write (u, "(A,1x,I0,A)") "         - dot_product (k(1:,1), k(1:,2)))) ** (3-", &
                                  writer%n_out, ")) * sqrt(const * fac)"
    end if
    write (u, "(A,1x,I0,A)") "    amp = amp / sqrt(", hel_out, "._default)"
    write (u, "(A)") "  end subroutine calculate_amplitudes"
    write (u, "(A)") "                                           "
    write (u, "(A)") "end module tpr_" // char(id)
    close (u, iostat=status)
    deallocate (sxxx)
  contains
    function s_conv (num) result (chrt)
      integer, intent(in) :: num
      character(len=10) :: chrt
      write (chrt, "(I10)") num
      chrt = trim(adjustl(chrt))
      if (num < 10) then
         chrt = "s000" // chrt
      else if (num < 100) then
         chrt = "s00" // chrt
      else if (num < 1000) then
         chrt = "s0" // chrt
      else
         chrt = "s" // chrt
      end if
    end function s_conv
    function converter (flv) result (str)
      integer, dimension(:), intent(in) :: flv
      type(string_t) :: str
      character(len=150), dimension(size(flv)) :: chrt
      integer :: i
      str = ""
      do i = 1, size(flv) - 1
         write (chrt(i), "(I10)") flv(i)
         str = str // var_str(trim(adjustl(chrt(i)))) // ", "
      end do
      write (chrt(size(flv)), "(I10)") flv(size(flv))
      str = str // trim(adjustl(chrt(size(flv))))
    end function converter
    integer function sj (j,m)
      integer, intent(in) :: j, m
      if (((j == 1) .and. (m == 1)) .or. &
          ((j == 2) .and. (m == 2)) .or. &
          ((j == 3) .and. (m == 3)) .or. &
          ((j == 4) .and. (m == 3)) .or. &
          ((j == 5) .and. (m == 4))) then
         sj = 1
      else if (((j == 2) .and. (m == 1)) .or. &
          ((j == 3) .and. (m == 1)) .or. &
          ((j == 4) .and. (m == 2)) .or. &
          ((j == 5) .and. (m == 2))) then
         sj = -1
      else if (((j == 3) .and. (m == 2)) .or. &
          ((j == 5) .and. (m == 3))) then
         sj = 0
      else if (((j == 4) .and. (m == 1)) .or. &
          ((j == 5) .and. (m == 1))) then
         sj = -2
      else if (((j == 4) .and. (m == 4)) .or. &
          ((j == 5) .and. (m == 5))) then
         sj = 2
      else
         call msg_fatal ("template_me_write_source_code: Wrong spin type")
      end if
    end function sj
    recursive subroutine create_spin_table (index, nhel, fac, mult, inta)
      integer, intent(inout) :: index, fac
      integer, intent(in) :: nhel
      integer, dimension(:), intent(in) :: mult
      integer, dimension(nhel,size(mult)), intent(out) :: inta
      integer :: j
      if (index > size(mult)) return
      fac = fac / mult(index)
      do j = 1, nhel
         inta(j,index) = sj (mult(index),mod(((j-1)/fac),mult(index))+1)
      end do
      index = index + 1
      call create_spin_table (index, nhel, fac, mult, inta)
    end subroutine create_spin_table
    function dummy_colorizer (flv) result (str)
      type(flavor_t), dimension(:), intent(in) :: flv
      type(string_t) :: str
      integer :: i, k
      str = ""
      k = 0
      do i = 1, size(flv)
         k = k + 1
         select case (flv(i)%get_color_type ())
	 case (1,-1)
	    str = str // "0,0, "
	 case (3)
	    str = str // int2string(k) // ",0, "
	 case (-3)
	    str = str // "0," // int2string(-k) // ", "
	 case (8)
	    str = str // int2string(k) // "," // int2string(-k-1) // ", "
	    k = k + 1
	 case default
	    call msg_error ("Color type not supported.")
	 end select
      end do
      str = adjustl(trim(str))
    end function dummy_colorizer
  end subroutine template_me_write_source_code

@ %def template_me_write_source_code
@ Nothing to be done here.
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: before_compile => template_me_before_compile
  procedure :: after_compile => template_me_after_compile
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_before_compile (writer, id)
      class(template_me_writer_t), intent(in) :: writer
      type(string_t), intent(in) :: id
    end subroutine template_me_before_compile
    module subroutine template_me_after_compile (writer, id)
      class(template_me_writer_t), intent(in) :: writer
      type(string_t), intent(in) :: id
    end subroutine template_me_after_compile
<<Template matrix elements: procedures>>=
  module subroutine template_me_before_compile (writer, id)
    class(template_me_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
  end subroutine template_me_before_compile

  module subroutine template_me_after_compile (writer, id)
    class(template_me_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
  end subroutine template_me_after_compile

@ %def template_me_before_compile
@ %def template_me_after_compile
@ Return the name of a procedure that implements a given feature, as
it is provided by the template matrix-element code.  Template ME names
are chosen completely in analogy to the \oMega\ matrix element
conventions.
<<Template matrix elements: template ME writer: TBP>>=
  procedure, nopass :: get_procname => template_me_writer_get_procname
<<Template matrix elements: sub interfaces>>=
    module function template_me_writer_get_procname (feature) result (name)
      type(string_t) :: name
      type(string_t), intent(in) :: feature
    end function template_me_writer_get_procname
<<Template matrix elements: procedures>>=
  module function template_me_writer_get_procname (feature) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: feature
    select case (char (feature))
    case ("n_in");   name = "number_particles_in"
    case ("n_out");  name = "number_particles_out"
    case ("n_flv");  name = "number_flavor_states"
    case ("n_hel");  name = "number_spin_states"
    case ("n_col");  name = "number_color_flows"
    case ("n_cin");  name = "number_color_indices"
    case ("n_cf");   name = "number_color_factors"
    case ("flv_state");  name = "flavor_states"
    case ("hel_state");  name = "spin_states"
    case ("col_state");  name = "color_flows"
    case default
       name = feature
    end select
  end function template_me_writer_get_procname

@ %def template_me_writer_get_procname
@ The interfaces for the template-specific features.
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: write_interface => template_me_write_interface
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_write_interface (writer, unit, id, feature)
      class(template_me_writer_t), intent(in) :: writer
      integer, intent(in) :: unit
      type(string_t), intent(in) :: id
      type(string_t), intent(in) :: feature
    end subroutine template_me_write_interface
<<Template matrix elements: procedures>>=
  module subroutine template_me_write_interface (writer, unit, id, feature)
    class(template_me_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(string_t), intent(in) :: feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, "(2x,9A)")  "interface"
    select case (char (feature))
    case ("init")
       write (unit, "(5x,9A)")  "subroutine ", char (name), &
            " (par, scheme) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: scheme"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: alpha_s"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, flag) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "logical(c_bool), intent(out) :: flag"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(0:3,*), &
            &intent(in) :: p"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, amp) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    end select
    write (unit, "(2x,9A)")  "end interface"
  end subroutine template_me_write_interface

@ %def template_me_write_interface
@ The wrappers have to take into account conversion between C and
Fortran data types.

NOTE: The case [[c_default_float]] $\neq$ [[default]] is not yet covered.
<<Template matrix elements: template ME writer: TBP>>=
  procedure :: write_wrapper => template_me_write_wrapper
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_write_wrapper (writer, unit, id, feature)
      class(template_me_writer_t), intent(in) :: writer
      integer, intent(in) :: unit
      type(string_t), intent(in) :: id, feature
    end subroutine template_me_write_wrapper
<<Template matrix elements: procedures>>=
  module subroutine template_me_write_wrapper (writer, unit, id, feature)
    class(template_me_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id, feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, *)
    select case (char (feature))
    case ("init")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (par, scheme) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use tpr_", char (id)
       write (unit, "(2x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: scheme"
       if (c_default_float == default .and. c_int == kind(1)) then
          write (unit, "(2x,9A)")  "call ", char (feature), " (par, scheme)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use tpr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: alpha_s"
          write (unit, "(2x,9A)")  "call ", char (feature), " (alpha_s)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, flag) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use tpr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "logical(c_bool), intent(out) :: flag"
       write (unit, "(2x,9A)")  "flag = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use tpr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), dimension(0:3,*), &
               &intent(in) :: p"
          write (unit, "(2x,9A)")  "call ", char (feature), " (p)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, amp) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use tpr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"
       write (unit, "(2x,9A)")  "amp = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    end select
  end subroutine template_me_write_wrapper

@ %def template_me_write_wrapper
@
\subsection{Driver}
<<Template matrix elements: public>>=
  public :: template_me_driver_t
<<Template matrix elements: types>>=
  type, extends (prc_core_driver_t) :: template_me_driver_t
     procedure(init_t), nopass, pointer :: &
          init => null ()
     procedure(update_alpha_s_t), nopass, pointer :: &
          update_alpha_s => null ()
     procedure(is_allowed_t), nopass, pointer :: &
          is_allowed => null ()
     procedure(new_event_t), nopass, pointer :: &
          new_event => null ()
     procedure(get_amplitude_t), nopass, pointer :: &
          get_amplitude => null ()
   contains
   <<Template matrix elements: template ME driver: TBP>>
  end type template_me_driver_t

@ %def template_me_driver_t
@ The reported type is the same as for the [[template_me_def_t]] type.
<<Template matrix elements: template ME driver: TBP>>=
  procedure, nopass :: type_name => template_me_driver_type_name
<<Template matrix elements: sub interfaces>>=
    module function template_me_driver_type_name () result (string)
      type(string_t) :: string
    end function template_me_driver_type_name
<<Template matrix elements: procedures>>=
  module function template_me_driver_type_name () result (string)
    type(string_t) :: string
    string = "template"
  end function template_me_driver_type_name

@ %def template_me_driver_type_name
@
\subsection{High-level process definition}
This procedure wraps the details filling a process-component
definition entry as appropriate for an template matrix element.
Gfortran 7/8/9 bug, remains in main module.
<<Template matrix elements: public>>=
  public :: template_me_make_process_component
<<Template matrix elements: main procedures>>=
  subroutine template_me_make_process_component (entry, component_index, &
         model, model_name, prt_in, prt_out, unity)
    class(process_def_entry_t), intent(inout) :: entry
    integer, intent(in) :: component_index
    type(string_t), intent(in) :: model_name
    class(model_data_t), intent(in), target :: model
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    logical, intent(in) :: unity
    class(prc_core_def_t), allocatable :: def
    allocate (template_me_def_t :: def)
    select type (def)
    type is (template_me_def_t)
       call def%init (model, prt_in, prt_out, unity)
    end select
    call entry%import_component (component_index, &
         n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method = var_str ("template"), &
         variant = def)
  end subroutine template_me_make_process_component

@ %def template_me_make_process_component
@
\subsection{The [[prc_template_me_t]] wrapper}
This is an instance of the generic [[prc_core_t]] object.  It contains a
pointer to the process definition ([[template_me_def_t]]), a data component
([[process_constants_t]]), and the matrix-element driver
([[template_me_driver_t]]).
<<Template matrix elements: public>>=
  public :: prc_template_me_t
<<Template matrix elements: types>>=
  type, extends (prc_core_t) :: prc_template_me_t
     real(default), dimension(:), allocatable :: par
     integer :: scheme = 0
   contains
   <<Template matrix elements: prc template ME: TBP>>
  end type prc_template_me_t

@ %def prc_template_me_t
@ The workspace associated to a [[prc_template_me_t]] object contains a single flag.
The flag is used to suppress re-evaluating the matrix element for each
quantum-number combination, after the first amplitude belonging to a given
kinematics has been computed.

We can also store the value of a running coupling once it has been calculated
for an event.  The default value is negative, which indicates an undefined
value in this context.
<<Template matrix elements: types>>=
  type, extends (prc_core_state_t) :: template_me_state_t
     logical :: new_kinematics = .true.
     real(default) :: alpha_qcd = -1
     real(default) :: alpha_qed = -1
   contains
     procedure :: write => template_me_state_write
     procedure :: reset_new_kinematics => template_me_state_reset_new_kinematics
  end type template_me_state_t

@ %def template_me_state_t
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_state_write (object, unit)
      class(template_me_state_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine template_me_state_write  
<<Template matrix elements: procedures>>=
  module subroutine template_me_state_write (object, unit)
    class(template_me_state_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A,L1)")  "Template ME state: new kinematics = ", &
         object%new_kinematics
  end subroutine template_me_state_write

@ %def template_me_state_write
@
<<Template matrix elements: sub interfaces>>=
    module subroutine template_me_state_reset_new_kinematics (object)
      class(template_me_state_t), intent(inout) :: object
    end subroutine template_me_state_reset_new_kinematics
<<Template matrix elements: procedures>>=
  module subroutine template_me_state_reset_new_kinematics (object)
    class(template_me_state_t), intent(inout) :: object
  end subroutine template_me_state_reset_new_kinematics

@
@ Allocate the workspace with the above specific type. 
Gfortran 7/8/9 bug, has to remain in the main module.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: allocate_workspace => prc_template_me_allocate_workspace
<<Template matrix elements: main procedures>>=
  subroutine prc_template_me_allocate_workspace (object, core_state)
    class(prc_template_me_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    allocate (template_me_state_t :: core_state)
  end subroutine prc_template_me_allocate_workspace

@ %def prc_template_me_allocate_workspace
@ The following procedures are inherited from the base type as deferred, thus
must be implemented.  The corresponding unit tests are skipped here; the
procedures are tested when called from the [[processes]] module.

Output: print just the ID of the associated matrix element.  Then display any
stored parameters.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: write => prc_template_me_write
<<Template matrix elements: sub interfaces>>=
    module subroutine prc_template_me_write (object, unit)
      class(prc_template_me_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine prc_template_me_write
<<Template matrix elements: procedures>>=
  module subroutine prc_template_me_write (object, unit)
    class(prc_template_me_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(3x,A)", advance="no")  "Template process core:"
    if (object%data_known) then
       write (u, "(1x,A)")  char (object%data%id)
    else
       write (u, "(1x,A)")  "[undefined]"
    end if
    if (allocated (object%par)) then
       write (u, "(3x,A)")  "Parameter array:"
       do i = 1, size (object%par)
          write (u, "(5x,I0,1x,ES17.10)")  i, object%par(i)
       end do
    end if
  end subroutine prc_template_me_write

@ %def prc_template_me_write
@
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: write_name => prc_template_me_write_name
<<Template matrix elements: sub interfaces>>=
    module subroutine prc_template_me_write_name (object, unit)
      class(prc_template_me_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine prc_template_me_write_name
<<Template matrix elements: procedures>>=
  module subroutine prc_template_me_write_name (object, unit)
    class(prc_template_me_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u,"(1x,A)") "Core: template"
  end subroutine prc_template_me_write_name

@ %def prc_template_me_write_name
@ Temporarily store the parameter array inside the [[prc_template_me]]
object, so we can use it later during the actual initialization.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: set_parameters => prc_template_me_set_parameters
<<Template matrix elements: sub interfaces>>=
    module subroutine prc_template_me_set_parameters (prc_template_me, model)
      class(prc_template_me_t), intent(inout) :: prc_template_me
      class(model_data_t), intent(in), target, optional :: model
    end subroutine prc_template_me_set_parameters
<<Template matrix elements: procedures>>=
  module subroutine prc_template_me_set_parameters (prc_template_me, model)
    class(prc_template_me_t), intent(inout) :: prc_template_me
    class(model_data_t), intent(in), target, optional :: model
    if (present (model)) then
       if (.not. allocated (prc_template_me%par)) &
            allocate (prc_template_me%par (model%get_n_real ()))
       call model%real_parameters_to_array (prc_template_me%par)
       prc_template_me%scheme = model%get_scheme_num ()
    end if
  end subroutine prc_template_me_set_parameters

@ %def prc_template_me_set_parameters
@ To fully initialize the process core, we perform base
initialization, then initialize the external matrix element code.

This procedure overrides the [[init]] method of the base type, which
we nevertheless can access via its binding [[base_init]].  When done, we
have an allocated driver.  The driver will call the [[init]] procedure
for the external matrix element, and thus transfer the parameter set to
where it finally belongs.

<<Template matrix elements: prc template ME: TBP>>=
  procedure :: init => prc_template_me_init
<<Template matrix elements: sub interfaces>>=
    module subroutine prc_template_me_init (object, def, lib, id, i_component)
      class(prc_template_me_t), intent(inout) :: object
      class(prc_core_def_t), intent(in), target :: def
      type(process_library_t), intent(in), target :: lib
      type(string_t), intent(in) :: id
      integer, intent(in) :: i_component
    end subroutine prc_template_me_init
<<Template matrix elements: procedures>>=
  module subroutine prc_template_me_init (object, def, lib, id, i_component)
    class(prc_template_me_t), intent(inout) :: object
    class(prc_core_def_t), intent(in), target :: def
    type(process_library_t), intent(in), target :: lib
    type(string_t), intent(in) :: id
    integer, intent(in) :: i_component
    call object%base_init (def, lib, id, i_component)
    call object%activate_parameters ()
  end subroutine prc_template_me_init

@ %def prc_template_me_init
@ Activate the stored parameters by transferring them to the external
matrix element.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: activate_parameters => prc_template_me_activate_parameters
<<Template matrix elements: sub interfaces>>=
    module subroutine prc_template_me_activate_parameters (object)
      class (prc_template_me_t), intent(inout) :: object
    end subroutine prc_template_me_activate_parameters
<<Template matrix elements: procedures>>=
  module subroutine prc_template_me_activate_parameters (object)
    class (prc_template_me_t), intent(inout) :: object
    if (allocated (object%driver)) then
       if (allocated (object%par)) then
          select type (driver => object%driver)
          type is (template_me_driver_t)
             if (associated (driver%init)) then
                call driver%init (object%par, object%scheme)
             end if
          end select
       else
          call msg_bug ("prc_template_me_activate: parameter set is not allocated")
       end if
    else
       call msg_bug ("prc_template_me_activate: driver is not allocated")
    end if
  end subroutine prc_template_me_activate_parameters

@ %def prc_template_me_activate_parameters
@ Tell whether a particular combination of flavor, helicity, color is
allowed.  Here we have to consult the matrix-element driver.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: is_allowed => prc_template_me_is_allowed
<<Template matrix elements: sub interfaces>>=
    module function prc_template_me_is_allowed &
        (object, i_term, f, h, c) result (flag)
      class(prc_template_me_t), intent(in) :: object
      integer, intent(in) :: i_term, f, h, c
      logical :: flag
    end function prc_template_me_is_allowed
<<Template matrix elements: procedures>>=
  module function prc_template_me_is_allowed &
      (object, i_term, f, h, c) result (flag)
    class(prc_template_me_t), intent(in) :: object
    integer, intent(in) :: i_term, f, h, c
    logical :: flag
    logical(c_bool) :: cflag
    select type (driver => object%driver)
    type is (template_me_driver_t)
       call driver%is_allowed (f, h, c, cflag)
       flag = cflag
    end select
  end function prc_template_me_is_allowed

@ %def prc_template_me_is_allowed
@ Transfer the generated momenta directly to the hard interaction in
the (only) term.  We assume that everything has been set up correctly,
so the array fits.

%We reset the [[new_kinematics]] flag, so that the next call to
%[[compute_amplitude]] will evaluate the matrix element.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: compute_hard_kinematics => &
       prc_template_me_compute_hard_kinematics
<<Template matrix elements: sub interfaces>>=
    module subroutine prc_template_me_compute_hard_kinematics &
         (object, p_seed, i_term, int_hard, core_state)
      class(prc_template_me_t), intent(in) :: object
      type(vector4_t), dimension(:), intent(in) :: p_seed
      integer, intent(in) :: i_term
      type(interaction_t), intent(inout) :: int_hard
      class(prc_core_state_t), intent(inout), allocatable :: core_state
    end subroutine prc_template_me_compute_hard_kinematics
<<Template matrix elements: procedures>>=
  module subroutine prc_template_me_compute_hard_kinematics &
       (object, p_seed, i_term, int_hard, core_state)
    class(prc_template_me_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p_seed
    integer, intent(in) :: i_term
    type(interaction_t), intent(inout) :: int_hard
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    call int_hard%set_momenta (p_seed)
  end subroutine prc_template_me_compute_hard_kinematics

@ %def prc_template_me_compute_hard_kinematics
@ This procedure is not called for [[prc_template_me_t]], just a placeholder.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: compute_eff_kinematics => &
       prc_template_me_compute_eff_kinematics
<<Template matrix elements: sub interfaces>>=
    module subroutine prc_template_me_compute_eff_kinematics &
         (object, i_term, int_hard, int_eff, core_state)
      class(prc_template_me_t), intent(in) :: object
      integer, intent(in) :: i_term
      type(interaction_t), intent(in) :: int_hard
      type(interaction_t), intent(inout) :: int_eff
      class(prc_core_state_t), intent(inout), allocatable :: core_state
    end subroutine prc_template_me_compute_eff_kinematics
<<Template matrix elements: procedures>>=
  module subroutine prc_template_me_compute_eff_kinematics &
       (object, i_term, int_hard, int_eff, core_state)
    class(prc_template_me_t), intent(in) :: object
    integer, intent(in) :: i_term
    type(interaction_t), intent(in) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
  end subroutine prc_template_me_compute_eff_kinematics

@ %def prc_template_me_compute_eff_kinematics
@ Compute the amplitude.  For the tree-level process, we can ignore the scale
settings.  The term index [[j]] is also irrelevant.

We first call [[new_event]] for the given momenta (which we must unpack), then
retrieve the amplitude value for the given quantum numbers.

If the [[core_state]] status flag is present, we can make sure that we call
[[new_event]] only once for a given kinematics.  After the first call, we
unset the [[new_kinematics]] flag.
<<Template matrix elements: prc template ME: TBP>>=
  procedure :: compute_amplitude => prc_template_me_compute_amplitude
<<Template matrix elements: sub interfaces>>=
    module function prc_template_me_compute_amplitude &
         (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
         core_state)  result (amp)
      class(prc_template_me_t), intent(in) :: object
      integer, intent(in) :: j
      type(vector4_t), dimension(:), intent(in) :: p
      integer, intent(in) :: f, h, c
      real(default), intent(in) :: fac_scale, ren_scale
      real(default), intent(in), allocatable :: alpha_qcd_forced
      class(prc_core_state_t), intent(inout), allocatable, optional :: &
           core_state
      complex(default) :: amp
    end function prc_template_me_compute_amplitude
<<Template matrix elements: procedures>>=
  module function prc_template_me_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
       core_state)  result (amp)
    class(prc_template_me_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: core_state
    complex(default) :: amp
    integer :: n_tot, i
    real(c_default_float), dimension(:,:), allocatable :: parray
    complex(c_default_complex) :: camp
    logical :: new_event
    select type (driver => object%driver)
    type is (template_me_driver_t)
       new_event = .true.
       if (present (core_state)) then
          if (allocated (core_state)) then
             select type (core_state)
             type is (template_me_state_t)
                new_event = core_state%new_kinematics
                core_state%new_kinematics = .false.
             end select
          end if
       end if
       if (new_event) then
          n_tot = object%data%n_in + object%data%n_out
          allocate (parray (0:3, n_tot))
          forall (i = 1:n_tot)  parray(:,i) = vector4_get_components (p(i))
          call driver%new_event (parray)
       end if
       if (object%is_allowed (1, f, h, c)) then
          call driver%get_amplitude &
               (int (f, c_int), int (h, c_int), int (c, c_int), camp)
          amp = camp
       else
          amp = 0
       end if
    end select
  end function prc_template_me_compute_amplitude

@ %def prc_template_me_compute_amplitude
@ We do not overwrite the [[prc_core_t]] routine for $\alpha_s$.

\subsection{Unit Test}
Test module, followed by the corresponding implementation module.
<<[[prc_template_me_ut.f90]]>>=
<<File header>>

module prc_template_me_ut
  use unit_tests
  use prc_template_me_uti

<<Standard module head>>

<<Template matrix elements: public test>>

contains

<<Template matrix elements: test driver>>

end module prc_template_me_ut
@ %def prc_template_me_ut
@
<<[[prc_template_me_uti.f90]]>>=
<<File header>>

module prc_template_me_uti

  use, intrinsic :: iso_c_binding !NODEP!

  use kinds
<<Use strings>>
  use os_interface
  use particle_specifiers, only: new_prt_spec
  use model_data
  use prc_core_def
  use process_constants
  use process_libraries
  use model_testbed, only: prepare_model, cleanup_model

  use prc_template_me

<<Standard module head>>

<<Template matrix elements: test declarations>>

contains

<<Template matrix elements: tests>>

end module prc_template_me_uti
@ %def prc_template_me_ut
@ API: driver for the unit tests below.
<<Template matrix elements: public test>>=
  public :: prc_template_me_test
<<Template matrix elements: test driver>>=
  subroutine prc_template_me_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Template matrix elements: execute tests>>
end subroutine prc_template_me_test

@ %def prc_template_me_test
@
\subsubsection{Generate, compile and load a simple process matrix element}
The process is $e^+ e^- \to \mu^+\mu^-$ for vanishing masses and
$e=0.3$.  We initialize the process, build the library, and compute a
particular matrix element for momenta of unit energy and right-angle
scattering.  The matrix element, as it happens, is equal to $e^2$.
(Note that are no conversion factors applied, so this result is
exact.)

For [[GNU make]], [[makeflags]] is set to [[-j1]].  This eliminates a
potential clash with a [[-j<n>]] flag if this test is called from a
parallel make.
<<Template matrix elements: execute tests>>=
  call test (prc_template_me_1, "prc_template_me_1", &
       "build and load simple template process", &
       u, results)
<<Template matrix elements: test declarations>>=
  public :: prc_template_me_1
<<Template matrix elements: tests>>=
  subroutine prc_template_me_1 (u)
    integer, intent(in) :: u
    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(string_t) :: model_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    integer, parameter :: cdf = c_default_float
    integer, parameter :: ci = c_int
    real(cdf), dimension(4) :: par
    real(cdf), dimension(0:3,4) :: p
    logical(c_bool) :: flag
    complex(c_default_complex) :: amp
    integer :: i

    write (u, "(A)")  "* Test output: prc_template_me_1"
    write (u, "(A)")  "*   Purpose: create a template matrix element,"
    write (u, "(A)")  "*            normalized to give unit integral,"
    write (u, "(A)")  "*            build a library, link, load, and &
         &access the matrix element"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with one entry"
    write (u, "(A)")
    call lib%init (var_str ("template_me1"))
    call os_data%init ()

    model_name = "QED"
    model => null ()
    call prepare_model (model, model_name)

    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("m+"), var_str ("m-")]

    allocate (template_me_def_t :: def)
    select type (def)
    type is (template_me_def_t)
       call def%init (model, prt_in, prt_out, unity = .false.)
    end select
    allocate (entry)
    call entry%init (var_str ("template_me1_a"), model_name = model_name, &
         n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("template"), &
         variant = def)
    call lib%append (entry)

    write (u, "(A)")  "* Configure library"
    write (u, "(A)")
    call lib%configure (os_data)

    write (u, "(A)")  "* Write makefile"
    write (u, "(A)")
    call lib%write_makefile (os_data, force = .true., verbose = .false.)

    write (u, "(A)")  "* Clean any left-over files"
    write (u, "(A)")
    call lib%clean (os_data, distclean = .false.)

    write (u, "(A)")  "* Write driver"
    write (u, "(A)")
    call lib%write_driver (force = .true.)

    write (u, "(A)")  "* Write process source code, compile, link, load"
    write (u, "(A)")
    call lib%load (os_data)

    call lib%write (u, libpath = .false.)

    write (u, "(A)")
    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")

    write (u, "(1x,A,L1)")  "is active                 = ", &
         lib%is_active ()
    write (u, "(1x,A,I0)")  "n_processes               = ", &
         lib%get_n_processes ()

    write (u, "(A)")
    write (u, "(A)")  "* Constants of template_me1_a_i1:"
    write (u, "(A)")

    call lib%connect_process (var_str ("template_me1_a"), 1, data, driver)

    write (u, "(1x,A,A)")  "component ID     = ", char (data%id)
    write (u, "(1x,A,A)")  "model name       = ", char (data%model_name)
    write (u, "(1x,A,A,A)")  "md5sum           = '", data%md5sum, "'"
    write (u, "(1x,A,I0)") "n_in  = ", data%n_in
    write (u, "(1x,A,I0)") "n_out = ", data%n_out
    write (u, "(1x,A,I0)") "n_flv = ", data%n_flv
    write (u, "(1x,A,I0)") "n_hel = ", data%n_hel
    write (u, "(1x,A,I0)") "n_col = ", data%n_col
    write (u, "(1x,A,I0)") "n_cin = ", data%n_cin
    write (u, "(1x,A,I0)") "n_cf  = ", data%n_cf
    write (u, "(1x,A,10(1x,I0))") "flv state =", data%flv_state
    write (u, "(1x,A,10(1x,I2))") "hel state =", data%hel_state(:,1)
    do i = 2, 16
       write (u, "(12x,4(1x,I2))")  data%hel_state(:,i)
    end do
    write (u, "(1x,A,10(1x,I0))") "col state =", data%col_state
    write (u, "(1x,A,10(1x,L1))") "ghost flag =", data%ghost_flag
    write (u, "(1x,A,10(1x,F5.3))") "color factors =", data%color_factors
    write (u, "(1x,A,10(1x,I0))") "cf index =", data%cf_index

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters for template_me1_a and initialize:"
    write (u, "(A)")

    par = [0.3_cdf, 0.0_cdf, 0.0_cdf, 0.0_cdf]
    write (u, "(2x,A,F6.4)")  "ee   = ", par(1)
    write (u, "(2x,A,F6.4)")  "me   = ", par(2)
    write (u, "(2x,A,F6.4)")  "mmu  = ", par(3)
    write (u, "(2x,A,F6.4)")  "mtau = ", par(4)

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")

    p = reshape ([ &
         1.0_cdf, 0.0_cdf, 0.0_cdf, 1.0_cdf, &
         1.0_cdf, 0.0_cdf, 0.0_cdf,-1.0_cdf, &
         1.0_cdf, 1.0_cdf, 0.0_cdf, 0.0_cdf, &
         1.0_cdf,-1.0_cdf, 0.0_cdf, 0.0_cdf &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.4))")  "p", i, " =", p(:,i)
    end do

    select type (driver)
    type is (template_me_driver_t)
       call driver%init (par, 0)

       call driver%new_event (p)

       write (u, "(A)")
       write (u, "(A)")  "* Compute matrix element:"
       write (u, "(A)")

       call driver%is_allowed (1_ci, 6_ci, 1_ci, flag)
       write (u, "(1x,A,L1)") "is_allowed (1, 6, 1) = ", flag

       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)
    end select

    call lib%final ()
    call cleanup_model (model)
    deallocate (model)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_template_me_1"

  end subroutine prc_template_me_1

@ %def prc_template_me_1
@
<<Template matrix elements: execute tests>>=
  call test (prc_template_me_2, "prc_template_me_2", &
       "build and load simple template_unity process", &
       u, results)
<<Template matrix elements: test declarations>>=
  public :: prc_template_me_2
<<Template matrix elements: tests>>=
  subroutine prc_template_me_2 (u)
    integer, intent(in) :: u
    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(string_t) :: model_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    integer, parameter :: cdf = c_default_float
    integer, parameter :: ci = c_int
    real(cdf), dimension(4) :: par
    real(cdf), dimension(0:3,4) :: p
    logical(c_bool) :: flag
    complex(c_default_complex) :: amp
    integer :: i

    write (u, "(A)")  "* Test output: prc_template_me_1"
    write (u, "(A)")  "*   Purpose: create a template matrix element,"
    write (u, "(A)")  "*            being identical to unity,"
    write (u, "(A)")  "*            build a library, link, load, and &
         &access the matrix element"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with one entry"
    write (u, "(A)")
    call lib%init (var_str ("template_me2"))
    call os_data%init ()

    model_name = "QED"
    model => null ()
    call prepare_model (model, model_name)

    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("m+"), var_str ("m-")]

    allocate (template_me_def_t :: def)
    select type (def)
    type is (template_me_def_t)
       call def%init (model, prt_in, prt_out, unity = .true.)
    end select
    allocate (entry)
    call entry%init (var_str ("template_me2_a"), model_name = model_name, &
         n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("template_unity"), &
         variant = def)
    call lib%append (entry)

    write (u, "(A)")  "* Configure library"
    write (u, "(A)")
    call lib%configure (os_data)

    write (u, "(A)")  "* Write makefile"
    write (u, "(A)")
    call lib%write_makefile (os_data, force = .true., verbose = .false.)

    write (u, "(A)")  "* Clean any left-over files"
    write (u, "(A)")
    call lib%clean (os_data, distclean = .false.)

    write (u, "(A)")  "* Write driver"
    write (u, "(A)")
    call lib%write_driver (force = .true.)

    write (u, "(A)")  "* Write process source code, compile, link, load"
    write (u, "(A)")
    call lib%load (os_data)

    call lib%write (u, libpath = .false.)

    write (u, "(A)")
    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")

    write (u, "(1x,A,L1)")  "is active                 = ", &
         lib%is_active ()
    write (u, "(1x,A,I0)")  "n_processes               = ", &
         lib%get_n_processes ()

    write (u, "(A)")
    write (u, "(A)")  "* Constants of template_me2_a_i1:"
    write (u, "(A)")

    call lib%connect_process (var_str ("template_me2_a"), 1, data, driver)

    write (u, "(1x,A,A)")  "component ID     = ", char (data%id)
    write (u, "(1x,A,A)")  "model name       = ", char (data%model_name)
    write (u, "(1x,A,A,A)")  "md5sum           = '", data%md5sum, "'"
    write (u, "(1x,A,I0)") "n_in  = ", data%n_in
    write (u, "(1x,A,I0)") "n_out = ", data%n_out
    write (u, "(1x,A,I0)") "n_flv = ", data%n_flv
    write (u, "(1x,A,I0)") "n_hel = ", data%n_hel
    write (u, "(1x,A,I0)") "n_col = ", data%n_col
    write (u, "(1x,A,I0)") "n_cin = ", data%n_cin
    write (u, "(1x,A,I0)") "n_cf  = ", data%n_cf
    write (u, "(1x,A,10(1x,I0))") "flv state =", data%flv_state
    write (u, "(1x,A,10(1x,I2))") "hel state =", data%hel_state(:,1)
    do i = 2, 16
       write (u, "(12x,4(1x,I2))")  data%hel_state(:,i)
    end do
    write (u, "(1x,A,10(1x,I0))") "col state =", data%col_state
    write (u, "(1x,A,10(1x,L1))") "ghost flag =", data%ghost_flag
    write (u, "(1x,A,10(1x,F5.3))") "color factors =", data%color_factors
    write (u, "(1x,A,10(1x,I0))") "cf index =", data%cf_index

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters for template_me2_a and initialize:"
    write (u, "(A)")

    par = [0.3_cdf, 0.0_cdf, 0.0_cdf, 0.0_cdf]
    write (u, "(2x,A,F6.4)")  "ee   = ", par(1)
    write (u, "(2x,A,F6.4)")  "me   = ", par(2)
    write (u, "(2x,A,F6.4)")  "mmu  = ", par(3)
    write (u, "(2x,A,F6.4)")  "mtau = ", par(4)

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")

    p = reshape ([ &
         1.0_cdf, 0.0_cdf, 0.0_cdf, 1.0_cdf, &
         1.0_cdf, 0.0_cdf, 0.0_cdf,-1.0_cdf, &
         1.0_cdf, 1.0_cdf, 0.0_cdf, 0.0_cdf, &
         1.0_cdf,-1.0_cdf, 0.0_cdf, 0.0_cdf &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.4))")  "p", i, " =", p(:,i)
    end do

    select type (driver)
    type is (template_me_driver_t)
       call driver%init (par, 0)

       call driver%new_event (p)

       write (u, "(A)")
       write (u, "(A)")  "* Compute matrix element:"
       write (u, "(A)")

       call driver%is_allowed (1_ci, 6_ci, 1_ci, flag)
       write (u, "(1x,A,L1)") "is_allowed (1, 6, 1) = ", flag

       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)
    end select

    call lib%final ()
    call cleanup_model (model)
    deallocate (model)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_template_me_2"

  end subroutine prc_template_me_2

@ %def prc_template_me_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\oMega\ Interface}

The standard method for process computation with \whizard\ is the
\oMega\ matrix element generator.

This section implements the interface to the code generator (via
the makefile) and the driver for the features provided by the \oMega\
matrix element.

There are actually two different methods steered by this interface, the
traditional one which delivers compiled Fortran code, while the \oMega\
virtual machine (OVM) produces bytecode with look-up tables.
<<[[prc_omega.f90]]>>=
<<File header>>

module prc_omega

  use, intrinsic :: iso_c_binding !NODEP!

  use kinds
<<Use strings>>
  use constants, only: one
  use os_interface
  use diagnostics
  use lorentz
  use sm_qcd
  use sm_qed
  use interactions
  use model_data

  use particle_specifiers, only: new_prt_spec
  use process_constants
  use prclib_interfaces
  use prc_core_def
  use process_libraries
  use prc_core

<<Standard module head>>

<<Omega interface: public>>

<<Omega interface: types>>

<<Omega interface: interfaces>>

  interface
<<Omega interface: sub interfaces>>
  end interface

contains

<<Omega interface: main procedures>>

end module prc_omega
@ %def prc_omega
@
<<[[prc_omega_sub.f90]]>>=
<<File header>>

submodule (prc_omega) prc_omega_s

  use io_units
  use system_defs, only: TAB

  implicit none

contains

<<Omega interface: procedures>>

end submodule prc_omega_s

@ %def prc_omega_s
@
\subsection{Process definition}
For the process definition we implement an extension of the
[[prc_core_def_t]] abstract type.
<<Omega interface: public>>=
  public :: omega_def_t
<<Omega interface: types>>=
  type, extends (prc_core_def_t) :: omega_def_t
     logical :: ufo = .false.
     logical :: ovm = .false.
   contains
   <<Omega interface: omega def: TBP>>
  end type omega_def_t

@ %def omega_def_t
@
<<Omega interface: omega def: TBP>>=
  procedure, nopass :: type_string => omega_def_type_string
<<Omega interface: sub interfaces>>=
    module function omega_def_type_string () result (string)
      type(string_t) :: string
    end function omega_def_type_string
<<Omega interface: procedures>>=
  module function omega_def_type_string () result (string)
    type(string_t) :: string
    string = "omega"
  end function omega_def_type_string

@ %def omega_omega_def_type_string
@
Initialization: allocate the writer for the \oMega\ matrix element.
The writer type depends on the settings of the [[ufo]] and [[ovm]] flags.
Also set any data for this process that the writer needs.
Gfortran 7/8/9 bug, has to remain in the main module.
<<Omega interface: omega def: TBP>>=
  procedure :: init => omega_def_init
<<Omega interface: main procedures>>=
  subroutine omega_def_init (object, &
       model_name, prt_in, prt_out, &
       ovm, ufo, ufo_path, &
       restrictions, cms_scheme, &
       openmp_support, report_progress, write_phs_output, extra_options, diags, diags_color)
    class(omega_def_t), intent(out) :: object
    type(string_t), intent(in) :: model_name
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    logical, intent(in) :: ovm
    logical, intent(in) :: ufo
    type(string_t), intent(in), optional :: ufo_path
    type(string_t), intent(in), optional :: restrictions
    logical, intent(in), optional :: cms_scheme
    logical, intent(in), optional :: openmp_support
    logical, intent(in), optional :: report_progress
    logical, intent(in), optional :: write_phs_output
    type(string_t), intent(in), optional :: extra_options
    logical, intent(in), optional :: diags, diags_color
    object%ufo = ufo
    object%ovm = ovm
    if (object%ufo) then
       if (object%ovm) then
          call msg_fatal ("Omega process: OVM method does not support UFO model")
       else
          allocate (omega_ufo_writer_t :: object%writer)
       end if
    else
       if (object%ovm) then
          allocate (omega_ovm_writer_t :: object%writer)
       else
          allocate (omega_omega_writer_t :: object%writer)
       end if
    end if
    select type (writer => object%writer)
    class is (omega_writer_t)
       call writer%init (model_name, prt_in, prt_out, &
            ufo_path, restrictions, cms_scheme, &
            openmp_support, report_progress, write_phs_output, extra_options, diags, diags_color)
    end select
  end subroutine omega_def_init

@ %def omega_def_init
@ Write/read process- and method-specific data.
<<Omega interface: omega def: TBP>>=
  procedure :: write => omega_def_write
<<Omega interface: sub interfaces>>=
    module subroutine omega_def_write (object, unit)
      class(omega_def_t), intent(in) :: object
      integer, intent(in) :: unit
    end subroutine omega_def_write
<<Omega interface: procedures>>=
  module subroutine omega_def_write (object, unit)
    class(omega_def_t), intent(in) :: object
    integer, intent(in) :: unit
    select type (writer => object%writer)
    class is (omega_writer_t)
       call writer%write (unit)
    end select
  end subroutine omega_def_write

@ %def omega_def_write
@
<<Omega interface: omega def: TBP>>=
  procedure :: read => omega_def_read
<<Omega interface: sub interfaces>>=
    module subroutine omega_def_read (object, unit)
      class(omega_def_t), intent(out) :: object
      integer, intent(in) :: unit
    end subroutine omega_def_read
<<Omega interface: procedures>>=
  module subroutine omega_def_read (object, unit)
    class(omega_def_t), intent(out) :: object
    integer, intent(in) :: unit
    call msg_bug ("O'Mega process definition: input not supported yet")
  end subroutine omega_def_read

@ %def omega_def_read
@ Allocate the driver for \oMega matrix elements.
Gfortran 7/8/9 bug, has to remain in the main module.
<<Omega interface: omega def: TBP>>=
  procedure :: allocate_driver => omega_def_allocate_driver
<<Omega interface: main procedures>>=
  subroutine omega_def_allocate_driver (object, driver, basename)
    class(omega_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    allocate (omega_driver_t :: driver)
  end subroutine omega_def_allocate_driver

@ %def omega_def_allocate_driver
@ We need code:
<<Omega interface: omega def: TBP>>=
  procedure, nopass :: needs_code => omega_def_needs_code
<<Omega interface: sub interfaces>>=
    module function omega_def_needs_code () result (flag)
      logical :: flag
    end function omega_def_needs_code
<<Omega interface: procedures>>=
  module function omega_def_needs_code () result (flag)
    logical :: flag
    flag = .true.
  end function omega_def_needs_code

@ %def omega_def_needs_code
@ These are the features that an \oMega\ matrix element provides.
<<Omega interface: omega def: TBP>>=
  procedure, nopass :: get_features => omega_def_get_features
<<Omega interface: sub interfaces>>=
    module subroutine omega_def_get_features (features)
      type(string_t), dimension(:), allocatable, intent(out) :: features
    end subroutine omega_def_get_features
<<Omega interface: procedures>>=
  module subroutine omega_def_get_features (features)
    type(string_t), dimension(:), allocatable, intent(out) :: features
    allocate (features (6))
    features = [ &
         var_str ("init"), &
         var_str ("update_alpha_s"), &
         var_str ("reset_helicity_selection"), &
         var_str ("is_allowed"), &
         var_str ("new_event"), &
         var_str ("get_amplitude")]
  end subroutine omega_def_get_features

@ %def omega_def_get_features
@ The interface of the specific features.
<<Omega interface: interfaces>>=
  abstract interface
     subroutine init_t (par, scheme) bind(C)
       import
       real(c_default_float), dimension(*), intent(in) :: par
       integer(c_int), intent(in) :: scheme
     end subroutine init_t
  end interface

  abstract interface
     subroutine update_alpha_s_t (alpha_s) bind(C)
       import
       real(c_default_float), intent(in) :: alpha_s
     end subroutine update_alpha_s_t
  end interface

  abstract interface
     subroutine reset_helicity_selection_t (threshold, cutoff) bind(C)
       import
       real(c_default_float), intent(in) :: threshold
       integer(c_int), intent(in) :: cutoff
     end subroutine reset_helicity_selection_t
  end interface

  abstract interface
     subroutine is_allowed_t (flv, hel, col, flag) bind(C)
       import
       integer(c_int), intent(in) :: flv, hel, col
       logical(c_bool), intent(out) :: flag
     end subroutine is_allowed_t
  end interface

  abstract interface
     subroutine new_event_t (p) bind(C)
       import
       real(c_default_float), dimension(0:3,*), intent(in) :: p
     end subroutine new_event_t
  end interface

  abstract interface
     subroutine get_amplitude_t (flv, hel, col, amp) bind(C)
       import
       integer(c_int), intent(in) :: flv, hel, col
       complex(c_default_complex), intent(out):: amp
     end subroutine get_amplitude_t
  end interface

@ %def init_t update_alpha_s_t reset_helicity_selection_t
@ %def is_allowed_t new_event_t get_amplitude_t
@ Connect the \oMega\ features with the process driver.
<<Omega interface: omega def: TBP>>=
  procedure :: connect => omega_def_connect
<<Omega interface: sub interfaces>>=
    module subroutine omega_def_connect (def, lib_driver, i, proc_driver)
      class(omega_def_t), intent(in) :: def
      class(prclib_driver_t), intent(in) :: lib_driver
      integer, intent(in) :: i
      class(prc_core_driver_t), intent(inout) :: proc_driver
    end subroutine omega_def_connect
<<Omega interface: procedures>>=
  module subroutine omega_def_connect (def, lib_driver, i, proc_driver)
    class(omega_def_t), intent(in) :: def
    class(prclib_driver_t), intent(in) :: lib_driver
    integer, intent(in) :: i
    class(prc_core_driver_t), intent(inout) :: proc_driver
    integer(c_int) :: pid, fid
    type(c_funptr) :: fptr
    select type (proc_driver)
    type is  (omega_driver_t)
       pid = i
       fid = 1
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%init)
       fid = 2
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%update_alpha_s)
       fid = 3
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%reset_helicity_selection)
       fid = 4
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%is_allowed)
       fid = 5
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%new_event)
       fid = 6
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%get_amplitude)
    end select
  end subroutine omega_def_connect

@ %def omega_def_connect
@
\subsection{The \oMega\ writer}
The \oMega\ writer is responsible for inserting the appropriate lines
in the makefile that call \oMega, and for writing interfaces and
wrappers.
<<Omega interface: types>>=
  type, extends (prc_writer_f_module_t), abstract :: omega_writer_t
     type(string_t) :: model_name
     type(string_t) :: process_mode
     type(string_t) :: process_string
     type(string_t) :: restrictions
     logical :: openmp_support = .false.
     logical :: report_progress = .false.
     logical :: diags = .false.
     logical :: diags_color = .false.
     logical :: complex_mass_scheme = .false.
     logical :: write_phs_output = .false.
     type(string_t) :: extra_options
   contains
   <<Omega interface: omega writer: TBP>>
  end type omega_writer_t

@ %def omega_writer_t
@
<<Omega interface: types>>=
  type, extends (omega_writer_t) :: omega_omega_writer_t
   contains
   <<Omega interface: omega omega writer: TBP>>
  end type omega_omega_writer_t

@ %def omega_omega_writer_t
@
<<Omega interface: types>>=
  type, extends (omega_omega_writer_t) :: omega_ufo_writer_t
     type(string_t) :: ufo_path
   contains
   <<Omega interface: omega ufo writer: TBP>>
  end type omega_ufo_writer_t

@ %def omega_ufo_writer_t
@
<<Omega interface: types>>=
  type, extends (omega_writer_t) :: omega_ovm_writer_t
   contains
   <<Omega interface: omega ovm writer: TBP>>
  end type omega_ovm_writer_t

@ %def omega_ovm_writer_t
@
<<Omega interface: omega omega writer: TBP>>=
  procedure, nopass :: type_name => omega_omega_writer_type_name
<<Omega interface: sub interfaces>>=
    module function omega_omega_writer_type_name () result (string)
      type(string_t) :: string
    end function omega_omega_writer_type_name
<<Omega interface: procedures>>=
  module function omega_omega_writer_type_name () result (string)
    type(string_t) :: string
    string = "omega"
  end function omega_omega_writer_type_name

@ %def omega_omega_writer_type_name
@
<<Omega interface: omega ufo writer: TBP>>=
  procedure, nopass :: type_name => omega_ufo_writer_type_name
<<Omega interface: sub interfaces>>=
    module function omega_ufo_writer_type_name () result (string)
      type(string_t) :: string
    end function omega_ufo_writer_type_name
<<Omega interface: procedures>>=
  module function omega_ufo_writer_type_name () result (string)
    type(string_t) :: string
    string = "omega/UFO"
  end function omega_ufo_writer_type_name

@ %def omega_ufo_writer_type_name
@
<<Omega interface: omega ovm writer: TBP>>=
  procedure, nopass :: type_name => omega_ovm_writer_type_name
<<Omega interface: sub interfaces>>=
    module function omega_ovm_writer_type_name () result (string)
      type(string_t) :: string
    end function omega_ovm_writer_type_name
<<Omega interface: procedures>>=
  module function omega_ovm_writer_type_name () result (string)
    type(string_t) :: string
    string = "ovm"
  end function omega_ovm_writer_type_name

@ %def omega_ovm_writer_type_name
@
@ Taking into account the prefix for \oMega\ module names.
<<Omega interface: omega writer: TBP>>=
  procedure, nopass :: get_module_name => omega_writer_get_module_name
<<Omega interface: sub interfaces>>=
    module function omega_writer_get_module_name (id) result (name)
      type(string_t) :: name
      type(string_t), intent(in) :: id
    end function omega_writer_get_module_name
<<Omega interface: procedures>>=
  module function omega_writer_get_module_name (id) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: id
    name = "opr_" // id
  end function omega_writer_get_module_name

@ %def omega_writer_get_module_name
@ Output.  This is called by [[omega_def_write]].
<<Omega interface: omega writer: TBP>>=
  procedure :: write => omega_writer_write
<<Omega interface: sub interfaces>>=
    module subroutine omega_writer_write (object, unit)
      class(omega_writer_t), intent(in) :: object
      integer, intent(in) :: unit
    end subroutine omega_writer_write
<<Omega interface: procedures>>=
  module subroutine omega_writer_write (object, unit)
    class(omega_writer_t), intent(in) :: object
    integer, intent(in) :: unit
    write (unit, "(5x,A,A)")  "Model name        = ", &
         '"' // char (object%model_name) // '"'
    write (unit, "(5x,A,A)")  "Mode string       = ", &
         '"' // char (object%process_mode) // '"'
    write (unit, "(5x,A,A)")  "Process string    = ", &
         '"' // char (object%process_string) // '"'
    write (unit, "(5x,A,A)")  "Restrictions      = ", &
         '"' // char (object%restrictions) // '"'
    write (unit, "(5x,A,L1)")  "OpenMP support    = ", object%openmp_support
    write (unit, "(5x,A,L1)")  "Report progress   = ", object%report_progress
    ! write (unit, "(5x,A,L1)")  "Write phs output  = ", object%write_phs_output
    write (unit, "(5x,A,A)")  "Extra options     = ", &
         '"' // char (object%extra_options) // '"'
    write (unit, "(5x,A,L1)")  "Write diagrams    = ", object%diags
    write (unit, "(5x,A,L1)")  "Write color diag. = ", object%diags_color
    write (unit, "(5x,A,L1)")  "Complex Mass S.   = ", &
         object%complex_mass_scheme
  end subroutine omega_writer_write

@ %def omega_writer_write
@ Initialize with process data.
<<Omega interface: omega writer: TBP>>=
  procedure :: init => omega_writer_init
<<Omega interface: sub interfaces>>=
    module subroutine omega_writer_init (writer, model_name, prt_in, prt_out, &
         ufo_path, restrictions, cms_scheme, openmp_support, &
         report_progress, write_phs_output, extra_options, diags, diags_color)
      class(omega_writer_t), intent(out) :: writer
      type(string_t), intent(in) :: model_name
      type(string_t), dimension(:), intent(in) :: prt_in
      type(string_t), dimension(:), intent(in) :: prt_out
      type(string_t), intent(in), optional :: ufo_path
      type(string_t), intent(in), optional :: restrictions
      logical, intent(in), optional :: cms_scheme
      logical, intent(in), optional :: openmp_support
      logical, intent(in), optional :: report_progress
      logical, intent(in), optional :: write_phs_output
      type(string_t), intent(in), optional :: extra_options
      logical, intent(in), optional :: diags, diags_color
    end subroutine omega_writer_init
<<Omega interface: procedures>>=
  module subroutine omega_writer_init (writer, model_name, prt_in, prt_out, &
       ufo_path, restrictions, cms_scheme, openmp_support, &
       report_progress, write_phs_output, extra_options, diags, diags_color)
    class(omega_writer_t), intent(out) :: writer
    type(string_t), intent(in) :: model_name
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    type(string_t), intent(in), optional :: ufo_path
    type(string_t), intent(in), optional :: restrictions
    logical, intent(in), optional :: cms_scheme
    logical, intent(in), optional :: openmp_support
    logical, intent(in), optional :: report_progress
    logical, intent(in), optional :: write_phs_output
    type(string_t), intent(in), optional :: extra_options
    logical, intent(in), optional :: diags, diags_color
    integer :: i
    writer%model_name = model_name
    select type (writer)
    type is (omega_ufo_writer_t)
       if (present (ufo_path)) then
          writer%ufo_path = ufo_path
       else
          call msg_fatal ("O'Mega: UFO model option is selected, but UFO model path is unset")
       end if
    end select
    if (present (restrictions)) then
       writer%restrictions = restrictions
    else
       writer%restrictions = ""
    end if
    if (present (cms_scheme))  writer%complex_mass_scheme = cms_scheme
    if (present (openmp_support))  writer%openmp_support = openmp_support
    if (present (report_progress))  writer%report_progress = report_progress
    if (present (write_phs_output)) writer%write_phs_output = write_phs_output
    if (present (extra_options)) then
       writer%extra_options = " " // extra_options
    else
       writer%extra_options = ""
    end if
    if (present (diags))  writer%diags = diags
    if (present (diags_color))  writer%diags_color = diags_color
    select case (size (prt_in))
    case (1);  writer%process_mode = " -decay"
    case (2);  writer%process_mode = " -scatter"
    end select
    associate (s => writer%process_string)
      s = " '"
      do i = 1, size (prt_in)
         if (i > 1)  s = s // " "
         s = s // prt_in(i)
      end do
      s = s // " ->"
      do i = 1, size (prt_out)
         s = s // " " // prt_out(i)
      end do
      s = s // "'"
    end associate
  end subroutine omega_writer_init

@ %def omega_writer_init
@ The makefile implements the actual \oMega\ call. For old \LaTeX\
distributions, we filter out the hyperref options for \oMega\
diagrams, at least in the testsuite.
<<Omega interface: omega writer: TBP>>=
  procedure :: write_makefile_code => omega_write_makefile_code
<<Omega interface: sub interfaces>>=
    module subroutine omega_write_makefile_code &
         (writer, unit, id, os_data, verbose, testflag)
      class(omega_writer_t), intent(in) :: writer
      integer, intent(in) :: unit
      type(string_t), intent(in) :: id
      type(os_data_t), intent(in) :: os_data
      logical, intent(in) :: verbose
      logical, intent(in), optional :: testflag
    end subroutine omega_write_makefile_code
<<Omega interface: procedures>>=
  module subroutine omega_write_makefile_code &
       (writer, unit, id, os_data, verbose, testflag)
    class(omega_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: verbose
    logical, intent(in), optional :: testflag
    type(string_t) :: omega_binary, omega_path
    type(string_t) :: restrictions_string
    type(string_t) :: openmp_string
    type(string_t) :: kmatrix_string
    type(string_t) :: progress_string
    type(string_t) :: diagrams_string
    type(string_t) :: cms_string
    type(string_t) :: write_phs_output_string
    type(string_t) :: parameter_module
    logical :: escape_hyperref
    escape_hyperref = .false.
    if (present (testflag))  escape_hyperref = testflag
    select type (writer)
    type is (omega_omega_writer_t)
       omega_binary = "omega_" // writer%model_name // ".opt"
    type is (omega_ufo_writer_t)
       omega_binary = "omega_UFO.opt"
    type is (omega_ovm_writer_t)
       select case (char (writer%model_name))
       case ("SM", "SM_CKM", "SM_Higgs", "THDM", "THDM_CKM", &
             "HSExt", "QED", "QCD", "Zprime")
       case default
          call msg_fatal ("The model " // char (writer%model_name) &
               // " is not available for the O'Mega VM.")
       end select
       omega_binary = "omega_" // writer%model_name // "_VM.opt"
    end select
    omega_path = os_data%whizard_omega_binpath // "/" // omega_binary
    if (.not. verbose)  omega_path = "@" // omega_path
    if (writer%restrictions /= "") then
       restrictions_string = " -cascade '" // writer%restrictions // "'"
    else
       restrictions_string = ""
    end if
    if (writer%openmp_support) then
       openmp_string = " -target:openmp"
    else
       openmp_string = ""
    end if
    if (writer%report_progress) then
       progress_string = " -fusion:progress"
    else
       progress_string = ""
    end if
    if (writer%diags) then
       if (writer%diags_color) then
          diagrams_string = " -diagrams:C " // char(id) // &
               "_diags -diagrams_LaTeX"
       else
          diagrams_string = " -diagrams " // char(id) // &
               "_diags -diagrams_LaTeX"
       end if
    else
       if (writer%diags_color) then
          diagrams_string = " -diagrams:c " // char(id) // &
               "_diags -diagrams_LaTeX"
       else
          diagrams_string = ""
       end if
    end if
    if (writer%complex_mass_scheme) then
       cms_string = " -model:cms_width"
    else
       cms_string = ""
    end if
    if (writer%write_phs_output) then
       write_phs_output_string = " -phase_space " // char (id) // ".fds"
    else
       write_phs_output_string = ""
    endif
    select case (char (writer%model_name))
    case ("SM_rx", "SSC", "NoH_rx", "AltH")
       kmatrix_string = " -target:kmatrix_2_write"
    case ("SSC_2", "SSC_AltT", "SM_ul")
       kmatrix_string = " -target:kmatrix_write"
    case default
       kmatrix_string = ""
    end select
    write (unit, "(5A)")  "SOURCES += ", char (id), ".f90"
    select type (writer)
    type is (omega_ovm_writer_t)
       write (unit, "(5A)")  "SOURCES += ", char (id), ".hbc"
    end select
    if (writer%diags .or. writer%diags_color) then
       write (unit, "(5A)")  "TEX_SOURCES += ", char (id), "_diags.tex"
       if (os_data%event_analysis_pdf) then
          write (unit, "(5A)")  "TEX_OBJECTS += ", char (id), "_diags.pdf"
       else
          write (unit, "(5A)")  "TEX_OBJECTS += ", char (id), "_diags.ps"
       end if
    end if
    write (unit, "(5A)")  "OBJECTS += ", char (id), ".lo"
    select type (writer)
    type is (omega_omega_writer_t)
       write (unit, "(5A)")  char (id), ".f90:"
       if (.not. verbose) then
          write (unit, "(5A)")  TAB // '@echo  "  OMEGA     ', trim (char (id)), '.f90"'
       end if
       write (unit, "(99A)")  TAB, char (omega_path), &
            " -o ", char (id), ".f90", &
            " -target:whizard", &
            " -target:parameter_module parameters_", char (writer%model_name), &
            " -target:module opr_", char (id), &
            " -target:md5sum '", writer%md5sum, "'", &
            char (cms_string), &
            char (openmp_string), &
            char (progress_string), &
            char (kmatrix_string), &
            char (writer%process_mode), char (writer%process_string), &
            char (restrictions_string), char (diagrams_string), &
            char (writer%extra_options), char (write_phs_output_string)
    type is (omega_ufo_writer_t)
       parameter_module = char (id) // "_par_" // replace (char (writer%model_name), &
            "-", "_", every=.true.)
       write (unit, "(5A)")  char (id), ".f90: ", char (parameter_module), ".lo"
       if (.not. verbose) then
          write (unit, "(5A)")  TAB // '@echo  "  OMEGA[UFO]', trim (char (id)), '.f90"'
       end if
       write (unit, "(99A)")  TAB, char (omega_path), &
            " -o ", char (id), ".f90", &
            " -model:UFO_dir ", &
            char (writer%ufo_path), "/", char (writer%model_name), &
            " -model:exec", &
            " -target:whizard", &
            " -target:parameter_module ", char (parameter_module), &
            " -target:module opr_", char (id), &
            " -target:md5sum '", writer%md5sum, "'", &
            char (cms_string), &
            char (openmp_string), &
            char (progress_string), &
            char (kmatrix_string), &
            char (writer%process_mode), char (writer%process_string), &
            char (restrictions_string), char (diagrams_string), &
            char (writer%extra_options), char (write_phs_output_string)
       write (unit, "(5A)") "SOURCES += ", char (parameter_module), ".f90"
       write (unit, "(5A)") "OBJECTS += ", char (parameter_module), ".lo"
       write (unit, "(5A)")  char (parameter_module), ".f90:"
       write (unit, "(99A)")  TAB, char (omega_path), &
            " -model:UFO_dir ", &
            char (writer%ufo_path), "/", char (writer%model_name), &
            " -model:exec", &
            " -target:parameter_module ", char (parameter_module), &
            " -params", &
            " -o $@"
       write (unit, "(5A)")  char (parameter_module), ".lo: ", char (parameter_module), ".f90"
       if (.not. verbose) then
          write (unit, "(5A)")  TAB // '@echo  "  FC       " $@'
       end if
       write (unit, "(5A)")  TAB, "$(LTFCOMPILE) $<"
    type is (omega_ovm_writer_t)
       write (unit, "(5A)")  char (id), ".hbc:"
       write (unit, "(99A)")  TAB, char (omega_path), &
            " -o ", char (id), ".hbc", &
            char (progress_string), &
            char (cms_string), &
            char (writer%process_mode), char (writer%process_string), &
            char (restrictions_string), char (diagrams_string), &
            char (writer%extra_options), char (write_phs_output_string)
       write (unit, "(5A)")  char (id), ".f90:"
       if (.not. verbose) then
          write (unit, "(5A)")  TAB // '@echo  "  OVM       ', trim (char (id)), '.f90"'
       end if
       write (unit, "(99A)")  TAB, char (omega_path), &
            " -o ", char (id), ".f90 -params", &
            " -target:whizard ", &
            " -target:bytecode_file ", char (id), ".hbc", &
            " -target:wrapper_module opr_", char (id), &
            " -target:parameter_module_external parameters_", &
            char (writer%model_name), &
            " -target:md5sum '", writer%md5sum, "'", &
            char (openmp_string)
    end select
    if (writer%diags .or. writer%diags_color) &
       write (unit, "(5A)")  char (id), "_diags.tex: ", char (id), ".f90"
    write (unit, "(5A)")  "clean-", char (id), ":"
    if (verbose) then
       write (unit, "(5A)")  TAB, "rm -f ", char (id), ".f90"
       write (unit, "(5A)")  TAB, "rm -f opr_", char (id), ".mod"
       write (unit, "(5A)")  TAB, "rm -f ", char (id), ".lo"
    else
       write (unit, "(5A)")  TAB // '@echo  "  RM        ', &
            trim (char (id)), '.f90,.mod,.lo"'
       write (unit, "(5A)")  TAB, "@rm -f ", char (id), ".f90"
       write (unit, "(5A)")  TAB, "@rm -f opr_", char (id), ".mod"
       write (unit, "(5A)")  TAB, "@rm -f ", char (id), ".lo"
    end if
    write (unit, "(5A)")  "CLEAN_SOURCES += ", char (id), ".f90"
    select type (writer)
    type is (omega_ufo_writer_t)
       write (unit, "(5A)")  "CLEAN_SOURCES += ", char (writer%model_name), ".mdl"
       write (unit, "(5A)")  "CLEAN_SOURCES += ", char (parameter_module), ".f90"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (parameter_module), ".mod"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (parameter_module), ".lo"
    type is (omega_ovm_writer_t)
       write (unit, "(5A)")  "CLEAN_SOURCES += ", char (id), ".hbc"
    end select
    if (writer%diags .or. writer%diags_color) then
       write (unit, "(5A)")  "CLEAN_SOURCES += ", char (id), "_diags.tex"
    end if
    write (unit, "(5A)")  "CLEAN_OBJECTS += opr_", char (id), ".mod"
    write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), ".lo"
    if (writer%diags .or. writer%diags_color) then
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.aux"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.log"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.dvi"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.toc"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.out"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.[1-9]"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.[1-9][0-9]"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.[1-9][0-9][0-9]"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.t[1-9]"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.t[1-9][0-9]"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.t[1-9][0-9][0-9]"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.mp"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags-fmf.log"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.dvi"
       write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.ps"
       if (os_data%event_analysis_pdf) &
            write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_diags.pdf"
    end if
    write (unit, "(5A)")  char (id), ".lo: ", char (id), ".f90"
    write (unit, "(5A)")  TAB, "$(LTFCOMPILE) $<"
    if (writer%diags .or. writer%diags_color) then
       if (os_data%event_analysis_ps) then
          if (os_data%event_analysis_pdf) then
             write (unit, "(5A)")  char (id), "_diags.pdf: ", char (id), "_diags.tex"
          else
             write (unit, "(5A)")  char (id), "_diags.ps: ", char (id), "_diags.tex"
          end if
          if (escape_hyperref) then
             if (verbose) then
                write (unit, "(5A)")  TAB, "-cat ", char (id), "_diags.tex | \"
             else
                write (unit, "(5A)")  TAB // '@echo  "  HYPERREF  ', &
                     trim (char (id)) // '_diags.tex"'
                write (unit, "(5A)")  TAB, "@cat ", char (id), "_diags.tex | \"
             end if
             write (unit, "(5A)")  TAB, "   sed -e" // &
                  "'s/\\usepackage\[colorlinks\]{hyperref}.*/%\\usepackage" // &
                  "\[colorlinks\]{hyperref}/' > \"
             write (unit, "(5A)")  TAB, "   ", char (id), "_diags.tex.tmp"
             if (verbose) then
                write (unit, "(5A)")  TAB, "mv -f ", char (id), "_diags.tex.tmp \"
             else
                write (unit, "(5A)")  TAB, "@mv -f ", char (id), "_diags.tex.tmp \"
             end if
             write (unit, "(5A)")  TAB, "   ", char (id), "_diags.tex"
          end if
          if (verbose) then
             write (unit, "(5A)")  TAB, "-TEXINPUTS=$(TEX_FLAGS) $(LATEX) " // &
                  char (id) // "_diags.tex"
             write (unit, "(5A)")  TAB, "MPINPUTS=$(MP_FLAGS) $(MPOST) " // &
                  char (id) // "_diags-fmf.mp"
             write (unit, "(5A)")  TAB, "TEXINPUTS=$(TEX_FLAGS) $(LATEX) " // &
                  char (id) // "_diags.tex"
             write (unit, "(5A)")  TAB, "$(DVIPS) -o " // char (id) // "_diags.ps " // &
                  char (id) // "_diags.dvi"
          else
             write (unit, "(5A)")  TAB // '@echo  "  LATEX     ', &
                  trim (char (id)) // '_diags.tex"'
             write (unit, "(5A)")  TAB, "@TEXINPUTS=$(TEX_FLAGS) $(LATEX) " // &
                  char (id) // "_diags.tex > /dev/null"
             write (unit, "(5A)")  TAB // '@echo  "  METAPOST  ', &
                  trim (char (id)) // '_diags-fmf.mp"'
             write (unit, "(5A)")  TAB, "@MPINPUTS=$(MP_FLAGS) $(MPOST) " // &
                  char (id) // "_diags-fmf.mp  > /dev/null"
             write (unit, "(5A)")  TAB // '@echo  "  LATEX     ', &
                  trim (char (id)) // '_diags.tex"'
             write (unit, "(5A)")  TAB, "@TEXINPUTS=$(TEX_FLAGS) $(LATEX) " // &
                  char (id) // "_diags.tex > /dev/null"
             write (unit, "(5A)")  TAB // '@echo  "  DVIPS     ', &
                  trim (char (id)) // '_diags.dvi"'
             write (unit, "(5A)")  TAB, "@$(DVIPS) -q -o " // char (id) &
                  // "_diags.ps " // char (id) // "_diags.dvi"
          end if
          if (os_data%event_analysis_pdf) then
             if (verbose) then
                write (unit, "(5A)")  TAB, "$(PS2PDF) " // char (id) // "_diags.ps"
             else
                write (unit, "(5A)")  TAB // '@echo  "  PS2PDF    ', &
                     trim (char (id)) // '_diags.ps"'
                write (unit, "(5A)")  TAB, "@$(PS2PDF) " // char (id) // "_diags.ps"
             end if
          end if
       end if
    end if
  end subroutine omega_write_makefile_code

@ %def omega_write_makefile_code
@ The source is written by the makefile, so nothing to do here.
<<Omega interface: omega writer: TBP>>=
  procedure :: write_source_code => omega_write_source_code
<<Omega interface: sub interfaces>>=
    module subroutine omega_write_source_code (writer, id)
      class(omega_writer_t), intent(in) :: writer
      type(string_t), intent(in) :: id
    end subroutine omega_write_source_code
<<Omega interface: procedures>>=
  module subroutine omega_write_source_code (writer, id)
    class(omega_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
  end subroutine omega_write_source_code

@ %def omega_write_source_code
@ Nothing to be done here.
<<Omega interface: omega writer: TBP>>=
  procedure :: before_compile => omega_before_compile
  procedure :: after_compile => omega_after_compile
<<Omega interface: sub interfaces>>=
    module subroutine omega_before_compile (writer, id)
      class(omega_writer_t), intent(in) :: writer
      type(string_t), intent(in) :: id
    end subroutine omega_before_compile
    module subroutine omega_after_compile (writer, id)
      class(omega_writer_t), intent(in) :: writer
      type(string_t), intent(in) :: id
    end subroutine omega_after_compile
<<Omega interface: procedures>>=
  module subroutine omega_before_compile (writer, id)
    class(omega_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
  end subroutine omega_before_compile

  module subroutine omega_after_compile (writer, id)
    class(omega_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
  end subroutine omega_after_compile

@ %def omega_before_compile
@ %def omega_after_compile
@ Return the name of a procedure that implements a given feature, as
it is provided by the external matrix-element code.  \oMega\ names
some procedures differently, therefore we translate here and override
the binding of the base type.
<<Omega interface: omega writer: TBP>>=
  procedure, nopass :: get_procname => omega_writer_get_procname
<<Omega interface: sub interfaces>>=
    module function omega_writer_get_procname (feature) result (name)
      type(string_t) :: name
      type(string_t), intent(in) :: feature
    end function omega_writer_get_procname
<<Omega interface: procedures>>=
  module function omega_writer_get_procname (feature) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: feature
    select case (char (feature))
    case ("n_in");   name = "number_particles_in"
    case ("n_out");  name = "number_particles_out"
    case ("n_flv");  name = "number_flavor_states"
    case ("n_hel");  name = "number_spin_states"
    case ("n_col");  name = "number_color_flows"
    case ("n_cin");  name = "number_color_indices"
    case ("n_cf");   name = "number_color_factors"
    case ("flv_state");  name = "flavor_states"
    case ("hel_state");  name = "spin_states"
    case ("col_state");  name = "color_flows"
    case default
       name = feature
    end select
  end function omega_writer_get_procname

@ %def omega_writer_get_procname
@ The interfaces for the \oMega-specific features.
<<Omega interface: omega writer: TBP>>=
  procedure :: write_interface => omega_write_interface
<<Omega interface: sub interfaces>>=
    module subroutine omega_write_interface (writer, unit, id, feature)
      class(omega_writer_t), intent(in) :: writer
      integer, intent(in) :: unit
      type(string_t), intent(in) :: id
      type(string_t), intent(in) :: feature
    end subroutine omega_write_interface
<<Omega interface: procedures>>=
  module subroutine omega_write_interface (writer, unit, id, feature)
    class(omega_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(string_t), intent(in) :: feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, "(2x,9A)")  "interface"
    select case (char (feature))
    case ("init")
       write (unit, "(5x,9A)")  "subroutine ", char (name), &
            " (par, scheme) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: scheme"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: alpha_s"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("reset_helicity_selection")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(threshold, cutoff) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: threshold"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: cutoff"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, flag) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "logical(c_bool), intent(out) :: flag"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(0:3,*), &
            &intent(in) :: p"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, amp) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    end select
    write (unit, "(2x,9A)")  "end interface"
  end subroutine omega_write_interface

@ %def omega_write_interface
@ The wrappers have to take into account conversion between C and
Fortran data types.

NOTE: The case [[c_default_float]] $\neq$ [[default]] is not yet covered.
<<Omega interface: omega writer: TBP>>=
  procedure :: write_wrapper => omega_write_wrapper
<<Omega interface: sub interfaces>>=
    module subroutine omega_write_wrapper (writer, unit, id, feature)
      class(omega_writer_t), intent(in) :: writer
      integer, intent(in) :: unit
      type(string_t), intent(in) :: id, feature
    end subroutine omega_write_wrapper
<<Omega interface: procedures>>=
  module subroutine omega_write_wrapper (writer, unit, id, feature)
    class(omega_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id, feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, *)
    select case (char (feature))
    case ("init")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (par, scheme) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: scheme"
       if (c_default_float == default .and. c_int == kind(1)) then
          write (unit, "(2x,9A)")  "call ", char (feature), " (par, scheme)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: alpha_s"
          write (unit, "(2x,9A)")  "call ", char (feature), " (alpha_s)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("reset_helicity_selection")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (threshold, cutoff) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: threshold"
          write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: cutoff"
          write (unit, "(2x,9A)")  "call ", char (feature), &
               " (threshold, int (cutoff))"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, flag) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "logical(c_bool), intent(out) :: flag"
       write (unit, "(2x,9A)")  "flag = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), dimension(0:3,*), &
               &intent(in) :: p"
          write (unit, "(2x,9A)")  "call ", char (feature), " (p)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, amp) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"
       write (unit, "(2x,9A)")  "amp = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    end select
  end subroutine omega_write_wrapper

@ %def omega_write_wrapper
@
\subsection{Driver}
<<Omega interface: public>>=
  public :: omega_driver_t
<<Omega interface: types>>=
  type, extends (prc_core_driver_t) :: omega_driver_t
     procedure(init_t), nopass, pointer :: &
          init => null ()
     procedure(update_alpha_s_t), nopass, pointer :: &
          update_alpha_s => null ()
     procedure(reset_helicity_selection_t), nopass, pointer :: &
          reset_helicity_selection => null ()
     procedure(is_allowed_t), nopass, pointer :: &
          is_allowed => null ()
     procedure(new_event_t), nopass, pointer :: &
          new_event => null ()
     procedure(get_amplitude_t), nopass, pointer :: &
          get_amplitude => null ()
   contains
   <<Omega interface: omega driver: TBP>>
  end type omega_driver_t

@ %def omega_driver_t
@ The reported type is the same as for the [[omega_def_t]] type.
<<Omega interface: omega driver: TBP>>=
  procedure, nopass :: type_name => omega_driver_type_name
<<Omega interface: sub interfaces>>=
    module function omega_driver_type_name () result (string)
      type(string_t) :: string
    end function omega_driver_type_name
<<Omega interface: procedures>>=
  module function omega_driver_type_name () result (string)
    type(string_t) :: string
    string = "omega"
  end function omega_driver_type_name

@ %def omega_driver_type_name
@
\subsection{High-level process definition}
This procedure wraps the details filling a process-component
definition entry as appropriate for an
\oMega\ matrix element.
Gfortran 7/8/9 bug, has to remain in the main module.
<<Omega interface: public>>=
  public :: omega_make_process_component
<<Omega interface: main procedures>>=
  subroutine omega_make_process_component (entry, component_index, &
         model_name, prt_in, prt_out, &
         ufo, ufo_path, restrictions, cms_scheme, &
         openmp_support, report_progress, write_omega_output, extra_options, diags, diags_color)
    class(process_def_entry_t), intent(inout) :: entry
    integer, intent(in) :: component_index
    type(string_t), intent(in) :: model_name
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    logical, intent(in), optional :: ufo
    type(string_t), intent(in), optional :: ufo_path
    type(string_t), intent(in), optional :: restrictions
    logical, intent(in), optional :: cms_scheme
    logical, intent(in), optional :: openmp_support
    logical, intent(in), optional :: report_progress
    logical, intent(in), optional :: write_omega_output
    type(string_t), intent(in), optional :: extra_options
    logical, intent(in), optional :: diags, diags_color
    logical :: ufo_model
    class(prc_core_def_t), allocatable :: def
    ufo_model = .false.;  if (present (ufo))  ufo_model = ufo
    allocate (omega_def_t :: def)
    select type (def)
    class is (omega_def_t)
       call def%init (model_name, prt_in, prt_out, &
            .false., ufo_model, ufo_path, &
            restrictions, cms_scheme, &
            openmp_support, report_progress, write_omega_output, extra_options, diags, diags_color)
    end select
    call entry%import_component (component_index, &
         n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method = var_str ("omega"), &
         variant = def)
  end subroutine omega_make_process_component

@ %def omega_make_process_component
@
\subsection{The [[prc_omega_t]] wrapper}
This is an instance of the generic [[prc_core_t]] object.  It contains a
pointer to the process definition ([[omega_def_t]]), a data component
([[process_constants_t]]), and the matrix-element driver
([[omega_driver_t]]).
<<Omega interface: public>>=
  public :: prc_omega_t
<<Omega interface: types>>=
  type, extends (prc_core_t) :: prc_omega_t
     real(default), dimension(:), allocatable :: par
     integer :: scheme = 0
     type(helicity_selection_t) :: helicity_selection
     type(qcd_t) :: qcd
     type(qed_t) :: qed
   contains
   <<Omega interface: prc omega: TBP>>
  end type prc_omega_t

@ %def prc_omega_t
@ The workspace associated to a [[prc_omega_t]] object contains a single flag.
The flag is used to suppress re-evaluating the matrix element for each
quantum-number combination, after the first amplitude belonging to a given
kinematics has been computed.

We can also store the value of a running coupling once it has been calculated
for an event.  The default value is negative, which indicates an undefined
value in this context.
<<Omega interface: public>>=
  public :: omega_state_t
<<Omega interface: types>>=
  type, extends (prc_core_state_t) :: omega_state_t
     logical :: new_kinematics = .true.
     real(default) :: alpha_qcd = -1
     real(default) :: alpha_qed = -1
   contains
  <<Omega interface: omega state: TBP>>
  end type omega_state_t

@ %def omega_state_t
@
<<Omega interface: omega state: TBP>>=
  procedure :: write => omega_state_write
<<Omega interface: sub interfaces>>=
    module subroutine omega_state_write (object, unit)
      class(omega_state_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine omega_state_write
<<Omega interface: procedures>>=
  module subroutine omega_state_write (object, unit)
    class(omega_state_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A,L1)")  "O'Mega state: new kinematics = ", &
         object%new_kinematics
  end subroutine omega_state_write

@ %def omega_state_write
<<Omega interface: omega state: TBP>>=
  procedure :: reset_new_kinematics => omega_state_reset_new_kinematics
<<Omega interface: sub interfaces>>=
    module subroutine omega_state_reset_new_kinematics (object)
      class(omega_state_t), intent(inout) :: object
    end subroutine omega_state_reset_new_kinematics
<<Omega interface: procedures>>=
  module subroutine omega_state_reset_new_kinematics (object)
    class(omega_state_t), intent(inout) :: object
    object%new_kinematics = .true.
  end subroutine omega_state_reset_new_kinematics

@ %def omega_state_reset_new_kinematics
@ Allocate the workspace with the above specific type.
Gfortran 7/8/9 bug, has to remain in main module.
<<Omega interface: prc omega: TBP>>=
  procedure :: allocate_workspace => prc_omega_allocate_workspace
<<Omega interface: main procedures>>=
  subroutine prc_omega_allocate_workspace (object, core_state)
    class(prc_omega_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    allocate (omega_state_t :: core_state)
  end subroutine prc_omega_allocate_workspace

@ %def prc_omega_allocate_workspace
@ The following procedures are inherited from the base type as deferred, thus
must be implemented.  The corresponding unit tests are skipped here; the
procedures are tested when called from the [[processes]] module.

Output: print just the ID of the associated matrix element.  Then display any
stored parameters and the helicity selection data.  (The latter are printed
only if active.)
<<Omega interface: prc omega: TBP>>=
  procedure :: write => prc_omega_write
<<Omega interface: sub interfaces>>=
    module subroutine prc_omega_write (object, unit)
      class(prc_omega_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine prc_omega_write
<<Omega interface: procedures>>=
  module subroutine prc_omega_write (object, unit)
    class(prc_omega_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(3x,A)", advance="no")  "O'Mega process core:"
    if (object%data_known) then
       write (u, "(1x,A)")  char (object%data%id)
    else
       write (u, "(1x,A)")  "[undefined]"
    end if
    if (allocated (object%par)) then
       write (u, "(3x,A)")  "Parameter array:"
       do i = 1, size (object%par)
          write (u, "(5x,I0,1x,ES17.10)")  i, object%par(i)
       end do
    end if
    call object%helicity_selection%write (u)
    call object%qcd%write (u)
    call object%qed%write (u)
  end subroutine prc_omega_write

@ %def prc_omega_write
@
<<Omega interface: prc omega: TBP>>=
  procedure :: write_name => prc_omega_write_name
<<Omega interface: sub interfaces>>=
    module subroutine prc_omega_write_name (object, unit)
      class(prc_omega_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine prc_omega_write_name
<<Omega interface: procedures>>=
  module subroutine prc_omega_write_name (object, unit)
    class(prc_omega_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u,"(1x,A)") "Core: O'Mega"
  end subroutine prc_omega_write_name

@ %def prc_omega_write_name
@ Temporarily store the parameter array inside the [[prc_omega]]
object, so we can use it later during the actual initialization.  Also
store threshold and cutoff for helicity selection.
Gfortran 7/8/9 bug, has to remain in the main module.
<<Omega interface: prc omega: TBP>>=
  procedure :: set_parameters => prc_omega_set_parameters
<<Omega interface: main procedures>>=
  subroutine prc_omega_set_parameters (prc_omega, model, &
       helicity_selection, qcd, use_color_factors)
    class(prc_omega_t), intent(inout) :: prc_omega
    class(model_data_t), intent(in), target, optional :: model
    type(helicity_selection_t), intent(in), optional :: helicity_selection
    type(qcd_t), intent(in), optional :: qcd
    type(qed_t) :: qed
    logical, intent(in), optional :: use_color_factors
    if (present (model)) then
       if (.not. allocated (prc_omega%par)) &
            allocate (prc_omega%par (model%get_n_real ()))
       call model%real_parameters_to_array (prc_omega%par)
       prc_omega%scheme = model%get_scheme_num ()
       if (associated (model%get_par_data_ptr (var_str ('alpha_em_i')))) then
          allocate (alpha_qed_fixed_t :: qed%alpha)
          select type (alpha => qed%alpha)
          type is (alpha_qed_fixed_t)
             alpha%val = one / model%get_real (var_str ('alpha_em_i'))
          end select
       end if
       prc_omega%qed = qed
    end if
    if (present (helicity_selection)) then
       prc_omega%helicity_selection = helicity_selection
    end if
    if (present (qcd)) then
       prc_omega%qcd = qcd
    end if
    if (present (use_color_factors)) then
       prc_omega%use_color_factors = use_color_factors
    end if
  end subroutine prc_omega_set_parameters

@ %def prc_omega_set_parameters
@ To fully initialize the process core, we perform base
initialization, then initialize the external matrix element code.

This procedure overrides the [[init]] method of the base type, which
we nevertheless can access via its binding [[base_init]].  When done, we
have an allocated driver.  The driver will call the [[init]] procedure
for the external matrix element, and thus transfer the parameter set to
where it finally belongs.

If requested, we initialize the helicity selction counter.
<<Omega interface: prc omega: TBP>>=
  procedure :: init => prc_omega_init
<<Omega interface: sub interfaces>>=
    module subroutine prc_omega_init (object, def, lib, id, i_component)
      class(prc_omega_t), intent(inout) :: object
      class(prc_core_def_t), intent(in), target :: def
      type(process_library_t), intent(in), target :: lib
      type(string_t), intent(in) :: id
      integer, intent(in) :: i_component
    end subroutine prc_omega_init
<<Omega interface: procedures>>=
  module subroutine prc_omega_init (object, def, lib, id, i_component)
    class(prc_omega_t), intent(inout) :: object
    class(prc_core_def_t), intent(in), target :: def
    type(process_library_t), intent(in), target :: lib
    type(string_t), intent(in) :: id
    integer, intent(in) :: i_component
    call object%base_init (def, lib, id, i_component)
    call object%activate_parameters ()
  end subroutine prc_omega_init

@ %def prc_omega_init
@ Activate the stored parameters by transferring them to the external
matrix element.  Also reset the helicity selection, if requested.
<<Omega interface: prc omega: TBP>>=
  procedure :: activate_parameters => prc_omega_activate_parameters
<<Omega interface: sub interfaces>>=
    module subroutine prc_omega_activate_parameters (object)
      class (prc_omega_t), intent(inout) :: object
    end subroutine prc_omega_activate_parameters
<<Omega interface: procedures>>=
  module subroutine prc_omega_activate_parameters (object)
    class (prc_omega_t), intent(inout) :: object
    if (allocated (object%driver)) then
       if (allocated (object%par)) then
          select type (driver => object%driver)
          type is (omega_driver_t)
             if (associated (driver%init)) then
                call driver%init (object%par, object%scheme)
             end if
          end select
       else
          call msg_bug ("prc_omega_activate: parameter set is not allocated")
       end if
       call object%reset_helicity_selection ()
    else
       call msg_bug ("prc_omega_activate: driver is not allocated")
    end if
  end subroutine prc_omega_activate_parameters

@ %def prc_omega_activate_parameters
@ Tell whether a particular combination of flavor, helicity, color is
allowed.  Here we have to consult the matrix-element driver.
<<Omega interface: prc omega: TBP>>=
  procedure :: is_allowed => prc_omega_is_allowed
<<Omega interface: sub interfaces>>=
    module function prc_omega_is_allowed (object, i_term, f, h, c) result (flag)
      class(prc_omega_t), intent(in) :: object
      integer, intent(in) :: i_term, f, h, c
      logical :: flag
    end function prc_omega_is_allowed
<<Omega interface: procedures>>=
  module function prc_omega_is_allowed (object, i_term, f, h, c) result (flag)
    class(prc_omega_t), intent(in) :: object
    integer, intent(in) :: i_term, f, h, c
    logical :: flag
    logical(c_bool) :: cflag
    select type (driver => object%driver)
    type is (omega_driver_t)
       call driver%is_allowed (f, h, c, cflag)
       flag = cflag
    end select
  end function prc_omega_is_allowed

@ %def prc_omega_is_allowed
@ Transfer the generated momenta directly to the hard interaction in
the (only) term.  We assume that everything has been set up correctly,
so the array fits.

We don't reset the [[new_kinematics]] flag here.  This has to be done
explicitly by the caller ([[reset_new_kinematics]]) when a new kinematics
configuration is to be considered.
<<Omega interface: prc omega: TBP>>=
  procedure :: compute_hard_kinematics => prc_omega_compute_hard_kinematics
<<Omega interface: sub interfaces>>=
    module subroutine prc_omega_compute_hard_kinematics &
         (object, p_seed, i_term, int_hard, core_state)
      class(prc_omega_t), intent(in) :: object
      type(vector4_t), dimension(:), intent(in) :: p_seed
      integer, intent(in) :: i_term
      type(interaction_t), intent(inout) :: int_hard
      class(prc_core_state_t), intent(inout), allocatable :: core_state
    end subroutine prc_omega_compute_hard_kinematics
<<Omega interface: procedures>>=
  module subroutine prc_omega_compute_hard_kinematics &
       (object, p_seed, i_term, int_hard, core_state)
    class(prc_omega_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p_seed
    integer, intent(in) :: i_term
    type(interaction_t), intent(inout) :: int_hard
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    call int_hard%set_momenta (p_seed)
  end subroutine prc_omega_compute_hard_kinematics

@ %def prc_omega_compute_hard_kinematics
@ This procedure is not called for [[prc_omega_t]], just a placeholder.
<<Omega interface: prc omega: TBP>>=
  procedure :: compute_eff_kinematics => prc_omega_compute_eff_kinematics
<<Omega interface: sub interfaces>>=
    module subroutine prc_omega_compute_eff_kinematics &
         (object, i_term, int_hard, int_eff, core_state)
      class(prc_omega_t), intent(in) :: object
      integer, intent(in) :: i_term
      type(interaction_t), intent(in) :: int_hard
      type(interaction_t), intent(inout) :: int_eff
      class(prc_core_state_t), intent(inout), allocatable :: core_state
    end subroutine prc_omega_compute_eff_kinematics
<<Omega interface: procedures>>=
  module subroutine prc_omega_compute_eff_kinematics &
       (object, i_term, int_hard, int_eff, core_state)
    class(prc_omega_t), intent(in) :: object
    integer, intent(in) :: i_term
    type(interaction_t), intent(in) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
  end subroutine prc_omega_compute_eff_kinematics

@ %def prc_omega_compute_eff_kinematics
@ Reset the helicity selection counters and start counting zero
helicities.  We assume that the [[helicity_selection]] object is allocated.
Otherwise, reset and switch off helicity counting.

In the test routine, the driver is allocated but the driver methods are not.
Therefore, guard against a disassociated method.
<<Omega interface: prc omega: TBP>>=
  procedure :: reset_helicity_selection => prc_omega_reset_helicity_selection
<<Omega interface: sub interfaces>>=
    module subroutine prc_omega_reset_helicity_selection (object)
      class(prc_omega_t), intent(inout) :: object
    end subroutine prc_omega_reset_helicity_selection
<<Omega interface: procedures>>=
  module subroutine prc_omega_reset_helicity_selection (object)
    class(prc_omega_t), intent(inout) :: object
    select type (driver => object%driver)
    type is (omega_driver_t)
       if (associated (driver%reset_helicity_selection)) then
          if (object%helicity_selection%active) then
             call driver%reset_helicity_selection &
                  (real (object%helicity_selection%threshold, &
                  c_default_float), &
                  int (object%helicity_selection%cutoff, c_int))
          else
             call driver%reset_helicity_selection &
                  (0._c_default_float, 0_c_int)
          end if
       end if
    end select
  end subroutine prc_omega_reset_helicity_selection

@ %def reset_helicity_selection
@ Compute the amplitude.  For the tree-level process, we can ignore the scale
settings.  The term index [[j]] is also irrelevant.

We first call [[new_event]] for the given momenta (which we must unpack), then
retrieve the amplitude value for the given quantum numbers.

If the [[core_state]] status flag is present, we can make sure that we call
[[new_event]] only once for a given kinematics.  After the first call, we
unset the [[new_kinematics]] flag.

The core objects computes the appropriate $\alpha_s$ value via the [[qcd]]
subobject, taking into account the provided [[ren_scale]] value.  However, if
the extra parameter [[alpha_qcd_forced]] is allocated, it overrides this
setting.

The [[is_allowed]] query is not redundant, since the status may change during
the run if helicities are switched off.
<<Omega interface: prc omega: TBP>>=
  procedure :: compute_amplitude => prc_omega_compute_amplitude
<<Omega interface: sub interfaces>>=
    module function prc_omega_compute_amplitude &
         (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
         core_state)  result (amp)
      class(prc_omega_t), intent(in) :: object
      integer, intent(in) :: j
      type(vector4_t), dimension(:), intent(in) :: p
      integer, intent(in) :: f, h, c
      real(default), intent(in) :: fac_scale, ren_scale
      real(default), intent(in), allocatable :: alpha_qcd_forced
      class(prc_core_state_t), intent(inout), allocatable, optional :: &
           core_state
      complex(default) :: amp
    end function prc_omega_compute_amplitude
<<Omega interface: procedures>>=
  module function prc_omega_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
       core_state)  result (amp)
    class(prc_omega_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: core_state
    real(default) :: alpha_qcd
    complex(default) :: amp
    integer :: n_tot, i
    real(c_default_float), dimension(:,:), allocatable :: parray
    complex(c_default_complex) :: camp
    logical :: new_event
    select type (driver => object%driver)
    type is (omega_driver_t)
       new_event = .true.
       if (present (core_state)) then
          if (allocated (core_state)) then
             select type (core_state)
             type is (omega_state_t)
                new_event = core_state%new_kinematics
                core_state%new_kinematics = .false.
             end select
          end if
       end if
       if (new_event) then
          if (allocated (object%qcd%alpha)) then
             if (allocated (alpha_qcd_forced)) then
                alpha_qcd = alpha_qcd_forced
             else
                alpha_qcd = object%qcd%alpha%get (ren_scale)
             end if
             call driver%update_alpha_s (alpha_qcd)
             if (present (core_state)) then
                if (allocated (core_state)) then
                   select type (core_state)
                   type is (omega_state_t)
                      core_state%alpha_qcd = alpha_qcd
                   end select
                end if
             end if
          end if
          n_tot = object%data%get_n_tot ()
          allocate (parray (0:3, n_tot))
          do i = 1, n_tot
             parray(:,i) = vector4_get_components (p(i))
          end do
          call driver%new_event (parray)
       end if
       if (object%is_allowed (1, f, h, c)) then
          call driver%get_amplitude &
               (int (f, c_int), int (h, c_int), int (c, c_int), camp)
          amp = camp
       else
          amp = 0
       end if
    end select
  end function prc_omega_compute_amplitude

@ %def prc_omega_compute_amplitude
@ After the amplitude has been computed, we may read off the current value of
$\alpha_s$.  This works only if $\alpha_s$ varies, and if the workspace
[[core_state]] is present which stores this value.
<<Omega interface: prc omega: TBP>>=
  procedure :: get_alpha_s => prc_omega_get_alpha_s
<<Omega interface: sub interfaces>>=
    module function prc_omega_get_alpha_s &
         (object, core_state) result (alpha_qcd)
      class(prc_omega_t), intent(in) :: object
      class(prc_core_state_t), intent(in), allocatable :: core_state
      real(default) :: alpha_qcd
    end function prc_omega_get_alpha_s
<<Omega interface: procedures>>=
  module function prc_omega_get_alpha_s &
       (object, core_state) result (alpha_qcd)
    class(prc_omega_t), intent(in) :: object
    class(prc_core_state_t), intent(in), allocatable :: core_state
    real(default) :: alpha_qcd
    alpha_qcd = -1
    if (allocated (object%qcd%alpha) .and. allocated (core_state)) then
       select type (core_state)
       type is (omega_state_t)
          alpha_qcd = core_state%alpha_qcd
       end select
    end if
  end function prc_omega_get_alpha_s

@ %def prc_omega_get_alpha_s
@ After the amplitude has been computed, we may read off the current value of
$\alpha$.  This works only if $\alpha$ varies, and if the workspace
[[core_state]] is present which stores this value.
<<Omega interface: prc omega: TBP>>=
  procedure :: get_alpha_qed => prc_omega_get_alpha_qed
<<Omega interface: sub interfaces>>=
    module function prc_omega_get_alpha_qed &
         (object, core_state) result (alpha_qed)
      class(prc_omega_t), intent(in) :: object
      class(prc_core_state_t), intent(in), allocatable :: core_state
      real(default) :: alpha_qed
    end function prc_omega_get_alpha_qed
<<Omega interface: procedures>>=
  module function prc_omega_get_alpha_qed &
       (object, core_state) result (alpha_qed)
    class(prc_omega_t), intent(in) :: object
    class(prc_core_state_t), intent(in), allocatable :: core_state
    real(default) :: alpha_qed
    alpha_qed = -1
    if (allocated (object%qed%alpha) .and. allocated (core_state)) then
       select type (core_state)
       type is (omega_state_t)
          alpha_qed = core_state%alpha_qed
       end select
    end if
  end function prc_omega_get_alpha_qed

@ %def prc_omega_get_alpha_qed
@
\subsection{Unit Test}
Test module, followed by the corresponding implementation module.
There is a separate test for testing \oMega\ diagram generation as
this depends on a working analysis setup.
<<[[prc_omega_ut.f90]]>>=
<<File header>>

module prc_omega_ut
  use unit_tests
  use prc_omega_uti

<<Standard module head>>

<<Omega interface: public test>>

contains

<<Omega interface: test driver>>

end module prc_omega_ut
@ %def prc_omega_ut
@
<<[[prc_omega_uti.f90]]>>=
<<File header>>

module prc_omega_uti

  use, intrinsic :: iso_c_binding !NODEP!

  use kinds
<<Use strings>>
  use io_units
  use file_utils, only: delete_file
  use os_interface
  use sm_qcd
  use lorentz
  use model_data
  use var_base
  use particle_specifiers, only: new_prt_spec
  use prc_core_def
  use process_constants
  use process_libraries
  use prc_core
  use model_testbed, only: prepare_model, cleanup_model

  use prc_omega

<<Standard module head>>

<<Omega interface: test declarations>>

contains

<<Omega interface: tests>>

end module prc_omega_uti
@ %def prc_omega_ut
@ API: driver for the unit tests below.
<<Omega interface: public test>>=
  public :: prc_omega_test
<<Omega interface: test driver>>=
  subroutine prc_omega_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Omega interface: execute tests>>
end subroutine prc_omega_test

@ %def prc_omega_test
@
<<Omega interface: public test>>=
  public :: prc_omega_diags_test
<<Omega interface: test driver>>=
  subroutine prc_omega_diags_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Omega interface: execute diags tests>>
end subroutine prc_omega_diags_test

@ %def prc_omega_diags_test
@
\subsubsection{Generate, compile and load a simple process matrix element}
The process is $e^+ e^- \to \mu^+\mu^-$ for vanishing masses and
$e=0.3$.  We initialize the process, build the library, and compute a
particular matrix element for momenta of unit energy and right-angle
scattering.  The matrix element, as it happens, is equal to $e^2$.
(Note that are no conversion factors applied, so this result is
exact.)

For [[GNU make]], [[makeflags]] is set to [[-j1]].  This eliminates a
potential clash with a [[-j<n>]] flag if this test is called from a
parallel make.
<<Omega interface: execute tests>>=
  call test (prc_omega_1, "prc_omega_1", &
       "build and load simple OMega process", &
       u, results)
<<Omega interface: test declarations>>=
  public :: prc_omega_1
<<Omega interface: tests>>=
  subroutine prc_omega_1 (u)
    integer, intent(in) :: u
    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(string_t) :: model_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    integer, parameter :: cdf = c_default_float
    integer, parameter :: ci = c_int
    real(cdf), dimension(4) :: par
    real(cdf), dimension(0:3,4) :: p
    logical(c_bool) :: flag
    complex(c_default_complex) :: amp
    integer :: i

    write (u, "(A)")  "* Test output: prc_omega_1"
    write (u, "(A)")  "*   Purpose: create a simple process with OMega"
    write (u, "(A)")  "*            build a library, link, load, and &
         &access the matrix element"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with one entry"
    write (u, "(A)")
    call lib%init (var_str ("omega1"))
    call os_data%init ()

    model_name = "QED"
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("m+"), var_str ("m-")]

    allocate (omega_def_t :: def)
    select type (def)
    type is (omega_def_t)
       call def%init (model_name, prt_in, prt_out, &
            ufo = .false., ovm = .false.)
    end select
    allocate (entry)
    call entry%init (var_str ("omega1_a"), model_name = model_name, &
         n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    write (u, "(A)")  "* Configure library"
    write (u, "(A)")
    call lib%configure (os_data)

    write (u, "(A)")  "* Write makefile"
    write (u, "(A)")
    call lib%write_makefile (os_data, force = .true., verbose = .false.)

    write (u, "(A)")  "* Clean any left-over files"
    write (u, "(A)")
    call lib%clean (os_data, distclean = .false.)

    write (u, "(A)")  "* Write driver"
    write (u, "(A)")
    call lib%write_driver (force = .true.)

    write (u, "(A)")  "* Write process source code, compile, link, load"
    write (u, "(A)")
    call lib%load (os_data)

    call lib%write (u, libpath = .false.)

    write (u, "(A)")
    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")

    write (u, "(1x,A,L1)")  "is active                 = ", &
         lib%is_active ()
    write (u, "(1x,A,I0)")  "n_processes               = ", &
         lib%get_n_processes ()

    write (u, "(A)")
    write (u, "(A)")  "* Constants of omega1_a_i1:"
    write (u, "(A)")

    call lib%connect_process (var_str ("omega1_a"), 1, data, driver)

    write (u, "(1x,A,A)")  "component ID     = ", char (data%id)
    write (u, "(1x,A,A)")  "model name       = ", char (data%model_name)
    write (u, "(1x,A,A,A)")  "md5sum           = '", data%md5sum, "'"
    write (u, "(1x,A,L1)") "openmp supported = ", data%openmp_supported
    write (u, "(1x,A,I0)") "n_in  = ", data%n_in
    write (u, "(1x,A,I0)") "n_out = ", data%n_out
    write (u, "(1x,A,I0)") "n_flv = ", data%n_flv
    write (u, "(1x,A,I0)") "n_hel = ", data%n_hel
    write (u, "(1x,A,I0)") "n_col = ", data%n_col
    write (u, "(1x,A,I0)") "n_cin = ", data%n_cin
    write (u, "(1x,A,I0)") "n_cf  = ", data%n_cf
    write (u, "(1x,A,10(1x,I0))") "flv state =", data%flv_state
    write (u, "(1x,A,10(1x,I2))") "hel state =", data%hel_state(:,1)
    do i = 2, 16
       write (u, "(12x,4(1x,I2))")  data%hel_state(:,i)
    end do
    write (u, "(1x,A,10(1x,I0))") "col state =", data%col_state
    write (u, "(1x,A,10(1x,L1))") "ghost flag =", data%ghost_flag
    write (u, "(1x,A,10(1x,F5.3))") "color factors =", data%color_factors
    write (u, "(1x,A,10(1x,I0))") "cf index =", data%cf_index

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters for omega1_a and initialize:"
    write (u, "(A)")

    par = [0.3_cdf, 0.0_cdf, 0.0_cdf, 0.0_cdf]
    write (u, "(2x,A,F6.4)")  "ee   = ", par(1)
    write (u, "(2x,A,F6.4)")  "me   = ", par(2)
    write (u, "(2x,A,F6.4)")  "mmu  = ", par(3)
    write (u, "(2x,A,F6.4)")  "mtau = ", par(4)

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")

    p = reshape ([ &
         1.0_cdf, 0.0_cdf, 0.0_cdf, 1.0_cdf, &
         1.0_cdf, 0.0_cdf, 0.0_cdf,-1.0_cdf, &
         1.0_cdf, 1.0_cdf, 0.0_cdf, 0.0_cdf, &
         1.0_cdf,-1.0_cdf, 0.0_cdf, 0.0_cdf &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.4))")  "p", i, " =", p(:,i)
    end do

    select type (driver)
    type is (omega_driver_t)
       call driver%init (par, 0)

       call driver%new_event (p)

       write (u, "(A)")
       write (u, "(A)")  "* Compute matrix element:"
       write (u, "(A)")

       call driver%is_allowed (1_ci, 6_ci, 1_ci, flag)
       write (u, "(1x,A,L1)") "is_allowed (1, 6, 1) = ", flag

       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)
    end select

    call lib%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_1"

  end subroutine prc_omega_1

@ %def prc_omega_1
@
\subsubsection{Check [[prc_omega_t]] wrapper and options}
The process is $e^- e^+ \to e^- e^+$ for vanishing masses and
$e=0.3$.  We build the library using the high-level procedure
[[omega_make_process_component]] and the ``black box''
[[prc_omega_t]] object.  Two variants with different settings for
restrictions and OpenMP.

For [[GNU make]], [[makeflags]] is set to [[-j1]].  This eliminates a
potential clash with a [[-j<n>]] flag if this test is called from a
parallel make.
<<Omega interface: execute tests>>=
  call test (prc_omega_2, "prc_omega_2", &
       "OMega option passing", &
       u, results)
<<Omega interface: test declarations>>=
  public :: prc_omega_2
<<Omega interface: tests>>=
  subroutine prc_omega_2 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(string_t) :: model_name
    class(model_data_t), pointer :: model
    class(vars_t), pointer :: vars
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(string_t) :: restrictions
    type(process_component_def_t), pointer :: config
    type(prc_omega_t) :: prc1, prc2
    type(process_constants_t) :: data
    integer, parameter :: cdf = c_default_float
    integer, parameter :: ci = c_int
    real(cdf), dimension(:), allocatable :: par
    real(cdf), dimension(0:3,4) :: p
    complex(c_default_complex) :: amp
    integer :: i
    logical :: exist

    write (u, "(A)")  "* Test output: prc_omega_2"
    write (u, "(A)")  "*   Purpose: create simple processes with OMega"
    write (u, "(A)")  "*            use the prc_omega wrapper for this"
    write (u, "(A)")  "*            and check OMega options"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with two entries, &
         &different options."
    write (u, "(A)")  "* (1) e- e+ -> e- e+   &
         &(all diagrams, no OpenMP, report progress)"
    write (u, "(A)")  "* (2) e- e+ -> e- e+   &
         &(s-channel only, with OpenMP, report progress to file)"

    call lib%init (var_str ("omega2"))
    call os_data%init ()

    model_name = "QED"
    model => null ()
    call prepare_model (model, model_name, vars)

    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e-"), var_str ("e+")]
    prt_out = prt_in
    restrictions = "3+4~A"

    allocate (entry)
    call entry%init (var_str ("omega2_a"), &
         model, n_in = 2, n_components = 2)

    call omega_make_process_component (entry, 1, &
         model_name, prt_in, prt_out, &
         report_progress=.true.)
    call omega_make_process_component (entry, 2, &
         model_name, prt_in, prt_out, &
         restrictions=restrictions, openmp_support=.true., &
         extra_options=var_str ("-fusion:progress_file omega2.log"))

    call lib%append (entry)

    write (u, "(A)")
    write (u, "(A)")  "* Remove left-over file"
    write (u, "(A)")

    call delete_file ("omega2.log")
    inquire (file="omega2.log", exist=exist)
    write (u, "(1x,A,L1)")  "omega2.log exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Build and load library"

    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true., verbose = .false.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)

    write (u, "(A)")
    write (u, "(A)")  "* Check extra output of OMega"
    write (u, "(A)")

    inquire (file="omega2.log", exist=exist)
    write (u, "(1x,A,L1)")  "omega2.log exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")

    write (u, "(1x,A,L1)")  "is active                 = ", &
         lib%is_active ()
    write (u, "(1x,A,I0)")  "n_processes               = ", &
         lib%get_n_processes ()

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters for omega2_a and initialize:"
    write (u, "(A)")

    call vars%set_rval (var_str ("ee"), 0.3_default)
    call vars%set_rval (var_str ("me"), 0._default)
    call vars%set_rval (var_str ("mmu"), 0._default)
    call vars%set_rval (var_str ("mtau"), 0._default)
    allocate (par (model%get_n_real ()))
    call model%real_parameters_to_c_array (par)

    write (u, "(2x,A,F6.4)")  "ee   = ", par(1)
    write (u, "(2x,A,F6.4)")  "me   = ", par(2)
    write (u, "(2x,A,F6.4)")  "mmu  = ", par(3)
    write (u, "(2x,A,F6.4)")  "mtau = ", par(4)

    call prc1%set_parameters (model)
    call prc2%set_parameters (model)

    write (u, "(A)")
    write (u, "(A)")  "* Constants of omega2_a_i1:"
    write (u, "(A)")

    entry => lib%get_process_def_ptr (var_str ("omega2_a"))
    config => entry%get_component_def_ptr (1)
    call prc1%init (config%get_core_def_ptr (), &
         lib, var_str ("omega2_a"), 1)
    call prc1%get_constants (data, 1)

    write (u, "(1x,A,A)")  "component ID     = ", &
         char (data%id)
    write (u, "(1x,A,L1)") "openmp supported = ", &
         data%openmp_supported
    write (u, "(1x,A,A,A)") "model name       = '", &
         char (data%model_name), "'"

    write (u, "(A)")
    write (u, "(A)")  "* Constants of omega2_a_i2:"
    write (u, "(A)")

    config => entry%get_component_def_ptr (2)
    call prc2%init (config%get_core_def_ptr (), &
         lib, var_str ("omega2_a"), 2)
    call prc2%get_constants (data, 1)

    write (u, "(1x,A,A)")  "component ID     = ", &
         char (data%id)
    write (u, "(1x,A,L1)") "openmp supported = ", &
         data%openmp_supported
    write (u, "(1x,A,A,A)") "model name       = '", &
         char (data%model_name), "'"

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")

    p = reshape ([ &
         1.0_cdf, 0.0_cdf, 0.0_cdf, 1.0_cdf, &
         1.0_cdf, 0.0_cdf, 0.0_cdf,-1.0_cdf, &
         1.0_cdf, 1.0_cdf, 0.0_cdf, 0.0_cdf, &
         1.0_cdf,-1.0_cdf, 0.0_cdf, 0.0_cdf &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.4))")  "p", i, " =", p(:,i)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Compute matrix element:"
    write (u, "(A)")

    select type (driver => prc1%driver)
    type is (omega_driver_t)
       call driver%new_event (p)
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(2x,A,1x,E11.4)") "(1) |amp (1, 6, 1)| =", abs (amp)
    end select

    select type (driver => prc2%driver)
    type is (omega_driver_t)
       call driver%new_event (p)
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(2x,A,1x,E11.4)") "(2) |amp (1, 6, 1)| =", abs (amp)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")

    p = reshape ([ &
         1.0_cdf, 0.0_cdf, 0.0_cdf, 1.0_cdf, &
         1.0_cdf, 0.0_cdf, 0.0_cdf,-1.0_cdf, &
         1.0_cdf, sqrt(0.5_cdf), 0.0_cdf, sqrt(0.5_cdf), &
         1.0_cdf,-sqrt(0.5_cdf), 0.0_cdf,-sqrt(0.5_cdf) &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.4))")  "p", i, " =", p(:,i)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Compute matrix element:"
    write (u, "(A)")

    select type (driver => prc1%driver)
    type is (omega_driver_t)
       call driver%new_event (p)
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(2x,A,1x,E11.4)") "(1) |amp (1, 6, 1)| =", abs (amp)
    end select

    select type (driver => prc2%driver)
    type is (omega_driver_t)
       call driver%new_event (p)
       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(2x,A,1x,E11.4)") "(2) |amp (1, 6, 1)| =", abs (amp)
    end select

    call lib%final ()
    call cleanup_model (model)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_2"

  end subroutine prc_omega_2

@ %def prc_omega_2
@
\subsubsection{Check helicity selection}
The process is $e^- e^+ \to e^- e^+$ for vanishing masses.  We call
the matrix element several times to verify the switching off of
irrelevant helicities.
<<Omega interface: execute tests>>=
  call test (prc_omega_3, "prc_omega_3", &
       "helicity selection", &
       u, results)
<<Omega interface: test declarations>>=
  public :: prc_omega_3
<<Omega interface: tests>>=
  subroutine prc_omega_3 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(string_t) :: model_name
    class(model_data_t), pointer :: model
    class(vars_t), pointer :: vars => null ()
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(process_component_def_t), pointer :: config
    type(prc_omega_t) :: prc1
    type(process_constants_t) :: data
    integer, parameter :: cdf = c_default_float
    real(cdf), dimension(:), allocatable :: par
    real(cdf), dimension(0:3,4) :: p
    type(helicity_selection_t) :: helicity_selection
    integer :: i, h

    write (u, "(A)")  "* Test output: prc_omega_3"
    write (u, "(A)")  "*   Purpose: create simple process with OMega"
    write (u, "(A)")  "*            and check helicity selection"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library."
    write (u, "(A)")  "* (1) e- e+ -> e- e+   (all diagrams, no OpenMP)"

    call lib%init (var_str ("omega3"))
    call os_data%init ()

    model_name = "QED"
    model => null ()
    call prepare_model (model, model_name, vars)

    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e-"), var_str ("e+")]
    prt_out = prt_in

    allocate (entry)
    call entry%init (var_str ("omega3_a"), &
         model, n_in = 2, n_components = 1)

    call omega_make_process_component (entry, 1, &
         model_name, prt_in, prt_out)
    call lib%append (entry)

    write (u, "(A)")
    write (u, "(A)")  "* Build and load library"

    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true., verbose = .false.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)

    write (u, "(A)")
    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")

    write (u, "(1x,A,L1)")  "is active                 = ", &
         lib%is_active ()
    write (u, "(1x,A,I0)")  "n_processes               = ", &
         lib%get_n_processes ()

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters for omega3_a and initialize:"
    write (u, "(A)")

    call vars%set_rval (var_str ("ee"), 0.3_default)
    call vars%set_rval (var_str ("me"), 0._default)
    call vars%set_rval (var_str ("mmu"), 0._default)
    call vars%set_rval (var_str ("mtau"), 0._default)
    allocate (par (model%get_n_real ()))
    call model%real_parameters_to_c_array (par)

    write (u, "(2x,A,F6.4)")  "ee   = ", par(1)
    write (u, "(2x,A,F6.4)")  "me   = ", par(2)
    write (u, "(2x,A,F6.4)")  "mmu  = ", par(3)
    write (u, "(2x,A,F6.4)")  "mtau = ", par(4)

    call prc1%set_parameters (model, helicity_selection=helicity_selection)

    write (u, "(A)")
    write (u, "(A)")  "* Helicity states of omega3_a_i1:"
    write (u, "(A)")

    entry => lib%get_process_def_ptr (var_str ("omega3_a"))
    config => entry%get_component_def_ptr (1)
    call prc1%init (config%get_core_def_ptr (), &
         lib, var_str ("omega3_a"), 1)
    call prc1%get_constants (data, 1)

    do i = 1, data%n_hel
       write (u, "(3x,I2,':',4(1x,I2))") i, data%hel_state(:,i)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Initially allowed helicities:"
    write (u, "(A)")

    write (u, "(4x,16(1x,I2))")  [(h, h = 1, data%n_hel)]
    write (u, "(4x)", advance = "no")
    do h = 1, data%n_hel
       write (u, "(2x,L1)", advance = "no")  prc1%is_allowed (1, 1, h, 1)
    end do
    write (u, "(A)")

    write (u, "(A)")
    write (u, "(A)")  "* Reset helicity selection (cutoff = 4)"
    write (u, "(A)")

    helicity_selection%active = .true.
    helicity_selection%threshold = 1e10_default
    helicity_selection%cutoff = 4
    call helicity_selection%write (u)

    call prc1%set_parameters (model, helicity_selection=helicity_selection)
    call prc1%reset_helicity_selection ()

    write (u, "(A)")
    write (u, "(A)")  "* Allowed helicities:"
    write (u, "(A)")

    write (u, "(4x,16(1x,I2))")  [(h, h = 1, data%n_hel)]
    write (u, "(4x)", advance = "no")
    do h = 1, data%n_hel
       write (u, "(2x,L1)", advance = "no")  prc1%is_allowed (1, 1, h, 1)
    end do
    write (u, "(A)")

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")

    p = reshape ([ &
         1.0_cdf, 0.0_cdf, 0.0_cdf, 1.0_cdf, &
         1.0_cdf, 0.0_cdf, 0.0_cdf,-1.0_cdf, &
         1.0_cdf, 1.0_cdf, 0.0_cdf, 0.0_cdf, &
         1.0_cdf,-1.0_cdf, 0.0_cdf, 0.0_cdf &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.4))")  "p", i, " =", p(:,i)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Compute scattering matrix 5 times"
    write (u, "(A)")

    write (u, "(4x,16(1x,I2))")  [(h, h = 1, data%n_hel)]

    select type (driver => prc1%driver)
    type is (omega_driver_t)
       do i = 1, 5
          call driver%new_event (p)
          write (u, "(2x,I2)", advance = "no")  i
          do h = 1, data%n_hel
             write (u, "(2x,L1)", advance = "no")  prc1%is_allowed (1, 1, h, 1)
          end do
          write (u, "(A)")
       end do
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Reset helicity selection again"
    write (u, "(A)")

    call prc1%activate_parameters ()

    write (u, "(A)")  "* Allowed helicities:"
    write (u, "(A)")

    write (u, "(4x,16(1x,I2))")  [(h, h = 1, data%n_hel)]
    write (u, "(4x)", advance = "no")
    do h = 1, data%n_hel
       write (u, "(2x,L1)", advance = "no")  prc1%is_allowed (1, 1, h, 1)
    end do
    write (u, "(A)")

    call lib%final ()
    call cleanup_model (model)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_3"

  end subroutine prc_omega_3

@ %def prc_omega_3
@
\subsubsection{QCD coupling}
The process is $u\bar u \to d\bar d$ for vanishing masses.  We compute
the amplitude for a fixed configuration once, then reset $\alpha_s$,
then compute again.

For [[GNU make]], [[makeflags]] is set to [[-j1]].  This eliminates a
potential clash with a [[-j<n>]] flag if this test is called from a
parallel make.
<<Omega interface: execute tests>>=
  call test (prc_omega_4, "prc_omega_4", &
       "update QCD alpha", &
       u, results)
<<Omega interface: test declarations>>=
  public :: prc_omega_4
<<Omega interface: tests>>=
  subroutine prc_omega_4 (u)
    integer, intent(in) :: u
    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(string_t) :: model_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    integer, parameter :: cdf = c_default_float
    integer, parameter :: ci = c_int
    real(cdf), dimension(8) :: par
    real(cdf), dimension(0:3,4) :: p
    logical(c_bool) :: flag
    complex(c_default_complex) :: amp
    integer :: i
    real(cdf) :: alpha_s

    write (u, "(A)")  "* Test output: prc_omega_4"
    write (u, "(A)")  "*   Purpose: create a QCD process with OMega"
    write (u, "(A)")  "*            and check alpha_s dependence"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with one entry"
    write (u, "(A)")
    call lib%init (var_str ("prc_omega_4_lib"))
    call os_data%init ()

    model_name = "QCD"
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("u"), var_str ("ubar")]
    prt_out = [var_str ("d"), var_str ("dbar")]

    allocate (omega_def_t :: def)
    select type (def)
    type is (omega_def_t)
       call def%init (model_name, prt_in, prt_out, &
            ufo = .false., ovm = .false.)
    end select
    allocate (entry)
    call entry%init (var_str ("prc_omega_4_p"), model_name = model_name, &
         n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    write (u, "(A)")  "* Configure and compile process"
    write (u, "(A)")
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true., verbose = .false.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)

    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")

    write (u, "(1x,A,L1)")  "is active = ", lib%is_active ()

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters:"
    write (u, "(A)")

    alpha_s = 0.1178_cdf

    par = [alpha_s, &
         0._cdf, 0._cdf, 0._cdf, 0._cdf, 0._cdf, 173.1_cdf, 1.523_cdf]
    write (u, "(2x,A,F8.4)")  "alpha_s = ", par(1)
    write (u, "(2x,A,F8.4)")  "md      = ", par(2)
    write (u, "(2x,A,F8.4)")  "mu      = ", par(3)
    write (u, "(2x,A,F8.4)")  "ms      = ", par(4)
    write (u, "(2x,A,F8.4)")  "mc      = ", par(5)
    write (u, "(2x,A,F8.4)")  "mb      = ", par(6)
    write (u, "(2x,A,F8.4)")  "mtop    = ", par(7)
    write (u, "(2x,A,F8.4)")  "wtop    = ", par(8)

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics:"
    write (u, "(A)")

    p = reshape ([ &
         100.0_cdf, 0.0_cdf, 0.0_cdf, 100.0_cdf, &
         100.0_cdf, 0.0_cdf, 0.0_cdf,-100.0_cdf, &
         100.0_cdf, 100.0_cdf, 0.0_cdf, 0.0_cdf, &
         100.0_cdf,-100.0_cdf, 0.0_cdf, 0.0_cdf &
         ], [4,4])
    do i = 1, 4
       write (u, "(2x,A,I0,A,4(1x,F7.1))")  "p", i, " =", p(:,i)
    end do

    call lib%connect_process (var_str ("prc_omega_4_p"), 1, data, driver)

    select type (driver)
    type is (omega_driver_t)
       call driver%init (par, 0)

       write (u, "(A)")
       write (u, "(A)")  "* Compute matrix element:"
       write (u, "(A)")

       call driver%new_event (p)

       call driver%is_allowed (1_ci, 6_ci, 1_ci, flag)
       write (u, "(1x,A,L1)") "is_allowed (1, 6, 1) = ", flag

       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)

       write (u, "(A)")
       write (u, "(A)")  "* Double alpha_s and compute matrix element again:"
       write (u, "(A)")

       call driver%update_alpha_s (2 * alpha_s)
       call driver%new_event (p)

       call driver%is_allowed (1_ci, 6_ci, 1_ci, flag)
       write (u, "(1x,A,L1)") "is_allowed (1, 6, 1) = ", flag

       call driver%get_amplitude (1_ci, 6_ci, 1_ci, amp)
       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)
    end select

    call lib%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_4"

  end subroutine prc_omega_4

@ %def prc_omega_4
@
\subsubsection{Amplitude and QCD coupling}
The same process as before.  Here, we initialize with a running $\alpha_s$
coupling and compute twice with different scales.  We use the high-level
method [[compute_amplitude]].
<<Omega interface: execute tests>>=
  call test (prc_omega_5, "prc_omega_5", &
       "running QCD alpha", &
       u, results)
<<Omega interface: test declarations>>=
  public :: prc_omega_5
<<Omega interface: tests>>=
  subroutine prc_omega_5 (u)
    integer, intent(in) :: u
    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_component_def_t), pointer :: cdef_ptr
    class(prc_core_def_t), pointer :: def_ptr
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(string_t) :: model_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(qcd_t) :: qcd
    class(prc_core_t), allocatable :: core
    class(prc_core_state_t), allocatable :: core_state
    type(vector4_t), dimension(4) :: p
    complex(default) :: amp
    real(default) :: ren_scale
    real(default), allocatable :: alpha_qcd_forced
    integer :: i

    write (u, "(A)")  "* Test output: prc_omega_5"
    write (u, "(A)")  "*   Purpose: create a QCD process with OMega"
    write (u, "(A)")  "*            and check alpha_s dependence"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with one entry"
    write (u, "(A)")
    call lib%init (var_str ("prc_omega_5_lib"))
    call os_data%init ()

    model_name = "QCD"
    model => null ()
    call prepare_model (model, model_name)

    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("u"), var_str ("ubar")]
    prt_out = [var_str ("d"), var_str ("dbar")]

    allocate (omega_def_t :: def)
    select type (def)
    type is (omega_def_t)
       call def%init (model_name, prt_in, prt_out, &
            ufo = .false., ovm = .false.)
    end select
    allocate (entry)
    call entry%init (var_str ("prc_omega_5_p"), model_name = model_name, &
         n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    write (u, "(A)")  "* Configure and compile process"
    write (u, "(A)")
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true., verbose = .false.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)

    write (u, "(A)")  "* Probe library API"
    write (u, "(A)")

    write (u, "(1x,A,L1)")  "is active = ", lib%is_active ()

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics"
    write (u, "(A)")

    p(1) = vector4_moving (100._default, 100._default, 3)
    p(2) = vector4_moving (100._default,-100._default, 3)
    p(3) = vector4_moving (100._default, 100._default, 1)
    p(4) = vector4_moving (100._default,-100._default, 1)
    do i = 1, 4
       call vector4_write (p(i), u)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Setup QCD data"
    write (u, "(A)")

    allocate (alpha_qcd_from_scale_t :: qcd%alpha)

    write (u, "(A)")  "* Setup process core"
    write (u, "(A)")

    allocate (prc_omega_t :: core)
    entry => lib%get_process_def_ptr (var_str ("prc_omega_5_p"))
    cdef_ptr => entry%get_component_def_ptr (1)
    def_ptr => cdef_ptr%get_core_def_ptr ()

    select type (core)
    type is (prc_omega_t)
       call core%allocate_workspace (core_state)
       call core%set_parameters (model, qcd = qcd)
       call core%init (def_ptr, lib, var_str ("prc_omega_5_p"), 1)
       call core%write (u)

       write (u, "(A)")
       write (u, "(A)")  "* Compute matrix element"
       write (u, "(A)")

       ren_scale = 100
       write (u, "(1x,A,F4.0)")  "renormalization scale = ", ren_scale

       amp = core%compute_amplitude &
            (1, p, 1, 6, 1, 100._default, ren_scale, alpha_qcd_forced)

       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)

       write (u, "(A)")
       write (u, "(A)")  "* Modify renormalization scale and &
            &compute matrix element again"
       write (u, "(A)")

       ren_scale = 200
       write (u, "(1x,A,F4.0)")  "renormalization scale = ", ren_scale

       amp = core%compute_amplitude &
            (1, p, 1, 6, 1, 100._default, ren_scale, alpha_qcd_forced)

       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)

       write (u, "(A)")
       write (u, "(A)")  "* Set alpha(QCD) directly and &
            &compute matrix element again"
       write (u, "(A)")

       allocate (alpha_qcd_forced, source = 0.1_default)
       write (u, "(1x,A,F6.4)")  "alpha_qcd = ", alpha_qcd_forced

       amp = core%compute_amplitude &
            (1, p, 1, 6, 1, 100._default, ren_scale, alpha_qcd_forced)

       write (u, "(1x,A,1x,E11.4)") "|amp (1, 6, 1)| =", abs (amp)

    end select

    call lib%final ()
    call cleanup_model (model)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_5"

  end subroutine prc_omega_5

@ %def prc_omega_5
@
\subsubsection{UFO model file support}
Again, the process is $e^- e^+ \to e^- e^+$ for vanishing masses and
$e=0.3$.  We build the library using the high-level procedure
[[omega_make_process_component]] and the ``black box''
[[prc_omega_t]] object.  OMega must be able to digest the specified
UFO file and provide use with a fresh model file that can be read
after producing the process code.

For [[GNU make]], [[makeflags]] is set to [[-j1]].  This eliminates a
potential clash with a [[-j<n>]] flag if this test is called from a
parallel make.
<<Omega interface: execute tests>>=
  call test (prc_omega_6, "prc_omega_6", &
       "OMega UFO support", &
       u, results)
<<Omega interface: test declarations>>=
  public :: prc_omega_6
<<Omega interface: tests>>=
  subroutine prc_omega_6 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(string_t) :: model_name
    class(model_data_t), pointer :: model
    class(vars_t), pointer :: vars
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(string_t) :: restrictions
    type(process_component_def_t), pointer :: config
    type(prc_omega_t) :: prc1, prc2
    type(process_constants_t) :: data
    integer, parameter :: cdf = c_default_float
    integer, parameter :: ci = c_int
    real(cdf), dimension(:), allocatable :: par
    real(cdf), dimension(0:3,4) :: p
    complex(c_default_complex) :: amp
    integer :: i
    logical :: exist

    write (u, "(A)")  "* Test output: prc_omega_6"
    write (u, "(A)")  "*   Purpose: create simple process with OMega / UFO file"
    write (u, "(A)")

    call os_data%init ()

    model_name = "SM"
    model => null ()

    os_data%whizard_modelpath_ufo = "../models/UFO"

    write (u, "(A)")  "* Create process library entry"
    write (u, "(A)")

    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e-"), var_str ("e+")]
    prt_out = prt_in
    restrictions = "3+4~A"

    allocate (entry)
    call entry%init (var_str ("omega_6_a"), &
         model_name = model_name, n_in = 2, n_components = 1)

    call omega_make_process_component (entry, 1, &
         model_name, prt_in, prt_out, &
         ufo=.true., ufo_path=os_data%whizard_modelpath_ufo, &
         report_progress=.true.)

    call entry%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Build and load library"

    call lib%init (var_str ("omega_6"))
    call lib%append (entry)

    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true., verbose = .false.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)

    write (u, "(A)")
    write (u, "(A)")  "* Probe library API:"
    write (u, "(A)")

    write (u, "(1x,A,L1)")  "is active                 = ", &
         lib%is_active ()
    write (u, "(1x,A,I0)")  "n_processes               = ", &
         lib%get_n_processes ()

    call lib%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_6"

  end subroutine prc_omega_6

@ %def prc_omega_6
@
\subsubsection{Generate matrix element diagrams}
The same process as before. No amplitude is computed here, instead we just
generate Feynman (and color flow) diagrams, and check whether PS and PDF
files have been generated. This test is only run if event analysis is
possible.
<<Omega interface: execute diags tests>>=
  call test (prc_omega_diags_1, "prc_omega_diags_1", &
       "generate Feynman diagrams", &
       u, results)
<<Omega interface: test declarations>>=
  public :: prc_omega_diags_1
<<Omega interface: tests>>=
  subroutine prc_omega_diags_1 (u)
    integer, intent(in) :: u
    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(os_data_t) :: os_data
    type(string_t) :: model_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(string_t) :: diags_file, pdf_file, ps_file
    logical :: exist, exist_pdf, exist_ps
    integer :: iostat, u_diags
    character(128) :: buffer

    write (u, "(A)")  "* Test output: prc_omega_diags_1"
    write (u, "(A)")  "*   Purpose: generate Feynman diagrams"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process library with one entry"
    write (u, "(A)")
    call lib%init (var_str ("prc_omega_diags_1_lib"))
    call os_data%init ()

    model_name = "SM"

    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("u"), var_str ("ubar")]
    prt_out = [var_str ("d"), var_str ("dbar")]

    allocate (omega_def_t :: def)
    select type (def)
    type is (omega_def_t)
       call def%init (model_name, prt_in, prt_out, &
            ufo = .false., ovm = .false., &
            diags = .true., diags_color = .true.)
    end select
    allocate (entry)
    call entry%init (var_str ("prc_omega_diags_1_p"), model_name = model_name, &
         n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = size (prt_out), &
         prt_in  = new_prt_spec (prt_in), &
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    write (u, "(A)")  "* Configure and compile process"
    write (u, "(A)")  "    and generate diagrams"
    write (u, "(A)")
    call lib%configure (os_data)
    call lib%write_makefile &
         (os_data, force = .true., verbose = .false., testflag = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)

    write (u, "(A)")  "* Probe library API"
    write (u, "(A)")

    write (u, "(1x,A,L1)")  "is active = ", lib%is_active ()

    write (u, "(A)")  "* Check produced diagram files"
    write (u, "(A)")

    diags_file = "prc_omega_diags_1_p_i1_diags.tex"
    ps_file  = "prc_omega_diags_1_p_i1_diags.ps"
    pdf_file = "prc_omega_diags_1_p_i1_diags.pdf"
    inquire (file = char (diags_file), exist = exist)
    if (exist) then
       u_diags = free_unit ()
       open (u_diags, file = char (diags_file), action = "read", status = "old")
       iostat = 0
       do while (iostat == 0)
          read (u_diags, "(A)", iostat = iostat)  buffer
          if (iostat == 0)  write (u, "(A)")  trim (buffer)
       end do
       close (u_diags)
    else
       write (u, "(A)")  "[Feynman diagrams LaTeX file is missing]"
    end if
    inquire (file = char (ps_file), exist = exist_ps)
    if (exist_ps) then
       write (u, "(A)")  "[Feynman diagrams Postscript file exists and is nonempty]"
    else
       write (u, "(A)")  "[Feynman diagrams Postscript file is missing/non-regular]"
    end if
    inquire (file = char (pdf_file), exist = exist_pdf)
    if (exist_pdf) then
       write (u, "(A)")  "[Feynman diagrams PDF file exists and is nonempty]"
    else
       write (u, "(A)")  "[Feynman diagrams PDF file is missing/non-regular]"
    end if

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    write (u, "(A)")

    call lib%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: prc_omega_diags_1"

  end subroutine prc_omega_diags_1

@ %def prc_omega_diags_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{External matrix elements (squared)}
This defines an abstract framework that can handle matrix elements which are
computed outside of \whizard.  Such matrix elements typically (i) require
extra code or libraries to be configured linked at execution time, and (ii)
provide only plain or correlated squared matrix elements instead of
amplitudes.

In particular, matrix-element libraries that conform to the BLHA standard
belong to this class.  They have their own (also abstract) extension of the
abstract [[prc_external_t]] type introduced here.
[[prc_external_t]]-type.
<<[[prc_external.f90]]>>=
<<File header>>
module prc_external

  use, intrinsic :: iso_c_binding !NODEP!

  use kinds
<<Use strings>>
  use constants
  use os_interface
  use lorentz
  use interactions
  use sm_qcd
  use sm_qed
  use variables, only: var_list_t

  use model_data
  use prclib_interfaces
  use prc_core_def
  use prc_core

  use sf_base
  use sf_pdf_builtin, only: pdf_builtin_t
  use sf_lhapdf, only: lhapdf_t

<<Standard module head>>

<<Prc external: public>>

<<Prc external: types>>

<<Prc external: interfaces>>

  interface
<<Prc external: sub interfaces>>
  end interface

contains

<<Prc external: main procedures>>

end module prc_external
@ %def prc_external
@
<<[[prc_external_sub.f90]]>>=
<<File header>>

submodule (prc_external) prc_external_s

<<Use debug>>
  use io_units
  use pdg_arrays, only: is_gluon, is_quark
  use system_defs, only: TAB
  use physics_defs, only: CF
  use diagnostics
  use prc_omega, only: omega_state_t

  implicit none

<<Prc external: parameters>>

contains

<<Prc external: procedures>>

end submodule prc_external_s

@ %def prc_external_s
@
\subsection{Handling of structure functions}
External matrix elements do not have access to the structure functions
stored in the evaluators. The current solution to this problem is to
just apply them explicitly after the computation of the matrix element.
<<Prc external: parameters>>=
  integer, parameter :: LEPTONS = 1
  integer, parameter :: HADRONS = 2
<<Prc external: types>>=
  type :: sf_handler_t
     integer :: initial_state_type = 0
     integer :: n_sf = -1
     real(default) :: val = one
  contains
  <<Prc external: sf handler: TBP>>
  end type sf_handler_t

@ %def sf_handler_t
@
<<Prc external: sf handler: TBP>>=
  procedure :: init => sf_handler_init
<<Prc external: sub interfaces>>=
    module subroutine sf_handler_init (sf_handler, sf_chain)
      class(sf_handler_t), intent(out) :: sf_handler
      type(sf_chain_instance_t), intent(in) :: sf_chain
    end subroutine sf_handler_init
<<Prc external: procedures>>=
  module subroutine sf_handler_init (sf_handler, sf_chain)
    class(sf_handler_t), intent(out) :: sf_handler
    type(sf_chain_instance_t), intent(in) :: sf_chain
    integer :: i
    sf_handler%n_sf = size (sf_chain%sf)
    if (sf_handler%n_sf == 0) then
       sf_handler%initial_state_type = LEPTONS
    else
       do i = 1, sf_handler%n_sf
          select type (int => sf_chain%sf(i)%int)
          type is (pdf_builtin_t)
             sf_handler%initial_state_type = HADRONS
          type is (lhapdf_t)
             sf_handler%initial_state_type = HADRONS
          class default
             sf_handler%initial_state_type = LEPTONS
          end select
       end do
     end if
  end subroutine sf_handler_init

@ %def sf_handler_init
@
<<Prc external: sf handler: TBP>>=
  procedure :: init_dummy => sf_handler_init_dummy
<<Prc external: sub interfaces>>=
    module subroutine sf_handler_init_dummy (sf_handler)
      class(sf_handler_t), intent(out) :: sf_handler
    end subroutine sf_handler_init_dummy
<<Prc external: procedures>>=
  module subroutine sf_handler_init_dummy (sf_handler)
    class(sf_handler_t), intent(out) :: sf_handler
    sf_handler%n_sf = 0
    sf_handler%initial_state_type = LEPTONS
  end subroutine sf_handler_init_dummy

@ %def sf_handler_init_dummy
@
<<Prc external: sf handler: TBP>>=
  procedure :: apply_structure_functions => &
       sf_handler_apply_structure_functions
<<Prc external: sub interfaces>>=
    module subroutine sf_handler_apply_structure_functions &
         (sf_handler, sf_chain, flavors)
       class(sf_handler_t), intent(inout) :: sf_handler
       type(sf_chain_instance_t), intent(in) :: sf_chain
       integer, intent(in), dimension(2) :: flavors
    end subroutine sf_handler_apply_structure_functions
<<Prc external: procedures>>=
  module subroutine sf_handler_apply_structure_functions &
       (sf_handler, sf_chain, flavors)
     class(sf_handler_t), intent(inout) :: sf_handler
     type(sf_chain_instance_t), intent(in) :: sf_chain
     integer, intent(in), dimension(2) :: flavors
     integer :: i
     real(default), dimension(:), allocatable :: f
     if (sf_handler%n_sf < 0) call msg_fatal ("sf_handler not initialized")
     sf_handler%val = one
     do i = 1, sf_handler%n_sf
        select case (sf_handler%initial_state_type)
        case (HADRONS)
           sf_handler%val = sf_handler%val * &
                sf_handler%get_pdf (sf_chain, i, flavors(i))
        case (LEPTONS)
           call sf_chain%get_matrix_elements (i, f)
           sf_handler%val = sf_handler%val * f(1)
        case default
           call msg_fatal ("sf_handler not initialized")
        end select
     end do
  end subroutine sf_handler_apply_structure_functions

@ %def sf_handler_apply_structure_functions
@
<<Prc external: sf handler: TBP>>=
  procedure :: get_pdf => sf_handler_get_pdf
<<Prc external: sub interfaces>>=
    module function sf_handler_get_pdf &
         (sf_handler, sf_chain, i, flavor) result (f)
       real(default) :: f
       class(sf_handler_t), intent(in) :: sf_handler
       type(sf_chain_instance_t), intent(in) :: sf_chain
       integer, intent(in) :: i, flavor
    end function sf_handler_get_pdf
<<Prc external: procedures>>=
  module function sf_handler_get_pdf &
       (sf_handler, sf_chain, i, flavor) result (f)
     real(default) :: f
     class(sf_handler_t), intent(in) :: sf_handler
     type(sf_chain_instance_t), intent(in) :: sf_chain
     integer, intent(in) :: i, flavor
     integer :: k
     real(default), dimension(:), allocatable :: ff
     integer, parameter :: n_flv_light = 6

     call sf_chain%get_matrix_elements (i, ff)

     if (is_gluon (flavor)) then
        k = n_flv_light + 1
     else if (is_quark (abs(flavor))) then
        k = n_flv_light + 1 + flavor
     else
        call msg_fatal ("Not a colored particle")
     end if

     f = ff(k)
  end function sf_handler_get_pdf

@ %def sf_handler_get_pdf
@
\subsection{Abstract interface to external matrix elements}
This process class allows us to factor out common necessities of processes
that involve external code or libraries.

\subsubsection{Workspace}
This is the workspace that is available for external matrix elements.
<<Prc external: public>>=
  public :: prc_external_state_t
<<Prc external: types>>=
  type, abstract, extends (prc_core_state_t) :: prc_external_state_t
    logical :: new_kinematics = .true.
    real(default) :: alpha_qcd = -1
    real(default) :: alpha_qed = -1
  contains
  <<Prc external: external state: TBP>>
  end type prc_external_state_t

@ %def prc_external_state_t
@
<<Prc external: external state: TBP>>=
  procedure :: reset_new_kinematics => prc_external_state_reset_new_kinematics
<<Prc external: sub interfaces>>=
    module subroutine prc_external_state_reset_new_kinematics (object)
      class(prc_external_state_t), intent(inout) :: object
    end subroutine prc_external_state_reset_new_kinematics
<<Prc external: procedures>>=
  module subroutine prc_external_state_reset_new_kinematics (object)
    class(prc_external_state_t), intent(inout) :: object
    object%new_kinematics = .true.
  end subroutine prc_external_state_reset_new_kinematics

@ %def prc_external_state_reset_new_kinematics
@
\subsubsection{Driver}
We have to add two O'Mega-routines to the external matrix-element driver to
ensure proper process setup.  The problem is that during the setup of
the real component, the particle and flavor data are taken from the Born
component to set up the subtraction terms.  However, the Born component
expects this data to be obtained from the Omega code, accessed by the
driver.
<<Prc external: public>>=
  public :: prc_external_driver_t
<<Prc external: types>>=
  type, abstract, extends (prc_core_driver_t) :: prc_external_driver_t
     procedure(omega_update_alpha_s), nopass, pointer :: &
              update_alpha_s => null ()
     procedure(omega_is_allowed), nopass, pointer :: &
              is_allowed => null ()
  end type prc_external_driver_t

@ %def prc_external_driver_t
@
\subsubsection{Core}
<<Prc external: public>>=
  public :: prc_external_t
<<Prc external: types>>=
  type, abstract, extends (prc_core_t) :: prc_external_t
    type(qcd_t) :: qcd
    type(qed_t) :: qed
    integer :: n_flv = 1
    real(default), dimension(:), allocatable :: par
    integer :: scheme = 0
    type(sf_handler_t) :: sf_handler
    real(default) :: maximum_accuracy = 10000.0
  contains
  <<Prc external: prc external: TBP>>
  end type prc_external_t

@ %def prc_external_t
@ By definition, this class of process-core types require extra code.
<<Prc external: prc external: TBP>>=
  procedure, nopass :: needs_external_code => &
       prc_external_needs_external_code
<<Prc external: sub interfaces>>=
    module function prc_external_needs_external_code () result (flag)
      logical :: flag
    end function prc_external_needs_external_code
<<Prc external: procedures>>=
  module function prc_external_needs_external_code () result (flag)
    logical :: flag
    flag = .true.
  end function prc_external_needs_external_code

@ %def prc_external_needs_external_code
@
<<Prc external: prc external: TBP>>=
  procedure :: get_n_flvs => prc_external_get_n_flvs
<<Prc external: sub interfaces>>=
    pure module function prc_external_get_n_flvs (object, i_flv) result (n)
      integer :: n
      class(prc_external_t), intent(in) :: object
      integer, intent(in) :: i_flv
    end function prc_external_get_n_flvs
<<Prc external: procedures>>=
  pure module function prc_external_get_n_flvs (object, i_flv) result (n)
    integer :: n
    class(prc_external_t), intent(in) :: object
    integer, intent(in) :: i_flv
    n = size (object%data%flv_state (:,i_flv))
  end function prc_external_get_n_flvs

@ %def prc_external_get_n_flvs
@
<<Prc external: prc external: TBP>>=
  procedure :: get_flv_state => prc_external_get_flv_state
<<Prc external: sub interfaces>>=
    module function prc_external_get_flv_state (object, i_flv) result (flv)
      integer, dimension(:), allocatable :: flv
      class(prc_external_t), intent(in) :: object
      integer, intent(in) :: i_flv
    end function prc_external_get_flv_state
<<Prc external: procedures>>=
  module function prc_external_get_flv_state (object, i_flv) result (flv)
    integer, dimension(:), allocatable :: flv
    class(prc_external_t), intent(in) :: object
    integer, intent(in) :: i_flv
    allocate (flv (size (object%data%flv_state (:,i_flv))))
    flv = object%data%flv_state (:,i_flv)
  end function prc_external_get_flv_state

@ %def prc_external_get_flv_state
@ Return one single squared test matrix element. It is fixed to 1,
therefore the integration output will be the phase space volume.
<<Prc external: prc external: TBP>>=
  procedure :: compute_sqme => prc_external_compute_sqme
<<Prc external: sub interfaces>>=
    module subroutine prc_external_compute_sqme (object, i_flv, i_hel, p, &
           ren_scale, sqme, bad_point)
       class(prc_external_t), intent(in) :: object
       integer, intent(in) :: i_flv, i_hel
       type(vector4_t), dimension(:), intent(in) :: p
       real(default), intent(in) :: ren_scale
       real(default), intent(out) :: sqme
       logical, intent(out) :: bad_point
    end subroutine prc_external_compute_sqme
<<Prc external: procedures>>=
  module subroutine prc_external_compute_sqme (object, i_flv, i_hel, p, &
         ren_scale, sqme, bad_point)
     class(prc_external_t), intent(in) :: object
     integer, intent(in) :: i_flv, i_hel
     type(vector4_t), dimension(:), intent(in) :: p
     real(default), intent(in) :: ren_scale
     real(default), intent(out) :: sqme
     logical, intent(out) :: bad_point
     sqme = one
     bad_point = .false.
  end subroutine prc_external_compute_sqme

@ %def prc_external_compute_sqme
@ Return an array of 4 numbers corresponding to the BLHA output convention.
Used for testing.
<<Prc external: prc external: TBP>>=
  procedure :: compute_sqme_virt => prc_external_compute_sqme_virt
<<Prc external: sub interfaces>>=
    module subroutine prc_external_compute_sqme_virt (object, i_flv, i_hel, &
       p, ren_scale, es_scale, loop_method, sqme, bad_point)
      class(prc_external_t), intent(in) :: object
      integer, intent(in) :: i_flv, i_hel
      type(vector4_t), dimension(:), intent(in) :: p
      real(default), intent(in) :: ren_scale, es_scale
      integer, intent(in) :: loop_method
      logical, intent(out) :: bad_point
      real(default), dimension(4), intent(out) :: sqme
    end subroutine prc_external_compute_sqme_virt
<<Prc external: procedures>>=
  module subroutine prc_external_compute_sqme_virt (object, i_flv, i_hel, &
     p, ren_scale, es_scale, loop_method, sqme, bad_point)
    class(prc_external_t), intent(in) :: object
    integer, intent(in) :: i_flv, i_hel
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), intent(in) :: ren_scale, es_scale
    integer, intent(in) :: loop_method
    logical, intent(out) :: bad_point
    real(default), dimension(4), intent(out) :: sqme
    if (debug_on) call msg_debug2 &
         (D_ME_METHODS, "prc_external_compute_sqme_virt")
    sqme(1) = 0.001_default
    sqme(2) = 0.001_default
    sqme(3) = 0.001_default
    sqme(4) = 0.0015_default
    bad_point = .false.
  end subroutine prc_external_compute_sqme_virt

@ %def prc_external_compute_sqme_virt
@ Also return test output for color-correlated matrix elements. We only
  give a sensible result for the processes used in the functional tests,
  which have 2 -> 2 topology. All other processes will obtain a vanishing
  dummy color-correlation. This effectively switches off the subtraction
  contributions, reproducing the real phase-space volume.
<<Prc external: prc external: TBP>>=
  procedure :: compute_sqme_color_c => prc_external_compute_sqme_color_c
<<Prc external: sub interfaces>>=
    module subroutine prc_external_compute_sqme_color_c (object, i_flv, &
         i_hel, p, ren_scale, born_color_c, bad_point, born_out)
      class(prc_external_t), intent(inout) :: object
      integer, intent(in) :: i_flv, i_hel
      type(vector4_t), intent(in), dimension(:) :: p
      real(default), intent(in) :: ren_scale
      real(default), intent(inout), dimension(:,:) :: born_color_c
      logical, intent(out) :: bad_point
      real(default), intent(out), optional :: born_out
    end subroutine prc_external_compute_sqme_color_c
<<Prc external: procedures>>=
  module subroutine prc_external_compute_sqme_color_c (object, i_flv, &
       i_hel, p, ren_scale, born_color_c, bad_point, born_out)
    class(prc_external_t), intent(inout) :: object
    integer, intent(in) :: i_flv, i_hel
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale
    real(default), intent(inout), dimension(:,:) :: born_color_c
    logical, intent(out) :: bad_point
    real(default), intent(out), optional :: born_out
    if (debug_on) call msg_debug2 (D_ME_METHODS, "prc_external_compute_sqme_color_c")
    if (size (p) == 4) then
       if (present (born_out)) then
          born_out = 0.0015_default
          born_color_c = zero
          born_color_c(3,3) = - CF * born_out
          born_color_c(4,4) = - CF * born_out
          born_color_c(3,4) = CF * born_out
          born_color_c(4,3) = born_color_c(3,4)
          bad_point = .false.
       end if
    else
       if (present (born_out)) born_out = zero
       born_color_c = zero
    end if
  end subroutine prc_external_compute_sqme_color_c

@ %def prc_external_compute_sqme_color_c
@
<<Prc external: prc external: TBP>>=
  procedure :: compute_alpha_s => prc_external_compute_alpha_s
<<Prc external: sub interfaces>>=
    module subroutine prc_external_compute_alpha_s &
         (object, core_state, ren_scale)
      class(prc_external_t), intent(in) :: object
      class(prc_external_state_t), intent(inout) :: core_state
      real(default), intent(in) :: ren_scale
    end subroutine prc_external_compute_alpha_s
<<Prc external: procedures>>=
  module subroutine prc_external_compute_alpha_s &
       (object, core_state, ren_scale)
    class(prc_external_t), intent(in) :: object
    class(prc_external_state_t), intent(inout) :: core_state
    real(default), intent(in) :: ren_scale
    core_state%alpha_qcd = object%qcd%alpha%get (ren_scale)
  end subroutine prc_external_compute_alpha_s

@ %def prc_external_compute_alpha_s
@
<<Prc external: prc external: TBP>>=
  procedure :: get_alpha_s => prc_external_get_alpha_s
<<Prc external: sub interfaces>>=
    module function prc_external_get_alpha_s &
         (object, core_state) result (alpha_qcd)
      class(prc_external_t), intent(in) :: object
      class(prc_core_state_t), intent(in), allocatable :: core_state
      real(default) :: alpha_qcd
    end function prc_external_get_alpha_s
<<Prc external: procedures>>=
  module function prc_external_get_alpha_s &
       (object, core_state) result (alpha_qcd)
    class(prc_external_t), intent(in) :: object
    class(prc_core_state_t), intent(in), allocatable :: core_state
    real(default) :: alpha_qcd
    if (allocated (core_state)) then
      select type (core_state)
      class is (prc_external_state_t)
         alpha_qcd = core_state%alpha_qcd
      type is (omega_state_t)
         alpha_qcd = core_state%alpha_qcd
      class default
         alpha_qcd = zero
      end select
    else
       alpha_qcd = zero
    end if
  end function prc_external_get_alpha_s

@ %def prc_external_get_alpha_s
@ Getter for [[alpha_qed]]
<<Prc external: prc external: TBP>>=
  procedure :: get_alpha_qed => prc_external_get_alpha_qed
<<Prc external: sub interfaces>>=
    module function prc_external_get_alpha_qed &
         (object, core_state) result (alpha_qed)
      class(prc_external_t), intent(in) :: object
      class(prc_core_state_t), intent(in), allocatable :: core_state
      real(default) :: alpha_qed
    end function prc_external_get_alpha_qed
<<Prc external: procedures>>=
  module function prc_external_get_alpha_qed &
       (object, core_state) result (alpha_qed)
    class(prc_external_t), intent(in) :: object
    class(prc_core_state_t), intent(in), allocatable :: core_state
    real(default) :: alpha_qed
    if (allocated (core_state)) then
       select type (core_state)
       class is (prc_external_state_t)
          alpha_qed = core_state%alpha_qed
       type is (omega_state_t)
          alpha_qed = core_state%alpha_qed
       class default
          alpha_qed = zero
       end select
    else
       alpha_qed = zero
    end if
  end function prc_external_get_alpha_qed

@ %def prc_external_get_alpha_qed
@
<<Prc external: prc external: TBP>>=
  procedure :: is_allowed => prc_external_is_allowed
<<Prc external: sub interfaces>>=
    module function prc_external_is_allowed &
         (object, i_term, f, h, c) result (flag)
      class(prc_external_t), intent(in) :: object
      integer, intent(in) :: i_term, f, h, c
      logical :: flag
    end function prc_external_is_allowed
<<Prc external: procedures>>=
  module function prc_external_is_allowed &
       (object, i_term, f, h, c) result (flag)
    class(prc_external_t), intent(in) :: object
    integer, intent(in) :: i_term, f, h, c
    logical :: flag
    logical(c_bool) :: cflag
    select type (driver => object%driver)
    class is (prc_external_driver_t)
       call driver%is_allowed (f, h, c, cflag)
       flag = cflag
    class default
       call msg_fatal &
          ("Driver does not fit to prc_external_t")
    end select
  end function prc_external_is_allowed

@
@ %def prc_external_is_allowed
<<Prc external: prc external: TBP>>=
  procedure :: get_nflv => prc_external_get_nflv
<<Prc external: sub interfaces>>=
    module function prc_external_get_nflv (object) result (n_flv)
      class(prc_external_t), intent(in) :: object
      integer :: n_flv
    end function prc_external_get_nflv
<<Prc external: procedures>>=
  module function prc_external_get_nflv (object) result (n_flv)
    class(prc_external_t), intent(in) :: object
    integer :: n_flv
    n_flv = object%n_flv
  end function prc_external_get_nflv

@ %def prc_external_get_nflv
@
<<Prc external: prc external: TBP>>=
  procedure :: compute_hard_kinematics => prc_external_compute_hard_kinematics
<<Prc external: sub interfaces>>=
    module subroutine prc_external_compute_hard_kinematics &
         (object, p_seed, i_term, int_hard, core_state)
      class(prc_external_t), intent(in) :: object
      type(vector4_t), dimension(:), intent(in) :: p_seed
      integer, intent(in) :: i_term
      type(interaction_t), intent(inout) :: int_hard
      class(prc_core_state_t), intent(inout), allocatable :: core_state
    end subroutine prc_external_compute_hard_kinematics
<<Prc external: procedures>>=
  module subroutine prc_external_compute_hard_kinematics &
       (object, p_seed, i_term, int_hard, core_state)
    class(prc_external_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p_seed
    integer, intent(in) :: i_term
    type(interaction_t), intent(inout) :: int_hard
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    call int_hard%set_momenta (p_seed)
    if (allocated (core_state)) then
      select type (core_state)
      class is (prc_external_state_t); core_state%new_kinematics = .true.
      end select
    end if
  end subroutine prc_external_compute_hard_kinematics

@
@ %def prc_external_compute_hard_kinematics
<<Prc external: prc external: TBP>>=
  procedure :: compute_eff_kinematics => prc_external_compute_eff_kinematics
<<Prc external: sub interfaces>>=
    module subroutine prc_external_compute_eff_kinematics &
         (object, i_term, int_hard, int_eff, core_state)
      class(prc_external_t), intent(in) :: object
      integer, intent(in) :: i_term
      type(interaction_t), intent(in) :: int_hard
      type(interaction_t), intent(inout) :: int_eff
      class(prc_core_state_t), intent(inout), allocatable :: core_state
    end subroutine prc_external_compute_eff_kinematics
<<Prc external: procedures>>=
  module subroutine prc_external_compute_eff_kinematics &
       (object, i_term, int_hard, int_eff, core_state)
    class(prc_external_t), intent(in) :: object
    integer, intent(in) :: i_term
    type(interaction_t), intent(in) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
  end subroutine prc_external_compute_eff_kinematics

@ %def prc_external_compute_eff_kinematics
@ Gfortran 7/8/9 bug, has to remain in the main module.
<<Prc external: prc external: TBP>>=
  procedure :: set_parameters => prc_external_set_parameters
<<Prc external: main procedures>>=
  subroutine prc_external_set_parameters (object, qcd, model)
    class(prc_external_t), intent(inout) :: object
    type(qcd_t), intent(in) :: qcd
    type(qed_t) :: qed
    class(model_data_t), intent(in), target, optional :: model
    object%qcd = qcd
    if (present (model)) then
       if (.not. allocated (object%par)) &
            allocate (object%par (model%get_n_real ()))
       call model%real_parameters_to_array (object%par)
       object%scheme = model%get_scheme_num ()
       if (associated (model%get_par_data_ptr (var_str ('alpha_em_i')))) then
          allocate (alpha_qed_fixed_t :: qed%alpha)
          select type (alpha => qed%alpha)
          type is (alpha_qed_fixed_t)
             alpha%val = one / model%get_real (var_str ('alpha_em_i'))
          end select
       end if
       object%qed = qed
    end if
  end subroutine prc_external_set_parameters

@ %def prc_external_set_parameters
@
<<Prc external: prc external: TBP>>=
  procedure :: update_alpha_s => prc_external_update_alpha_s
<<Prc external: sub interfaces>>=
    module subroutine prc_external_update_alpha_s (object, core_state, scale)
      class(prc_external_t), intent(in) :: object
      class(prc_core_state_t), intent(inout), allocatable :: core_state
      real(default), intent(in) :: scale
    end subroutine prc_external_update_alpha_s
<<Prc external: procedures>>=
  module subroutine prc_external_update_alpha_s (object, core_state, scale)
    class(prc_external_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    real(default), intent(in) :: scale
    real(default) :: alpha_qcd
    if (allocated (object%qcd%alpha)) then
       alpha_qcd = object%qcd%alpha%get (scale)
       select type (driver => object%driver)
       class is (prc_external_driver_t)
          call driver%update_alpha_s (alpha_qcd)
       end select
       select type (core_state)
       class is (prc_external_state_t)
          core_state%alpha_qcd = alpha_qcd
       type is (omega_state_t)
          core_state%alpha_qcd = alpha_qcd
       end select
    end if
  end subroutine prc_external_update_alpha_s

@ %def prc_external_update_alpha_s
@
<<Prc external: prc external: TBP>>=
  procedure :: init_sf_handler => prc_external_init_sf_handler
<<Prc external: sub interfaces>>=
    module subroutine prc_external_init_sf_handler (core, sf_chain)
       class(prc_external_t), intent(inout) :: core
       type(sf_chain_instance_t), intent(in) :: sf_chain
    end subroutine prc_external_init_sf_handler
<<Prc external: procedures>>=
  module subroutine prc_external_init_sf_handler (core, sf_chain)
     class(prc_external_t), intent(inout) :: core
     type(sf_chain_instance_t), intent(in) :: sf_chain
     if (allocated (sf_chain%sf)) then
        call core%sf_handler%init (sf_chain)
     else
        call core%sf_handler%init_dummy ()
     end if
  end subroutine prc_external_init_sf_handler

@ %def prc_external_init_sf_handler
@
<<Prc external: prc external: TBP>>=
  procedure :: init_sf_handler_dummy => prc_external_init_sf_handler_dummy
<<Prc external: sub interfaces>>=
    module subroutine prc_external_init_sf_handler_dummy (core)
       class(prc_external_t), intent(inout) :: core
    end subroutine prc_external_init_sf_handler_dummy
<<Prc external: procedures>>=
  module subroutine prc_external_init_sf_handler_dummy (core)
     class(prc_external_t), intent(inout) :: core
     call core%sf_handler%init_dummy ()
  end subroutine prc_external_init_sf_handler_dummy

@ %def prc_external_init_sf_handler_dummy
@
<<Prc external: prc external: TBP>>=
  procedure :: apply_structure_functions => &
       prc_external_apply_structure_functions
<<Prc external: sub interfaces>>=
    module subroutine prc_external_apply_structure_functions &
         (core, sf_chain, flavors)
      class(prc_external_t), intent(inout) :: core
      type(sf_chain_instance_t), intent(in) :: sf_chain
      integer, dimension(2), intent(in) :: flavors
    end subroutine prc_external_apply_structure_functions
<<Prc external: procedures>>=
  module subroutine prc_external_apply_structure_functions &
       (core, sf_chain, flavors)
    class(prc_external_t), intent(inout) :: core
    type(sf_chain_instance_t), intent(in) :: sf_chain
    integer, dimension(2), intent(in) :: flavors
    call core%sf_handler%apply_structure_functions (sf_chain, flavors)
  end subroutine prc_external_apply_structure_functions

@ %def prc_external_apply_structure_functions
@
<<Prc external: prc external: TBP>>=
  procedure :: get_sf_value => prc_external_get_sf_value
<<Prc external: sub interfaces>>=
    module function prc_external_get_sf_value (core) result (val)
      real(default) :: val
      class(prc_external_t), intent(in) :: core
    end function prc_external_get_sf_value
<<Prc external: procedures>>=
  module function prc_external_get_sf_value (core) result (val)
    real(default) :: val
    class(prc_external_t), intent(in) :: core
    val = core%sf_handler%val
  end function prc_external_get_sf_value

@ %def prc_external_get_sf_value
@
<<Prc external: prc external: TBP>>=
  procedure(prc_external_includes_polarization), deferred :: &
    includes_polarization
<<Prc external: interfaces>>=
  abstract interface
    function prc_external_includes_polarization (object) result (polarized)
      import
      logical :: polarized
      class(prc_external_t), intent(in) :: object
    end function prc_external_includes_polarization
  end interface

@ %def prc_external_includes_polarization
@
\subsubsection{Configuration}
This is the abstract external matrix-element interface.
<<Prc external: public>>=
  public :: prc_external_def_t
<<Prc external: types>>=
  type, abstract, extends (prc_core_def_t) :: prc_external_def_t
    type(string_t) :: basename
  contains
  <<Prc external: external def: TBP>>
  end type prc_external_def_t

@ %def prc_external_def_t
@
<<Prc external: external def: TBP>>=
  procedure :: set_active_writer => prc_external_def_set_active_writer
<<Prc external: sub interfaces>>=
    module subroutine prc_external_def_set_active_writer (def, active)
      class(prc_external_def_t), intent(inout) :: def
      logical, intent(in) :: active
    end subroutine prc_external_def_set_active_writer
<<Prc external: procedures>>=
  module subroutine prc_external_def_set_active_writer (def, active)
    class(prc_external_def_t), intent(inout) :: def
    logical, intent(in) :: active
    select type (writer => def%writer)
    class is (prc_external_writer_t)
       writer%active = active
    end select
  end subroutine prc_external_def_set_active_writer

@ %def_prc_external_def_set_active_writer
@
<<Prc external: external def: TBP>>=
  procedure, nopass :: get_features => prc_external_def_get_features
<<Prc external: sub interfaces>>=
    module subroutine prc_external_def_get_features (features)
      type(string_t), dimension(:), allocatable, intent(out) :: features
    end subroutine prc_external_def_get_features
<<Prc external: procedures>>=
  module subroutine prc_external_def_get_features (features)
    type(string_t), dimension(:), allocatable, intent(out) :: features
    allocate (features (6))
    features = [ &
         var_str ("init"), &
         var_str ("update_alpha_s"), &
         var_str ("reset_helicity_selection"), &
         var_str ("is_allowed"), &
         var_str ("new_event"), &
         var_str ("get_amplitude")]
  end subroutine prc_external_def_get_features

@
@ %def prc_external_def_get_features
<<Prc external: external def: TBP>>=
  procedure :: connect => prc_external_def_connect
  procedure :: omega_connect => prc_external_def_connect
<<Prc external: sub interfaces>>=
    module subroutine prc_external_def_connect (def, lib_driver, i, proc_driver)
      class(prc_external_def_t), intent(in) :: def
      class(prclib_driver_t), intent(in) :: lib_driver
      integer, intent(in) :: i
      class(prc_core_driver_t), intent(inout) :: proc_driver
    end subroutine prc_external_def_connect
<<Prc external: procedures>>=
  module subroutine prc_external_def_connect (def, lib_driver, i, proc_driver)
    class(prc_external_def_t), intent(in) :: def
    class(prclib_driver_t), intent(in) :: lib_driver
    integer, intent(in) :: i
    class(prc_core_driver_t), intent(inout) :: proc_driver
    integer :: pid, fid
    type(c_funptr) :: fptr
    select type (proc_driver)
    class is (prc_external_driver_t)
       pid = i
       fid = 2
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%update_alpha_s)
       fid = 4
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%is_allowed)
    end select
  end subroutine prc_external_def_connect

@ %def prc_external_def_connect
@
<<Prc external: external def: TBP>>=
  procedure, nopass :: needs_code => prc_external_def_needs_code
<<Prc external: sub interfaces>>=
    module function prc_external_def_needs_code () result (flag)
      logical :: flag
    end function prc_external_def_needs_code
<<Prc external: procedures>>=
  module function prc_external_def_needs_code () result (flag)
    logical :: flag
    flag = .true.
  end function prc_external_def_needs_code

@  %def prc_external_def_needs_code
@
<<Prc external: interfaces>>=
  abstract interface
     subroutine omega_update_alpha_s (alpha_s) bind(C)
       import
       real(c_default_float), intent(in) :: alpha_s
     end subroutine omega_update_alpha_s
  end interface

  abstract interface
     subroutine omega_is_allowed (flv, hel, col, flag) bind(C)
       import
       integer(c_int), intent(in) :: flv, hel, col
       logical(c_bool), intent(out) :: flag
     end subroutine omega_is_allowed
  end interface

@ %def omega-interfaces
@
\subsubsection{Writer}
<<Prc external: public>>=
  public :: prc_external_writer_t
<<Prc external: types>>=
  type, abstract, extends (prc_writer_f_module_t) :: prc_external_writer_t
    type(string_t) :: model_name
    type(string_t) :: process_mode
    type(string_t) :: process_string
    type(string_t) :: restrictions
    integer :: n_in = 0
    integer :: n_out = 0
    logical :: active = .true.
    logical :: amp_triv = .true.
  contains
  <<Prc external: external writer: TBP>>
  end type prc_external_writer_t

@ %def prc_external_writer_t
@
<<Prc external: external writer: TBP>>=
  procedure :: init => prc_external_writer_init
  procedure :: base_init => prc_external_writer_init
<<Prc external: sub interfaces>>=
    pure module subroutine prc_external_writer_init &
         (writer, model_name, prt_in, prt_out, restrictions)
      class(prc_external_writer_t), intent(inout) :: writer
      type(string_t), intent(in) :: model_name
      type(string_t), dimension(:), intent(in) :: prt_in, prt_out
      type(string_t), intent(in), optional :: restrictions
    end subroutine prc_external_writer_init
<<Prc external: procedures>>=
  pure module subroutine prc_external_writer_init &
       (writer, model_name, prt_in, prt_out, restrictions)
    class(prc_external_writer_t), intent(inout) :: writer
    type(string_t), intent(in) :: model_name
    type(string_t), dimension(:), intent(in) :: prt_in, prt_out
    type(string_t), intent(in), optional :: restrictions
    integer :: i
    writer%model_name = model_name
    if (present (restrictions)) then
       writer%restrictions = restrictions
    else
       writer%restrictions = ""
    end if
    writer%n_in = size (prt_in)
    writer%n_out = size (prt_out)
    select case (size (prt_in))
       case(1); writer%process_mode = " -decay"
       case(2); writer%process_mode = " -scatter"
    end select
    associate (s => writer%process_string)
      s = " '"
      do i = 1, size (prt_in)
         if (i > 1) s = s // " "
         s = s // prt_in(i)
      end do
      s = s // " ->"
      do i = 1, size (prt_out)
         s = s // " " // prt_out(i)
      end do
      s = s // "'"
    end associate
  end subroutine prc_external_writer_init

@ %def prc_external_writer_init
@
<<Prc external: external writer: TBP>>=
  procedure, nopass :: get_module_name => prc_external_writer_get_module_name
<<Prc external: sub interfaces>>=
    module function prc_external_writer_get_module_name (id) result (name)
      type(string_t) :: name
      type(string_t), intent(in) :: id
    end function prc_external_writer_get_module_name
<<Prc external: procedures>>=
  module function prc_external_writer_get_module_name (id) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: id
    name = "opr_" // id
  end function prc_external_writer_get_module_name

@ %def prc_external_writer_get_module_name
@
<<Prc external: external writer: TBP>>=
  procedure :: write_wrapper => prc_external_writer_write_wrapper
<<Prc external: sub interfaces>>=
    module subroutine prc_external_writer_write_wrapper &
         (writer, unit, id, feature)
      class(prc_external_writer_t), intent(in) :: writer
      integer, intent(in) :: unit
      type(string_t), intent(in) :: id, feature
    end subroutine prc_external_writer_write_wrapper
<<Prc external: procedures>>=
  module subroutine prc_external_writer_write_wrapper &
       (writer, unit, id, feature)
    class(prc_external_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id, feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, *)
    select case (char (feature))
    case ("init")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (par, scheme) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: scheme"
       if (c_default_float == default .and. c_int == kind (1)) then
          write (unit, "(2x,9A)")  "call ", char (feature), " (par, scheme)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: alpha_s"
          write (unit, "(2x,9A)")  "call ", char (feature), " (alpha_s)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("reset_helicity_selection")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (threshold, cutoff) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: threshold"
          write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: cutoff"
          write (unit, "(2x,9A)")  "call ", char (feature), &
               " (threshold, int (cutoff))"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, flag) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "logical(c_bool), intent(out) :: flag"
       write (unit, "(2x,9A)")  "flag = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), dimension(0:3,*), &
               &intent(in) :: p"
          write (unit, "(2x,9A)")  "call ", char (feature), " (p)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, amp) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"
       write (unit, "(2x,9A)")  "amp = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    end select

  end subroutine prc_external_writer_write_wrapper

@
@ %def prc_external_writer_write_wrapper
<<Prc external: external writer: TBP>>=
  procedure :: write_interface => prc_external_writer_write_interface
<<Prc external: sub interfaces>>=
    module subroutine prc_external_writer_write_interface &
         (writer, unit, id, feature)
      class(prc_external_writer_t), intent(in) :: writer
      integer, intent(in) :: unit
      type(string_t), intent(in) :: id
      type(string_t), intent(in) :: feature
    end subroutine prc_external_writer_write_interface
<<Prc external: procedures>>=
  module subroutine prc_external_writer_write_interface &
       (writer, unit, id, feature)
    class(prc_external_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(string_t), intent(in) :: feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, "(2x,9A)")  "interface"
    select case (char (feature))
    case ("init")
       write (unit, "(5x,9A)")  "subroutine ", char (name), &
            " (par, scheme) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: scheme"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: alpha_s"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("reset_helicity_selection")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(threshold, cutoff) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: threshold"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: cutoff"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, flag) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "logical(c_bool), intent(out) :: flag"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(0:3,*), &
            &intent(in) :: p"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, amp) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    end select
    write (unit, "(2x,9A)")  "end interface"
  end subroutine prc_external_writer_write_interface

@ %def prc_external_writer_write_interface
@ Empty, but can be overridden.
<<Prc external: external writer: TBP>>=
  procedure :: write_source_code => prc_external_writer_write_source_code
<<Prc external: sub interfaces>>=
    module subroutine prc_external_writer_write_source_code (writer, id)
      class(prc_external_writer_t), intent(in) :: writer
      type(string_t), intent(in) :: id
    end subroutine prc_external_writer_write_source_code
<<Prc external: procedures>>=
  module subroutine prc_external_writer_write_source_code (writer, id)
    class(prc_external_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
    if (debug_on) call msg_debug (D_ME_METHODS, &
         "prc_external_writer_write_source_code (no-op)")
    !!! This is a dummy
  end subroutine prc_external_writer_write_source_code

@ %def prc_external_writer_write_source_code
@ Empty, but can be overridden.
<<Prc external: external writer: TBP>>=
  procedure :: before_compile => prc_external_writer_before_compile
  procedure :: after_compile => prc_external_writer_after_compile
<<Prc external: sub interfaces>>=
    module subroutine prc_external_writer_before_compile (writer, id)
      class(prc_external_writer_t), intent(in) :: writer
      type(string_t), intent(in) :: id
    end subroutine prc_external_writer_before_compile
    module subroutine prc_external_writer_after_compile (writer, id)
      class(prc_external_writer_t), intent(in) :: writer
      type(string_t), intent(in) :: id
    end subroutine prc_external_writer_after_compile
<<Prc external: procedures>>=
  module subroutine prc_external_writer_before_compile (writer, id)
    class(prc_external_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
    if (debug_on) call msg_debug (D_ME_METHODS, &
         "prc_external_writer_before_compile (no-op)")
    !!! This is a dummy
  end subroutine prc_external_writer_before_compile

  module subroutine prc_external_writer_after_compile (writer, id)
    class(prc_external_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
    if (debug_on) call msg_debug (D_ME_METHODS, &
         "prc_external_writer_after_compile (no-op)")
    !!! This is a dummy
  end subroutine prc_external_writer_after_compile

@ %def prc_external_writer_before_compile
@ %def prc_external_writer_after_compile
@ Standard Makefile, set up to call \oMega.  Additionally, the \oMega\ output
can be exploited for its data-management parts.
<<Prc external: external writer: TBP>>=
  procedure :: write_makefile_code => prc_external_writer_write_makefile_code
  procedure :: base_write_makefile_code => &
       prc_external_writer_write_makefile_code
<<Prc external: sub interfaces>>=
    module subroutine prc_external_writer_write_makefile_code &
         (writer, unit, id, os_data, verbose, testflag)
      class(prc_external_writer_t), intent(in) :: writer
      integer, intent(in) :: unit
      type(string_t), intent(in) :: id
      type(os_data_t), intent(in) :: os_data
      logical, intent(in) :: verbose
      logical, intent(in), optional :: testflag
    end subroutine prc_external_writer_write_makefile_code
<<Prc external: procedures>>=
  module subroutine prc_external_writer_write_makefile_code &
       (writer, unit, id, os_data, verbose, testflag)
    class(prc_external_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: verbose
    logical, intent(in), optional :: testflag
    type(string_t) :: omega_binary, omega_path
    type(string_t) :: restrictions_string, amp_triv_string
    omega_binary = "omega_" // writer%model_name // ".opt"
    omega_path = os_data%whizard_omega_binpath // "/" // omega_binary
    if (.not. verbose)  omega_path = "@" // omega_path
    if (writer%restrictions /= "") then
       restrictions_string = " -cascade '" // writer%restrictions // "'"
    else
       restrictions_string = ""
    end if
    amp_triv_string = ""
    if (writer%amp_triv)  amp_triv_string = " -target:amp_triv"
    write (unit, "(5A)")  "OBJECTS += ", char (id), ".lo"
    write (unit, "(5A)")  char (id), ".f90:"
    if (.not. verbose) then
       write (unit, "(5A)")  TAB // '@echo  "  OMEGA     ', trim (char (id)), '.f90"'
    end if
    write (unit, "(99A)")  TAB, char (omega_path), &
         " -o ", char (id), ".f90", &
         " -target:whizard", char (amp_triv_string), &
         " -target:parameter_module parameters_", char (writer%model_name), &
         " -target:module opr_", char (id), &
         " -target:md5sum '", writer%md5sum, "'", &
         char (writer%process_mode), char (writer%process_string), &
         char (restrictions_string)
    write (unit, "(5A)")  "clean-", char (id), ":"
    write (unit, "(5A)")  TAB, "rm -f ", char (id), ".f90"
    write (unit, "(5A)")  TAB, "rm -f opr_", char (id), ".mod"
    write (unit, "(5A)")  TAB, "rm -f ", char (id), ".lo"
    write (unit, "(5A)")  "CLEAN_SOURCES += ", char (id), ".f90"
    write (unit, "(5A)")  "CLEAN_OBJECTS += opr_", char (id), ".mod"
    write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), ".lo"
    write (unit, "(5A)")  char (id), ".lo: ", char (id), ".f90"
    if (.not. verbose) then
       write (unit, "(5A)")  TAB // '@echo  "  FC       " $@'
    end if
    write (unit, "(5A)")  TAB, "$(LTFCOMPILE) $<"

  end subroutine prc_external_writer_write_makefile_code

@ %def prc_external_writer_write_makefile_code
@
<<Prc external: external writer: TBP>>=
  procedure, nopass:: get_procname => prc_external_writer_writer_get_procname
<<Prc external: sub interfaces>>=
    module function prc_external_writer_writer_get_procname &
         (feature) result (name)
      type(string_t) :: name
      type(string_t), intent(in) :: feature
    end function prc_external_writer_writer_get_procname
<<Prc external: procedures>>=
  module function prc_external_writer_writer_get_procname &
       (feature) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: feature
    select case (char (feature))
    case ("n_in");   name = "number_particles_in"
    case ("n_out");  name = "number_particles_out"
    case ("n_flv");  name = "number_flavor_states"
    case ("n_hel");  name = "number_spin_states"
    case ("n_col");  name = "number_color_flows"
    case ("n_cin");  name = "number_color_indices"
    case ("n_cf");   name = "number_color_factors"
    case ("flv_state");  name = "flavor_states"
    case ("hel_state");  name = "spin_states"
    case ("col_state");  name = "color_flows"
    case default
       name = feature
    end select
  end function prc_external_writer_writer_get_procname

@ %def prc_external_writer_writer_get_procname
@
\subsection{external test}
\subsubsection{Writer}
<<Prc external: public>>=
  public :: prc_external_test_writer_t
<<Prc external: types>>=
  type, extends (prc_external_writer_t) :: prc_external_test_writer_t
  contains
  <<Prc external: external test writer: TBP>>
  end type prc_external_test_writer_t

@ %def prc_external_test_writer_t
@
<<Prc external: external test writer: TBP>>=
  procedure, nopass :: type_name => prc_external_test_writer_type_name
<<Prc external: sub interfaces>>=
    module function prc_external_test_writer_type_name () result (string)
      type(string_t) :: string
    end function prc_external_test_writer_type_name
<<Prc external: procedures>>=
  module function prc_external_test_writer_type_name () result (string)
    type(string_t) :: string
    string = "External matrix element dummy"
  end function prc_external_test_writer_type_name

@ %def prc_external_test_writer_type_name
@
\subsubsection{Workspace}
This looks pretty useless. Why don't we make [[prc_external_state_t]]
nonabstract and remove this?
<<Prc external: public>>=
  public :: prc_external_test_state_t
<<Prc external: types>>=
  type, extends (prc_external_state_t) :: prc_external_test_state_t
  contains
  <<Prc external: external test state: TBP>>
  end type prc_external_test_state_t

@ %def prc_external_test_state_t
@
<<Prc external: external test state: TBP>>=
  procedure :: write => prc_external_test_state_write
<<Prc external: sub interfaces>>=
    module subroutine prc_external_test_state_write (object, unit)
      class(prc_external_test_state_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine prc_external_test_state_write
<<Prc external: procedures>>=
  module subroutine prc_external_test_state_write (object, unit)
    class(prc_external_test_state_t), intent(in) :: object
    integer, intent(in), optional :: unit
  end subroutine prc_external_test_state_write

@ %def prc_external_test_state_write
@
\subsubsection{Driver}
<<Prc external: public>>=
  public :: prc_external_test_driver_t
<<Prc external: types>>=
  type, extends (prc_external_driver_t) :: prc_external_test_driver_t
  contains
  <<Prc external: external test driver: TBP>>
  end type prc_external_test_driver_t

@ %def prc_external_test_driver_t
@
<<Prc external: external test driver: TBP>>=
  procedure, nopass :: type_name => prc_external_test_driver_type_name
<<Prc external: sub interfaces>>=
    module function prc_external_test_driver_type_name () result (type)
      type(string_t) :: type
    end function prc_external_test_driver_type_name
<<Prc external: procedures>>=
  module function prc_external_test_driver_type_name () result (type)
    type(string_t) :: type
    type = "External matrix element dummy"
  end function prc_external_test_driver_type_name

@ %def prc_external_test_driver_type_name
@
\subsubsection{Configuration}
A external test definition.
<<Prc external: public>>=
  public :: prc_external_test_def_t
<<Prc external: types>>=
  type, extends (prc_external_def_t) :: prc_external_test_def_t
  contains
  <<Prc external: external test def: TBP>>
  end type prc_external_test_def_t

@ %def prc_external_test_def_t
@ Gfortran 7/8/9 bug, has to remain in the main module.
<<Prc external: external test def: TBP>>=
  procedure :: init => prc_external_test_def_init
<<Prc external: main procedures>>=
  subroutine prc_external_test_def_init (object, basename, model_name, &
       prt_in, prt_out)
    class(prc_external_test_def_t), intent(inout) :: object
    type(string_t), intent(in) :: basename, model_name
    type(string_t), dimension(:), intent(in) :: prt_in, prt_out
    object%basename = basename
    allocate (prc_external_test_writer_t :: object%writer)
    select type (writer => object%writer)
    type is (prc_external_test_writer_t)
       call writer%init (model_name, prt_in, prt_out)
    end select
  end subroutine prc_external_test_def_init

@ %def prc_external_test_def_init
@
<<Prc external: external test def: TBP>>=
  procedure, nopass :: type_string => prc_external_test_def_type_string
<<Prc external: sub interfaces>>=
    module function prc_external_test_def_type_string () result (string)
      type(string_t) :: string
    end function prc_external_test_def_type_string
<<Prc external: procedures>>=
  module function prc_external_test_def_type_string () result (string)
    type(string_t) :: string
    string = "external test dummy"
  end function prc_external_test_def_type_string

@ %def prc_external_def_type_string
@
<<Prc external: external test def: TBP>>=
  procedure :: write => prc_external_test_def_write
<<Prc external: sub interfaces>>=
    module subroutine prc_external_test_def_write (object, unit)
      class(prc_external_test_def_t), intent(in) :: object
      integer, intent(in) :: unit
    end subroutine prc_external_test_def_write
<<Prc external: procedures>>=
  module subroutine prc_external_test_def_write (object, unit)
    class(prc_external_test_def_t), intent(in) :: object
    integer, intent(in) :: unit
  end subroutine prc_external_test_def_write

@ %def prc_external_test_def_write
@
<<Prc external: external test def: TBP>>=
  procedure :: read => prc_external_test_def_read
<<Prc external: sub interfaces>>=
    module subroutine prc_external_test_def_read (object, unit)
      class(prc_external_test_def_t), intent(out) :: object
      integer, intent(in) :: unit
    end subroutine prc_external_test_def_read
<<Prc external: procedures>>=
  module subroutine prc_external_test_def_read (object, unit)
    class(prc_external_test_def_t), intent(out) :: object
    integer, intent(in) :: unit
  end subroutine prc_external_test_def_read

@ %def prc_external_test_def_read
@ Gfortran 7/8/9 bug, has to remain in the main module.
<<Prc external: external test def: TBP>>=
  procedure :: allocate_driver => prc_external_test_def_allocate_driver
<<Prc external: main procedures>>=
  subroutine prc_external_test_def_allocate_driver (object, driver, basename)
    class(prc_external_test_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    if (.not. allocated (driver)) &
         allocate (prc_external_test_driver_t :: driver)
  end subroutine prc_external_test_def_allocate_driver

@ %def prc_external_test_def_allocate_driver
@
\subsubsection{Core}
This external test just returns $|\mathcal{M}|^2=1$ and thus the
result of the integration is the n-particle-phase-space volume.
<<Prc external: public>>=
  public :: prc_external_test_t
<<Prc external: types>>=
  type, extends (prc_external_t) :: prc_external_test_t
  contains
  <<Prc external: prc test: TBP>>
  end type prc_external_test_t

@ %def prc_external_test_t
@
<<Prc external: prc test: TBP>>=
  procedure :: write => prc_external_test_write
<<Prc external: sub interfaces>>=
    module subroutine prc_external_test_write (object, unit)
      class(prc_external_test_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine prc_external_test_write
<<Prc external: procedures>>=
  module subroutine prc_external_test_write (object, unit)
    class(prc_external_test_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call msg_message ("Test external matrix elements")
  end subroutine prc_external_test_write

@ %def prc_external_write
@
<<Prc external: prc test: TBP>>=
  procedure :: write_name => prc_external_test_write_name
<<Prc external: sub interfaces>>=
    module subroutine prc_external_test_write_name (object, unit)
      class(prc_external_test_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine prc_external_test_write_name
<<Prc external: procedures>>=
  module subroutine prc_external_test_write_name (object, unit)
    class(prc_external_test_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u,"(1x,A)") "Core: external test"
  end subroutine prc_external_test_write_name

@ %def prc_external_test_write_name
@
<<Prc external: prc test: TBP>>=
  procedure :: compute_amplitude => prc_external_test_compute_amplitude
<<Prc external: sub interfaces>>=
    module function prc_external_test_compute_amplitude &
         (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
         core_state)  result (amp)
      class(prc_external_test_t), intent(in) :: object
      integer, intent(in) :: j
      type(vector4_t), dimension(:), intent(in) :: p
      integer, intent(in) :: f, h, c
      real(default), intent(in) :: fac_scale, ren_scale
      real(default), intent(in), allocatable :: alpha_qcd_forced
      class(prc_core_state_t), intent(inout), allocatable, optional :: &
           core_state
      complex(default) :: amp
    end function prc_external_test_compute_amplitude
<<Prc external: procedures>>=
  module function prc_external_test_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
       core_state)  result (amp)
    class(prc_external_test_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: core_state
    complex(default) :: amp
    select type (core_state)
    class is (prc_external_test_state_t)
       core_state%alpha_qcd = object%qcd%alpha%get (ren_scale)
    end select
    amp = 0.0
  end function prc_external_test_compute_amplitude

@ %def prc_external_test_compute_amplitude
@ Gfortran 7/8/9 bug, has to remain in the main module.
<<Prc external: prc test: TBP>>=
  procedure :: allocate_workspace => prc_external_test_allocate_workspace
<<Prc external: main procedures>>=
  subroutine prc_external_test_allocate_workspace (object, core_state)
    class(prc_external_test_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    allocate (prc_external_test_state_t :: core_state)
  end subroutine prc_external_test_allocate_workspace

@ %def prc_external_test_allocate_workspace
@
<<Prc external: prc test: TBP>>=
  procedure :: includes_polarization => &
       prc_external_test_includes_polarization
<<Prc external: sub interfaces>>=
    module function prc_external_test_includes_polarization &
         (object) result (polarized)
      logical :: polarized
      class(prc_external_test_t), intent(in) :: object
    end function prc_external_test_includes_polarization
<<Prc external: procedures>>=
  module function prc_external_test_includes_polarization &
       (object) result (polarized)
    logical :: polarized
    class(prc_external_test_t), intent(in) :: object
    polarized = .false.
  end function prc_external_test_includes_polarization

@ %def prc_external_test_includes_polarization
@
<<Prc external: prc test: TBP>>=
  procedure :: prepare_external_code => &
       prc_external_test_prepare_external_code
<<Prc external: sub interfaces>>=
    module subroutine prc_external_test_prepare_external_code &
         (core, flv_states, var_list, os_data, libname, model, i_core, is_nlo)
      class(prc_external_test_t), intent(inout) :: core
      integer, intent(in), dimension(:,:), allocatable :: flv_states
      type(var_list_t), intent(in) :: var_list
      type(os_data_t), intent(in) :: os_data
      type(string_t), intent(in) :: libname
      type(model_data_t), intent(in), target :: model
      integer, intent(in) :: i_core
      logical, intent(in) :: is_nlo
    end subroutine prc_external_test_prepare_external_code
<<Prc external: procedures>>=
  module subroutine prc_external_test_prepare_external_code &
       (core, flv_states, var_list, os_data, libname, model, i_core, is_nlo)
    class(prc_external_test_t), intent(inout) :: core
    integer, intent(in), dimension(:,:), allocatable :: flv_states
    type(var_list_t), intent(in) :: var_list
    type(os_data_t), intent(in) :: os_data
    type(string_t), intent(in) :: libname
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: i_core
    logical, intent(in) :: is_nlo
  end subroutine prc_external_test_prepare_external_code

@ %def prc_external_test_prepare_external_code
@
\subsection{Threshold}
<<[[prc_threshold.f90]]>>=
<<File header>>
module prc_threshold

  use, intrinsic :: iso_c_binding !NODEP!

  use kinds
<<Use strings>>
<<Use debug>>
  use physics_defs
  use diagnostics
  use os_interface
  use lorentz
  use interactions
  use model_data
  use variables, only: var_list_t

  use prclib_interfaces
  use process_libraries
  use prc_core_def
  use prc_core
  use prc_external

<<Standard module head>>

<<Prc threshold: public>>

<<Prc threshold: interfaces>>

<<Prc threshold: types>>

  interface
<<Prc threshold: sub interfaces>>
  end interface

contains

<<Prc threshold: main procedures>>

end module prc_threshold
@ %def prc_threshold
@
<<[[prc_threshold_sub.f90]]>>=
<<File header>>

submodule (prc_threshold) prc_threshold_s

  use constants
  use numeric_utils
  use string_utils, only: lower_case
  use io_units
  use system_defs, only: TAB
  use sm_qcd

  implicit none

contains

<<Prc threshold: procedures>>

end submodule prc_threshold_s

@ %def prc_threshold_s
@
\subsubsection{Writer}
<<Prc threshold: public>>=
  public :: threshold_writer_t
<<Prc threshold: types>>=
  type, extends (prc_external_writer_t) :: threshold_writer_t
     integer :: nlo_type
  contains
  <<Prc threshold: threshold writer: TBP>>
  end type threshold_writer_t

@ %def threshold_writer_t
@
<<Prc threshold: threshold writer: TBP>>=
  procedure :: init => threshold_writer_init
<<Prc threshold: sub interfaces>>=
    pure module subroutine threshold_writer_init &
         (writer, model_name, prt_in, prt_out, restrictions)
      class(threshold_writer_t), intent(inout) :: writer
      type(string_t), intent(in) :: model_name
      type(string_t), dimension(:), intent(in) :: prt_in, prt_out
      type(string_t), intent(in), optional :: restrictions
    end subroutine threshold_writer_init
<<Prc threshold: procedures>>=
  pure module subroutine threshold_writer_init &
       (writer, model_name, prt_in, prt_out, restrictions)
    class(threshold_writer_t), intent(inout) :: writer
    type(string_t), intent(in) :: model_name
    type(string_t), dimension(:), intent(in) :: prt_in, prt_out
    type(string_t), intent(in), optional :: restrictions
    call writer%base_init (model_name, prt_in, prt_out, restrictions)
    writer%amp_triv = .false.
  end subroutine threshold_writer_init

@ %def threshold_writer_init
@
<<Prc threshold: threshold writer: TBP>>=
  procedure :: write_makefile_extra => threshold_writer_write_makefile_extra
<<Prc threshold: sub interfaces>>=
    module subroutine threshold_writer_write_makefile_extra &
         (writer, unit, id, os_data, verbose, nlo_type)
      class(threshold_writer_t), intent(in) :: writer
      integer, intent(in) :: unit
      type(string_t), intent(in) :: id
      type(os_data_t), intent(in) :: os_data
      logical, intent(in) :: verbose
      integer, intent(in) :: nlo_type
    end subroutine threshold_writer_write_makefile_extra
<<Prc threshold: procedures>>=
  module subroutine threshold_writer_write_makefile_extra &
       (writer, unit, id, os_data, verbose, nlo_type)
    class(threshold_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: verbose
    integer, intent(in) :: nlo_type
    type(string_t) :: f90in, f90, lo, extra
    if (debug_on) call msg_debug &
         (D_ME_METHODS, "threshold_writer_write_makefile_extra")
    if (nlo_type /= BORN) then
       extra = "_" // component_status (nlo_type)
    else
       extra = var_str ("")
    end if
    f90 = id // "_threshold" // extra //".f90"
    f90in = f90 // ".in"
    lo = id // "_threshold" // extra // ".lo"
    write (unit, "(A)") "OBJECTS += " // char (lo)
    write (unit, "(A)") char (f90in) // ":"
    write (unit, "(A)") char (TAB // "if ! test -f " // f90in // &
         "; then cp " // os_data%whizard_sharepath // &
         "/SM_tt_threshold_data/threshold" // extra // ".f90 " // &
         f90in // "; fi")
    write (unit, "(A)") char(f90) // ": " // char (f90in)
    write (unit, "(A)") TAB // "sed 's/@ID@/" // char (id) // "/' " // &
         char (f90in) // " > " // char (f90)
    write (unit, "(5A)")  "CLEAN_SOURCES += ", char (f90)
    write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (f90in)
    write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), "_threshold.mod"
    write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (lo)
    write (unit, "(A)") char(lo) // ": " // char (f90) // " " // &
         char(id) // ".f90"
    write (unit, "(5A)")  TAB, "$(LTFCOMPILE) $<"
    if (.not. verbose) then
       write (unit, "(5A)")  TAB // '@echo  "  FC       " $@'
    end if
  end subroutine threshold_writer_write_makefile_extra

@ %def threshold_writer_write_makefile_extra
@
<<Prc threshold: threshold writer: TBP>>=
  procedure :: write_makefile_code => threshold_writer_write_makefile_code
<<Prc threshold: sub interfaces>>=
    module subroutine threshold_writer_write_makefile_code &
         (writer, unit, id, os_data, verbose, testflag)
      class(threshold_writer_t), intent(in) :: writer
      integer, intent(in) :: unit
      type(string_t), intent(in) :: id
      type(os_data_t), intent(in) :: os_data
      logical, intent(in) :: verbose
      logical, intent(in), optional :: testflag
    end subroutine threshold_writer_write_makefile_code
<<Prc threshold: procedures>>=
  module subroutine threshold_writer_write_makefile_code &
       (writer, unit, id, os_data, verbose, testflag)
    class(threshold_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: verbose
    logical, intent(in), optional :: testflag
    if (debug_on) &
         call msg_debug (D_ME_METHODS, "threshold_writer_write_makefile_code")
    call writer%base_write_makefile_code &
         (unit, id, os_data, verbose, testflag = testflag)
    call writer%write_makefile_extra (unit, id, os_data, verbose, BORN)
    if (writer%nlo_type == NLO_VIRTUAL .and. writer%active) &
         call writer%write_makefile_extra (unit, id, os_data, verbose, writer%nlo_type)
  end subroutine threshold_writer_write_makefile_code

@ %def threshold_writer_write_makefile_code
@
<<Prc threshold: threshold writer: TBP>>=
  procedure, nopass :: type_name => threshold_writer_type_name
<<Prc threshold: sub interfaces>>=
    module function threshold_writer_type_name () result (string)
      type(string_t) :: string
    end function threshold_writer_type_name
<<Prc threshold: procedures>>=
  module function threshold_writer_type_name () result (string)
    type(string_t) :: string
    string = "Threshold"
  end function threshold_writer_type_name

@ %def threshold_writer_type_name
@
\subsubsection{Driver}
<<Prc threshold: public>>=
  public :: threshold_set_process_mode
<<Prc threshold: interfaces>>=
  interface
    subroutine threshold_set_process_mode (mode) bind(C)
      import
      integer(kind = c_int), intent(in) :: mode
    end subroutine threshold_set_process_mode
  end interface

@ %def threshold_set_process_mode
@
<<Prc threshold: public>>=
  public :: threshold_get_amp_squared
<<Prc threshold: interfaces>>=
  interface
    subroutine threshold_get_amp_squared (amp2, p_ofs, p_ons, leg, n_tot, sel_hel_beam) bind(C)
      import
      real(c_default_float), intent(out) :: amp2
      real(c_default_float), dimension(0:3,*), intent(in) :: p_ofs
      real(c_default_float), dimension(0:3,*), intent(in) :: p_ons
      integer(kind = c_int) :: n_tot, leg, sel_hel_beam
    end subroutine threshold_get_amp_squared
  end interface

@ %def threshold_get_amp_squared
@
<<Prc threshold: public>>=
  public :: threshold_olp_eval2
<<Prc threshold: interfaces>>=
  interface
    subroutine threshold_olp_eval2 (i_flv, alpha_s_c, parray, mu_c, &
           sel_hel_beam, sqme_c, acc_c) bind(C)
      import
      integer(c_int), intent(in) :: i_flv
      real(c_default_float), intent(in) :: alpha_s_c
      real(c_default_float), dimension(0:3,*), intent(in) :: parray
      real(c_default_float), intent(in) :: mu_c
      integer, intent(in) :: sel_hel_beam
      real(c_default_float), dimension(4), intent(out) :: sqme_c
      real(c_default_float), intent(out) :: acc_c
    end subroutine threshold_olp_eval2
  end interface

@ %def threshold_olp_eval2
@
<<Prc threshold: public>>=
  public :: threshold_init
<<Prc threshold: interfaces>>=
  interface
   subroutine threshold_init (par, scheme) bind(C)
      import
      real(c_default_float), dimension(*), intent(in) :: par
      integer(c_int), intent(in) :: scheme
    end subroutine threshold_init
  end interface

@ %def threshold_init
@
<<Prc threshold: public>>=
  public :: threshold_start_openloops
<<Prc threshold: interfaces>>=
  interface
   subroutine threshold_start_openloops () bind(C)
      import
    end subroutine threshold_start_openloops
  end interface

@ %def threshold_start_openloops
@
<<Prc threshold: public>>=
  public :: threshold_driver_t
<<Prc threshold: types>>=
  type, extends (prc_external_driver_t) :: threshold_driver_t
    procedure(threshold_olp_eval2), nopass, pointer :: &
         olp_eval2 => null ()
    procedure(threshold_set_process_mode), nopass, pointer :: &
         set_process_mode => null ()
    procedure(threshold_get_amp_squared), nopass, pointer :: &
         get_amp_squared => null ()
    procedure(threshold_start_openloops), nopass, pointer :: &
         start_openloops => null ()
    procedure(threshold_init), nopass, pointer :: &
         init => null ()
    type(string_t) :: id
    integer :: nlo_type = BORN
  contains
  <<Prc threshold: threshold driver: TBP>>
  end type threshold_driver_t

@ %def threshold_driver_t
@
<<Prc threshold: threshold driver: TBP>>=
  procedure, nopass :: type_name => threshold_driver_type_name
<<Prc threshold: sub interfaces>>=
    module function threshold_driver_type_name () result (type)
      type(string_t) :: type
    end function threshold_driver_type_name
<<Prc threshold: procedures>>=
  module function threshold_driver_type_name () result (type)
    type(string_t) :: type
    type = "Threshold"
  end function threshold_driver_type_name

@ %def threshold_driver_type_name
@
<<Prc threshold: threshold driver: TBP>>=
  procedure :: load => threshold_driver_load
<<Prc threshold: sub interfaces>>=
    module subroutine threshold_driver_load (threshold_driver, dlaccess)
      class(threshold_driver_t), intent(inout) :: threshold_driver
      type(dlaccess_t), intent(inout) :: dlaccess
    end subroutine threshold_driver_load
<<Prc threshold: procedures>>=
  module subroutine threshold_driver_load (threshold_driver, dlaccess)
    class(threshold_driver_t), intent(inout) :: threshold_driver
    type(dlaccess_t), intent(inout) :: dlaccess
    type(c_funptr) :: c_fptr
    type(string_t) :: lower_case_id
    if (debug_on) call msg_debug (D_ME_METHODS, "threshold_driver_load")
    lower_case_id = lower_case (threshold_driver%id)
    c_fptr = dlaccess_get_c_funptr (dlaccess, lower_case_id // "_set_process_mode")
    call c_f_procpointer (c_fptr, threshold_driver%set_process_mode)
    call check_for_error (lower_case_id // "_set_process_mode")
    c_fptr = dlaccess_get_c_funptr (dlaccess, lower_case_id // "_get_amp_squared")
    call c_f_procpointer (c_fptr, threshold_driver%get_amp_squared)
    call check_for_error (lower_case_id // "_get_amp_squared")
    c_fptr = dlaccess_get_c_funptr (dlaccess, lower_case_id // "_threshold_init")
    call c_f_procpointer (c_fptr, threshold_driver%init)
    call check_for_error (lower_case_id // "_threshold_init")
    select type (threshold_driver)
    type is (threshold_driver_t)
       if (threshold_driver%nlo_type == NLO_VIRTUAL) then
          c_fptr = dlaccess_get_c_funptr &
               (dlaccess, lower_case_id // "_start_openloops")
          call c_f_procpointer (c_fptr, threshold_driver%start_openloops)
          call check_for_error (lower_case_id // "_start_openloops")
          c_fptr = dlaccess_get_c_funptr (dlaccess, lower_case_id // "_olp_eval2")
          call c_f_procpointer (c_fptr, threshold_driver%olp_eval2)
          call check_for_error (lower_case_id // "_olp_eval2")
       end if
    end select
    call msg_message ("Loaded extra threshold functions")
    contains
      subroutine check_for_error (function_name)
        type(string_t), intent(in) :: function_name
        if (dlaccess_has_error (dlaccess))  call msg_fatal &
             (char ("Loading of " // function_name // " failed!"))
     end subroutine check_for_error
  end subroutine threshold_driver_load

@ %def threshold_driver_load
@
\subsubsection{Configuration}
<<Prc threshold: public>>=
  public :: threshold_def_t
<<Prc threshold: types>>=
  type, extends (prc_external_def_t) :: threshold_def_t
     integer :: nlo_type
  contains
  <<Prc threshold: threshold def: TBP>>
  end type threshold_def_t

@ %def threshold_def_t
@ Gfortran 7/8/9 bug: has to remain in the main module.
<<Prc threshold: threshold def: TBP>>=
  procedure :: init => threshold_def_init
<<Prc threshold: main procedures>>=
  subroutine threshold_def_init (object, basename, model_name, &
       prt_in, prt_out, nlo_type, restrictions)
    class(threshold_def_t), intent(inout) :: object
    type(string_t), intent(in) :: basename, model_name
    type(string_t), dimension(:), intent(in) :: prt_in, prt_out
    integer, intent(in) :: nlo_type
    type(string_t), intent(in), optional :: restrictions
    if (debug_on) call msg_debug (D_ME_METHODS, "threshold_def_init")
    object%basename = basename
    object%nlo_type = nlo_type
    allocate (threshold_writer_t :: object%writer)
    select type (writer => object%writer)
    type is (threshold_writer_t)
       call writer%init (model_name, prt_in, prt_out, restrictions)
       writer%nlo_type = nlo_type
    end select
  end subroutine threshold_def_init

@ %def threshold_def_init
@
<<Prc threshold: threshold def: TBP>>=
  procedure, nopass :: type_string => threshold_def_type_string
<<Prc threshold: sub interfaces>>=
    module function threshold_def_type_string () result (string)
      type(string_t) :: string
    end function threshold_def_type_string
<<Prc threshold: procedures>>=
  module function threshold_def_type_string () result (string)
    type(string_t) :: string
    string = "threshold computation"
  end function threshold_def_type_string

@ %def prc_external_def_type_string
@ [[write]] and [[read]] could be put in the abstract version
<<Prc threshold: threshold def: TBP>>=
  procedure :: write => threshold_def_write
<<Prc threshold: sub interfaces>>=
    module subroutine threshold_def_write (object, unit)
      class(threshold_def_t), intent(in) :: object
      integer, intent(in) :: unit
    end subroutine threshold_def_write
<<Prc threshold: procedures>>=
  module subroutine threshold_def_write (object, unit)
    class(threshold_def_t), intent(in) :: object
    integer, intent(in) :: unit
  end subroutine threshold_def_write

@ %def threshold_def_write
@
<<Prc threshold: threshold def: TBP>>=
  procedure :: read => threshold_def_read
<<Prc threshold: sub interfaces>>=
    module subroutine threshold_def_read (object, unit)
      class(threshold_def_t), intent(out) :: object
      integer, intent(in) :: unit
    end subroutine threshold_def_read
<<Prc threshold: procedures>>=
  module subroutine threshold_def_read (object, unit)
    class(threshold_def_t), intent(out) :: object
    integer, intent(in) :: unit
  end subroutine threshold_def_read

@ %def threshold_def_read
@ Gfortran 7/8/9 bug: has to remain in the main module.
<<Prc threshold: threshold def: TBP>>=
  procedure :: allocate_driver => threshold_def_allocate_driver
<<Prc threshold: main procedures>>=
  subroutine threshold_def_allocate_driver (object, driver, basename)
    class(threshold_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    if (debug_on) call msg_debug (D_ME_METHODS, "threshold_def_allocate_driver")
    if (.not. allocated (driver)) allocate (threshold_driver_t :: driver)
    select type (driver)
    type is (threshold_driver_t)
       driver%id = basename
       driver%nlo_type = object%nlo_type
    end select
  end subroutine threshold_def_allocate_driver

@ %def threshold_def_allocate_driver
@
<<Prc threshold: threshold def: TBP>>=
  procedure :: connect => threshold_def_connect
<<Prc threshold: sub interfaces>>=
    module subroutine threshold_def_connect (def, lib_driver, i, proc_driver)
      class(threshold_def_t), intent(in) :: def
      class(prclib_driver_t), intent(in) :: lib_driver
      integer, intent(in) :: i
      class(prc_core_driver_t), intent(inout) :: proc_driver
    end subroutine threshold_def_connect
<<Prc threshold: procedures>>=
  module subroutine threshold_def_connect (def, lib_driver, i, proc_driver)
    class(threshold_def_t), intent(in) :: def
    class(prclib_driver_t), intent(in) :: lib_driver
    integer, intent(in) :: i
    class(prc_core_driver_t), intent(inout) :: proc_driver
    type(dlaccess_t) :: dlaccess
    logical :: skip
    if (debug_on) call msg_debug (D_ME_METHODS, "threshold_def_connect")
    call def%omega_connect (lib_driver, i, proc_driver)
    select type (lib_driver)
    class is (prclib_driver_dynamic_t)
       dlaccess = lib_driver%dlaccess
    end select
    select type (proc_driver)
    class is (threshold_driver_t)
       select type (writer => def%writer)
       type is (threshold_writer_t)
          skip = writer%nlo_type == NLO_VIRTUAL .and. .not. writer%active
          if (.not. skip) call proc_driver%load (dlaccess)
       end select
    end select
  end subroutine threshold_def_connect

@ %def threshold_def_connect
@
\subsubsection{Core state}
<<Prc threshold: public>>=
  public :: threshold_state_t
<<Prc threshold: types>>=
  type, extends (prc_external_state_t) :: threshold_state_t
  contains
  <<Prc threshold: threshold state: TBP>>
  end type threshold_state_t

@ %def threshold_state_t
@
<<Prc threshold: threshold state: TBP>>=
  procedure :: write => threshold_state_write
<<Prc threshold: sub interfaces>>=
    module subroutine threshold_state_write (object, unit)
      class(threshold_state_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine threshold_state_write
<<Prc threshold: procedures>>=
  module subroutine threshold_state_write (object, unit)
    class(threshold_state_t), intent(in) :: object
    integer, intent(in), optional :: unit
  end subroutine threshold_state_write

@ %def threshold_state_write
@
\subsubsection{Core}
<<Prc threshold: public>>=
  public :: prc_threshold_t
<<Prc threshold: types>>=
  type, extends (prc_external_t) :: prc_threshold_t
     real(default), dimension(:,:), allocatable :: parray_ofs
     real(default), dimension(:,:), allocatable :: parray_ons
     integer :: leg
     logical :: has_beam_pol = .false.
  contains
  <<Prc threshold: prc threshold: TBP>>
  end type prc_threshold_t

@ %def prc_threshold_t
@
<<Prc threshold: prc threshold: TBP>>=
  procedure :: write => prc_threshold_write
<<Prc threshold: sub interfaces>>=
    module subroutine prc_threshold_write (object, unit)
      class(prc_threshold_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine prc_threshold_write
<<Prc threshold: procedures>>=
  module subroutine prc_threshold_write (object, unit)
    class(prc_threshold_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call msg_message ("Supply amplitudes squared for threshold computation")
  end subroutine prc_threshold_write

@ %def prc_external_write
@
<<Prc threshold: prc threshold: TBP>>=
  procedure :: write_name => prc_threshold_write_name
<<Prc threshold: sub interfaces>>=
    module subroutine prc_threshold_write_name (object, unit)
      class(prc_threshold_t), intent(in) :: object
      integer, intent(in), optional :: unit
    end subroutine prc_threshold_write_name
<<Prc threshold: procedures>>=
  module subroutine prc_threshold_write_name (object, unit)
    class(prc_threshold_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u,"(1x,A)") "Core: Threshold"
  end subroutine prc_threshold_write_name

@ %def prc_threshold_write_name
@
This core type has the beam polarization as an extra parameter.
<<Prc threshold: prc threshold: TBP>>=
  procedure :: set_beam_pol => prc_threshold_set_beam_pol
<<Prc threshold: sub interfaces>>=
    module subroutine prc_threshold_set_beam_pol (object, has_beam_pol)
      class(prc_threshold_t), intent(inout) :: object
      logical, intent(in), optional :: has_beam_pol
    end subroutine prc_threshold_set_beam_pol
<<Prc threshold: procedures>>=
  module subroutine prc_threshold_set_beam_pol (object, has_beam_pol)
    class(prc_threshold_t), intent(inout) :: object
    logical, intent(in), optional :: has_beam_pol
    if (present (has_beam_pol)) then
       object%has_beam_pol = has_beam_pol
    end if
  end subroutine prc_threshold_set_beam_pol

@ %def prc_threshold_set_beam_pol
@
<<Prc threshold: prc threshold: TBP>>=
  procedure :: compute_amplitude => prc_threshold_compute_amplitude
<<Prc threshold: sub interfaces>>=
    module function prc_threshold_compute_amplitude &
         (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
         core_state)  result (amp)
      class(prc_threshold_t), intent(in) :: object
      integer, intent(in) :: j
      type(vector4_t), dimension(:), intent(in) :: p
      integer, intent(in) :: f, h, c
      real(default), intent(in) :: fac_scale, ren_scale
      real(default), intent(in), allocatable :: alpha_qcd_forced
      class(prc_core_state_t), intent(inout), allocatable, optional :: &
           core_state
      complex(default) :: amp
    end function prc_threshold_compute_amplitude
<<Prc threshold: procedures>>=
  module function prc_threshold_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
       core_state)  result (amp)
    class(prc_threshold_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: core_state
    complex(default) :: amp
    select type (core_state)
    class is (prc_external_test_state_t)
       core_state%alpha_qcd = object%qcd%alpha%get (ren_scale)
    end select
    amp = 0
  end function prc_threshold_compute_amplitude

@ %def prc_threshold_compute_amplitude
@ Gfortran 7/8/9 bug: has to remain in the main module.
<<Prc threshold: prc threshold: TBP>>=
  procedure :: allocate_workspace => prc_threshold_allocate_workspace
<<Prc threshold: main procedures>>=
  subroutine prc_threshold_allocate_workspace (object, core_state)
    class(prc_threshold_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    allocate (threshold_state_t :: core_state)
  end subroutine prc_threshold_allocate_workspace

@ %def prc_threshold_allocate_workspace
@
<<Prc threshold: prc threshold: TBP>>=
  procedure :: set_offshell_momenta => prc_threshold_set_offshell_momenta
<<Prc threshold: sub interfaces>>=
    module subroutine prc_threshold_set_offshell_momenta (object, p)
      class(prc_threshold_t), intent(inout) :: object
      type(vector4_t), intent(in), dimension(:) :: p
    end subroutine prc_threshold_set_offshell_momenta
<<Prc threshold: procedures>>=
  module subroutine prc_threshold_set_offshell_momenta (object, p)
    class(prc_threshold_t), intent(inout) :: object
    type(vector4_t), intent(in), dimension(:) :: p
    integer :: i
    do i = 1, size(p)
       object%parray_ofs(:,i) = p(i)%p
    end do
  end subroutine prc_threshold_set_offshell_momenta

@ %def prc_threshold_set_offshell_momenta
@
<<Prc threshold: prc threshold: TBP>>=
  procedure :: set_onshell_momenta => prc_threshold_set_onshell_momenta
<<Prc threshold: sub interfaces>>=
    module subroutine prc_threshold_set_onshell_momenta (object, p)
      class(prc_threshold_t), intent(inout) :: object
      type(vector4_t), intent(in), dimension(:) :: p
    end subroutine prc_threshold_set_onshell_momenta
<<Prc threshold: procedures>>=
  module subroutine prc_threshold_set_onshell_momenta (object, p)
    class(prc_threshold_t), intent(inout) :: object
    type(vector4_t), intent(in), dimension(:) :: p
    integer :: i
    do  i = 1, size(p)
       object%parray_ons(:,i) = p(i)%p
    end do
  end subroutine prc_threshold_set_onshell_momenta

@ %def prc_threshold_set_onshell_momenta
@
<<Prc threshold: prc threshold: TBP>>=
  procedure :: set_leg => prc_threshold_set_leg
<<Prc threshold: sub interfaces>>=
    module subroutine prc_threshold_set_leg (object, leg)
      class(prc_threshold_t), intent(inout) :: object
      integer, intent(in) :: leg
    end subroutine prc_threshold_set_leg
<<Prc threshold: procedures>>=
  module subroutine prc_threshold_set_leg (object, leg)
    class(prc_threshold_t), intent(inout) :: object
    integer, intent(in) :: leg
    object%leg = leg
  end subroutine prc_threshold_set_leg

@ %def prc_threshold_set_leg
@
<<Prc threshold: prc threshold: TBP>>=
  procedure :: set_process_mode => prc_threshold_set_process_mode
<<Prc threshold: sub interfaces>>=
    module subroutine prc_threshold_set_process_mode (object, mode)
      class(prc_threshold_t), intent(in) :: object
      integer(kind = c_int), intent(in) :: mode
    end subroutine prc_threshold_set_process_mode
<<Prc threshold: procedures>>=
  module subroutine prc_threshold_set_process_mode (object, mode)
    class(prc_threshold_t), intent(in) :: object
    integer(kind = c_int), intent(in) :: mode
    select type (driver => object%driver)
    class is (threshold_driver_t)
       if (associated (driver%set_process_mode)) &
            call driver%set_process_mode (mode)
    end select
  end subroutine prc_threshold_set_process_mode

@ %def prc_threshold_set_process_mode
@
<<Prc threshold: prc threshold: TBP>>=
  procedure :: compute_sqme => prc_threshold_compute_sqme
<<Prc threshold: sub interfaces>>=
    module subroutine prc_threshold_compute_sqme (object, i_flv, i_hel, p, &
           ren_scale, sqme, bad_point)
      class(prc_threshold_t), intent(in) :: object
      integer, intent(in) :: i_flv, i_hel
      type(vector4_t), intent(in), dimension(:) :: p
      real(default), intent(in) :: ren_scale
      real(default), intent(out) :: sqme
      logical, intent(out) :: bad_point
    end subroutine prc_threshold_compute_sqme
<<Prc threshold: procedures>>=
  module subroutine prc_threshold_compute_sqme (object, i_flv, i_hel, p, &
         ren_scale, sqme, bad_point)
    class(prc_threshold_t), intent(in) :: object
    integer, intent(in) :: i_flv, i_hel
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale
    real(default), intent(out) :: sqme
    logical, intent(out) :: bad_point
    integer :: n_tot
    if (debug_on) call msg_debug2 (D_ME_METHODS, "prc_threshold_compute_sqme")
    n_tot = size (p)
    select type (driver => object%driver)
    class is (threshold_driver_t)
       if (object%has_beam_pol) then
          call driver%get_amp_squared (sqme, object%parray_ofs, &
               object%parray_ons, object%leg, n_tot, i_flv - 1)
       else
          call driver%get_amp_squared (sqme, object%parray_ofs, &
               object%parray_ons, object%leg, n_tot, -1)
       end if
    end select
    bad_point = .false.
  end subroutine prc_threshold_compute_sqme

@ %def prc_threshold_compute_sqme
@
<<Prc threshold: prc threshold: TBP>>=
  procedure :: compute_sqme_virt => prc_threshold_compute_sqme_virt
<<Prc threshold: sub interfaces>>=
    module subroutine prc_threshold_compute_sqme_virt (object, i_flv, i_hel, &
           p, ren_scale, es_scale, loop_method, sqme, bad_point)
      class(prc_threshold_t), intent(in) :: object
      integer, intent(in) :: i_flv, i_hel
      type(vector4_t), dimension(:), intent(in) :: p
      real(default), intent(in) :: ren_scale, es_scale
      integer, intent(in) :: loop_method
      real(default), dimension(4), intent(out) :: sqme
      real(c_default_float), dimension(:,:), allocatable, save :: parray
      logical, intent(out) :: bad_point
    end subroutine prc_threshold_compute_sqme_virt
<<Prc threshold: procedures>>=
  module subroutine prc_threshold_compute_sqme_virt (object, i_flv, i_hel, &
         p, ren_scale, es_scale, loop_method, sqme, bad_point)
    class(prc_threshold_t), intent(in) :: object
    integer, intent(in) :: i_flv, i_hel
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), intent(in) :: ren_scale, es_scale
    integer, intent(in) :: loop_method
    real(default), dimension(4), intent(out) :: sqme
    real(c_default_float), dimension(:,:), allocatable, save :: parray
    logical, intent(out) :: bad_point
    integer :: n_tot, i
    real(default) :: mu
    real(c_default_float), dimension(4) :: sqme_c
    real(c_default_float) :: mu_c, acc_c, alpha_s_c
    integer(c_int) :: i_flv_c
    if (debug_on) call msg_debug2 (D_ME_METHODS, "prc_threshold_compute_sqme_virt")
    n_tot = size (p)
    if (allocated (parray)) then
       if (size(parray) /= n_tot) deallocate (parray)
    end if
    if (.not. allocated (parray))  allocate (parray (0:3, n_tot))
    forall (i = 1:n_tot)  parray(:,i) = p(i)%p

    if (vanishes (ren_scale)) then
      mu = sqrt (2* (p(1)*p(2)))
    else
      mu = ren_scale
    end if
    mu_c = mu
    alpha_s_c = object%qcd%alpha%get (mu)
    i_flv_c = i_flv
    select type (driver => object%driver)
    class is (threshold_driver_t)
       if (associated (driver%olp_eval2)) then
          if (object%has_beam_pol) then
             call driver%olp_eval2 (1, alpha_s_c, &
                  parray, mu_c, i_flv_c - 1, sqme_c, acc_c)
          else
             call driver%olp_eval2 (i_flv_c, alpha_s_c, &
                  parray, mu_c, -1, sqme_c, acc_c)
          end if
          bad_point = real(acc_c, kind=default) > object%maximum_accuracy
          sqme = sqme_c
       else
          sqme = 0._default
          bad_point = .true.
       end if
    end select
  end subroutine prc_threshold_compute_sqme_virt

@ %def prc_threshold_compute_sqme_virt
@
<<Prc threshold: prc threshold: TBP>>=
  procedure :: init => prc_threshold_init
<<Prc threshold: sub interfaces>>=
    module subroutine prc_threshold_init (object, def, lib, id, i_component)
      class(prc_threshold_t), intent(inout) :: object
      class(prc_core_def_t), intent(in), target :: def
      type(process_library_t), intent(in), target :: lib
      type(string_t), intent(in) :: id
      integer, intent(in) :: i_component
    end subroutine prc_threshold_init
<<Prc threshold: procedures>>=
  module subroutine prc_threshold_init (object, def, lib, id, i_component)
    class(prc_threshold_t), intent(inout) :: object
    class(prc_core_def_t), intent(in), target :: def
    type(process_library_t), intent(in), target :: lib
    type(string_t), intent(in) :: id
    integer, intent(in) :: i_component
    integer :: n_tot
    call object%base_init (def, lib, id, i_component)
    n_tot = object%data%n_in + object%data%n_out
    allocate (object%parray_ofs (0:3,n_tot), object%parray_ons (0:3,n_tot))
    if (n_tot == 4) then
       call object%set_process_mode (PROC_MODE_TT)
    else
       call object%set_process_mode (PROC_MODE_WBWB)
    end if
    call object%activate_parameters ()
  end subroutine prc_threshold_init

@ %def prc_threshold_init
@ Activate the stored parameters by transferring them to the external
matrix element.
<<Prc threshold: prc threshold: TBP>>=
  procedure :: activate_parameters => prc_threshold_activate_parameters
<<Prc threshold: sub interfaces>>=
    module subroutine prc_threshold_activate_parameters (object)
      class (prc_threshold_t), intent(inout) :: object
    end subroutine prc_threshold_activate_parameters
<<Prc threshold: procedures>>=
  module subroutine prc_threshold_activate_parameters (object)
    class (prc_threshold_t), intent(inout) :: object
    if (debug_on) &
         call msg_debug (D_ME_METHODS, "prc_threshold_activate_parameters")
    if (allocated (object%driver)) then
       if (allocated (object%par)) then
          select type (driver => object%driver)
          type is (threshold_driver_t)
             if (associated (driver%init)) then
                call driver%init (object%par, object%scheme)
             end if
          end select
       else
          call msg_bug &
               ("prc_threshold_activate: parameter set is not allocated")
       end if
    else
       call msg_bug ("prc_threshold_activate: driver is not allocated")
    end if
  end subroutine prc_threshold_activate_parameters

@ %def prc_threshold_activate_parameters
@
<<Prc threshold: prc threshold: TBP>>=
  procedure :: prepare_external_code => &
       prc_threshold_prepare_external_code
<<Prc threshold: sub interfaces>>=
    module subroutine prc_threshold_prepare_external_code &
         (core, flv_states, var_list, os_data, libname, model, i_core, is_nlo)
      class(prc_threshold_t), intent(inout) :: core
      integer, intent(in), dimension(:,:), allocatable :: flv_states
      type(var_list_t), intent(in) :: var_list
      type(os_data_t), intent(in) :: os_data
      type(string_t), intent(in) :: libname
      type(model_data_t), intent(in), target :: model
      integer, intent(in) :: i_core
      logical, intent(in) :: is_nlo
    end subroutine prc_threshold_prepare_external_code
<<Prc threshold: procedures>>=
  module subroutine prc_threshold_prepare_external_code &
       (core, flv_states, var_list, os_data, libname, model, i_core, is_nlo)
    class(prc_threshold_t), intent(inout) :: core
    integer, intent(in), dimension(:,:), allocatable :: flv_states
    type(var_list_t), intent(in) :: var_list
    type(os_data_t), intent(in) :: os_data
    type(string_t), intent(in) :: libname
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: i_core
    logical, intent(in) :: is_nlo
    if (debug_on) call msg_debug (D_ME_METHODS, &
         "prc_threshold_prepare_external_code")
    if (allocated (core%driver)) then
       select type (driver => core%driver)
       type is (threshold_driver_t)
          if (driver%nlo_type == NLO_VIRTUAL) call driver%start_openloops ()
       end select
    else
       call msg_bug ("prc_threshold_prepare_external_code: " &
            // "driver is not allocated")
    end if
  end subroutine prc_threshold_prepare_external_code

@ %def prc_threshold_prepare_external_code
@
<<Prc threshold: prc threshold: TBP>>=
  procedure :: includes_polarization => prc_threshold_includes_polarization
<<Prc threshold: sub interfaces>>=
    module function prc_threshold_includes_polarization &
         (object) result (polarized)
      logical :: polarized
      class(prc_threshold_t), intent(in) :: object
    end function prc_threshold_includes_polarization
<<Prc threshold: procedures>>=
  module function prc_threshold_includes_polarization &
       (object) result (polarized)
    logical :: polarized
    class(prc_threshold_t), intent(in) :: object
    polarized = object%has_beam_pol
  end function prc_threshold_includes_polarization

@ %def prc_threshold_includes_polarization
@
